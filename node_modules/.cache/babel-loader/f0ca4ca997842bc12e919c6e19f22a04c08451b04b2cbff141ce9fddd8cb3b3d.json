{"ast":null,"code":"import { _ as _classPrivateFieldInitSpec, a as _classPrivateFieldSet, b as _classPrivateFieldGet } from '../../../../dist/classPrivateFieldSet-a5db7c83.browser.esm.js';\nimport { _ as _defineProperty } from '../../../../dist/defineProperty-c8ecdc07.browser.esm.js';\nimport { a as ConnectorNotFoundError, U as UserRejectedRequestError, R as ResourceUnavailableError } from '../../../../dist/errors-d961f852.browser.esm.js';\nimport { w as walletIds } from '../../../../dist/walletIds-e41b240b.browser.esm.js';\nimport { InjectedConnector } from '../../injected/dist/thirdweb-dev-wallets-evm-connectors-injected.browser.esm.js';\nimport { utils } from 'ethers';\nimport { g as getInjectedMetamaskProvider } from '../../../../dist/getInjectedMetamaskProvider-928dd9c3.browser.esm.js';\nimport '../../../../dist/assertWindowEthereum-b48c1686.browser.esm.js';\nimport '../../../../dist/url-bc88b2b6.browser.esm.js';\nimport '@thirdweb-dev/chains';\nimport '../../../../dist/WagmiConnector-2f14002d.browser.esm.js';\nimport 'eventemitter3';\nimport '../../../../dist/normalizeChainId-e4cc0175.browser.esm.js';\nvar _UNSTABLE_shimOnConnectSelectAccount = /*#__PURE__*/new WeakMap();\nclass MetaMaskConnector extends InjectedConnector {\n  constructor(arg) {\n    const defaultOptions = {\n      name: \"MetaMask\",\n      shimDisconnect: true,\n      shimChainChangedDisconnect: true,\n      getProvider: getInjectedMetamaskProvider\n    };\n    const options = {\n      ...defaultOptions,\n      ...arg.options\n    };\n    super({\n      chains: arg.chains,\n      options,\n      connectorStorage: arg.connectorStorage\n    });\n    _defineProperty(this, \"id\", walletIds.metamask);\n    _classPrivateFieldInitSpec(this, _UNSTABLE_shimOnConnectSelectAccount, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _UNSTABLE_shimOnConnectSelectAccount, options.UNSTABLE_shimOnConnectSelectAccount);\n  }\n\n  /**\n   * Connect to injected MetaMask provider\n   */\n  async connect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    try {\n      const provider = await this.getProvider();\n      if (!provider) {\n        throw new ConnectorNotFoundError();\n      }\n      this.setupListeners();\n\n      // emit \"connecting\" event\n      this.emit(\"message\", {\n        type: \"connecting\"\n      });\n\n      // Attempt to show wallet select prompt with `wallet_requestPermissions` when\n      // `shimDisconnect` is active and account is in disconnected state (flag in storage)\n      let account = null;\n      if (_classPrivateFieldGet(this, _UNSTABLE_shimOnConnectSelectAccount) && this.options?.shimDisconnect && !Boolean(this.connectorStorage.getItem(this.shimDisconnectKey))) {\n        account = await this.getAccount().catch(() => null);\n        const isConnected = !!account;\n        if (isConnected) {\n          // Attempt to show another prompt for selecting wallet if already connected\n          try {\n            await provider.request({\n              method: \"wallet_requestPermissions\",\n              params: [{\n                eth_accounts: {}\n              }]\n            });\n          } catch (error) {\n            // Not all MetaMask injected providers support `wallet_requestPermissions` (e.g. MetaMask iOS).\n            // Only bubble up error if user rejects request\n            if (this.isUserRejectedRequestError(error)) {\n              throw new UserRejectedRequestError(error);\n            }\n          }\n        }\n      }\n\n      // if account is not already set, request accounts and use the first account\n      if (!account) {\n        const accounts = await provider.request({\n          method: \"eth_requestAccounts\"\n        });\n        account = utils.getAddress(accounts[0]);\n      }\n\n      // get currently connected chainId\n      let connectedChainId = await this.getChainId();\n      // check if connected chain is unsupported\n      let isUnsupported = this.isChainUnsupported(connectedChainId);\n\n      // if chainId is given, but does not match the currently connected chainId, switch to the given chainId\n      if (options.chainId && connectedChainId !== options.chainId) {\n        try {\n          await this.switchChain(options.chainId);\n          // recalculate the chainId and isUnsupported\n          connectedChainId = options.chainId;\n          isUnsupported = this.isChainUnsupported(options.chainId);\n        } catch (e) {\n          console.error(`Could not switch to chain id : ${options.chainId}`, e);\n        }\n      }\n\n      // if shimDisconnect is enabled\n      if (this.options?.shimDisconnect) {\n        // add shimDisconnectKey in storage - this signals that connector is \"connected\"\n        await this.connectorStorage.setItem(this.shimDisconnectKey, \"true\");\n      }\n      const connectionInfo = {\n        chain: {\n          id: connectedChainId,\n          unsupported: isUnsupported\n        },\n        provider: provider,\n        account\n      };\n      this.emit(\"connect\", connectionInfo);\n      return connectionInfo;\n    } catch (error) {\n      if (this.isUserRejectedRequestError(error)) {\n        throw new UserRejectedRequestError(error);\n      }\n      if (error.code === -32002) {\n        throw new ResourceUnavailableError(error);\n      }\n      throw error;\n    }\n  }\n  async switchAccount() {\n    const provider = await this.getProvider();\n    await provider.request({\n      method: \"wallet_requestPermissions\",\n      params: [{\n        eth_accounts: {}\n      }]\n    });\n  }\n}\nexport { MetaMaskConnector };","map":{"version":3,"names":["_","_classPrivateFieldInitSpec","a","_classPrivateFieldSet","b","_classPrivateFieldGet","_defineProperty","ConnectorNotFoundError","U","UserRejectedRequestError","R","ResourceUnavailableError","w","walletIds","InjectedConnector","utils","g","getInjectedMetamaskProvider","_UNSTABLE_shimOnConnectSelectAccount","WeakMap","MetaMaskConnector","constructor","arg","defaultOptions","name","shimDisconnect","shimChainChangedDisconnect","getProvider","options","chains","connectorStorage","metamask","writable","value","UNSTABLE_shimOnConnectSelectAccount","connect","arguments","length","undefined","provider","setupListeners","emit","type","account","Boolean","getItem","shimDisconnectKey","getAccount","catch","isConnected","request","method","params","eth_accounts","error","isUserRejectedRequestError","accounts","getAddress","connectedChainId","getChainId","isUnsupported","isChainUnsupported","chainId","switchChain","e","console","setItem","connectionInfo","chain","id","unsupported","code","switchAccount"],"sources":["C:/Users/SUMAN K/meta_transfer/node_modules/@thirdweb-dev/wallets/evm/connectors/metamask/dist/thirdweb-dev-wallets-evm-connectors-metamask.browser.esm.js"],"sourcesContent":["import { _ as _classPrivateFieldInitSpec, a as _classPrivateFieldSet, b as _classPrivateFieldGet } from '../../../../dist/classPrivateFieldSet-a5db7c83.browser.esm.js';\nimport { _ as _defineProperty } from '../../../../dist/defineProperty-c8ecdc07.browser.esm.js';\nimport { a as ConnectorNotFoundError, U as UserRejectedRequestError, R as ResourceUnavailableError } from '../../../../dist/errors-d961f852.browser.esm.js';\nimport { w as walletIds } from '../../../../dist/walletIds-e41b240b.browser.esm.js';\nimport { InjectedConnector } from '../../injected/dist/thirdweb-dev-wallets-evm-connectors-injected.browser.esm.js';\nimport { utils } from 'ethers';\nimport { g as getInjectedMetamaskProvider } from '../../../../dist/getInjectedMetamaskProvider-928dd9c3.browser.esm.js';\nimport '../../../../dist/assertWindowEthereum-b48c1686.browser.esm.js';\nimport '../../../../dist/url-bc88b2b6.browser.esm.js';\nimport '@thirdweb-dev/chains';\nimport '../../../../dist/WagmiConnector-2f14002d.browser.esm.js';\nimport 'eventemitter3';\nimport '../../../../dist/normalizeChainId-e4cc0175.browser.esm.js';\n\nvar _UNSTABLE_shimOnConnectSelectAccount = /*#__PURE__*/new WeakMap();\nclass MetaMaskConnector extends InjectedConnector {\n  constructor(arg) {\n    const defaultOptions = {\n      name: \"MetaMask\",\n      shimDisconnect: true,\n      shimChainChangedDisconnect: true,\n      getProvider: getInjectedMetamaskProvider\n    };\n    const options = {\n      ...defaultOptions,\n      ...arg.options\n    };\n    super({\n      chains: arg.chains,\n      options,\n      connectorStorage: arg.connectorStorage\n    });\n    _defineProperty(this, \"id\", walletIds.metamask);\n    _classPrivateFieldInitSpec(this, _UNSTABLE_shimOnConnectSelectAccount, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _UNSTABLE_shimOnConnectSelectAccount, options.UNSTABLE_shimOnConnectSelectAccount);\n  }\n\n  /**\n   * Connect to injected MetaMask provider\n   */\n  async connect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    try {\n      const provider = await this.getProvider();\n      if (!provider) {\n        throw new ConnectorNotFoundError();\n      }\n      this.setupListeners();\n\n      // emit \"connecting\" event\n      this.emit(\"message\", {\n        type: \"connecting\"\n      });\n\n      // Attempt to show wallet select prompt with `wallet_requestPermissions` when\n      // `shimDisconnect` is active and account is in disconnected state (flag in storage)\n      let account = null;\n      if (_classPrivateFieldGet(this, _UNSTABLE_shimOnConnectSelectAccount) && this.options?.shimDisconnect && !Boolean(this.connectorStorage.getItem(this.shimDisconnectKey))) {\n        account = await this.getAccount().catch(() => null);\n        const isConnected = !!account;\n        if (isConnected) {\n          // Attempt to show another prompt for selecting wallet if already connected\n          try {\n            await provider.request({\n              method: \"wallet_requestPermissions\",\n              params: [{\n                eth_accounts: {}\n              }]\n            });\n          } catch (error) {\n            // Not all MetaMask injected providers support `wallet_requestPermissions` (e.g. MetaMask iOS).\n            // Only bubble up error if user rejects request\n            if (this.isUserRejectedRequestError(error)) {\n              throw new UserRejectedRequestError(error);\n            }\n          }\n        }\n      }\n\n      // if account is not already set, request accounts and use the first account\n      if (!account) {\n        const accounts = await provider.request({\n          method: \"eth_requestAccounts\"\n        });\n        account = utils.getAddress(accounts[0]);\n      }\n\n      // get currently connected chainId\n      let connectedChainId = await this.getChainId();\n      // check if connected chain is unsupported\n      let isUnsupported = this.isChainUnsupported(connectedChainId);\n\n      // if chainId is given, but does not match the currently connected chainId, switch to the given chainId\n      if (options.chainId && connectedChainId !== options.chainId) {\n        try {\n          await this.switchChain(options.chainId);\n          // recalculate the chainId and isUnsupported\n          connectedChainId = options.chainId;\n          isUnsupported = this.isChainUnsupported(options.chainId);\n        } catch (e) {\n          console.error(`Could not switch to chain id : ${options.chainId}`, e);\n        }\n      }\n\n      // if shimDisconnect is enabled\n      if (this.options?.shimDisconnect) {\n        // add shimDisconnectKey in storage - this signals that connector is \"connected\"\n        await this.connectorStorage.setItem(this.shimDisconnectKey, \"true\");\n      }\n      const connectionInfo = {\n        chain: {\n          id: connectedChainId,\n          unsupported: isUnsupported\n        },\n        provider: provider,\n        account\n      };\n      this.emit(\"connect\", connectionInfo);\n      return connectionInfo;\n    } catch (error) {\n      if (this.isUserRejectedRequestError(error)) {\n        throw new UserRejectedRequestError(error);\n      }\n      if (error.code === -32002) {\n        throw new ResourceUnavailableError(error);\n      }\n      throw error;\n    }\n  }\n  async switchAccount() {\n    const provider = await this.getProvider();\n    await provider.request({\n      method: \"wallet_requestPermissions\",\n      params: [{\n        eth_accounts: {}\n      }]\n    });\n  }\n}\n\nexport { MetaMaskConnector };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}