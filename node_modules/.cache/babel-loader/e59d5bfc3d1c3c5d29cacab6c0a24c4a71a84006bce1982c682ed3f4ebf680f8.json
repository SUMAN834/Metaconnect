{"ast":null,"code":"import { RELAYER_EVENTS as ve, PAIRING_EVENTS as Ae, Core as _e, Store as P } from \"@walletconnect/core\";\nimport { pino as xe, getDefaultLoggerOptions as Re, generateChildLogger as Fe, getLoggerContext as Te } from \"@walletconnect/logger\";\nimport { EventEmitter as Ie } from \"events\";\nimport { formatJsonRpcRequest as qe, formatJsonRpcResult as Ue, formatJsonRpcError as Oe, isJsonRpcResult as Se, isJsonRpcError as Pe, isJsonRpcRequest as Ne, isJsonRpcResponse as $e } from \"@walletconnect/jsonrpc-utils\";\nimport { isValidUrl as Be, isValidRequestExpiry as ze, getInternalError as k, hashKey as J, isBrowser as je, TYPE_1 as Me } from \"@walletconnect/utils\";\nimport { ONE_DAY as N, FIVE_MINUTES as Le, SEVEN_DAYS as Ke } from \"@walletconnect/time\";\nimport { hashMessage as X } from \"@ethersproject/hash\";\nimport { recoverAddress as Ve } from \"@ethersproject/transactions\";\nimport ke from \"isomorphic-unfetch\";\nimport { randomStringForEntropy as Je } from \"@stablelib/random\";\nimport { hash as Xe } from \"@stablelib/sha256\";\nclass G {\n  constructor(t) {\n    this.client = t;\n  }\n}\nclass H {\n  constructor(t) {\n    this.opts = t;\n  }\n}\nconst Y = \"https://rpc.walletconnect.com/v1\",\n  R = {\n    wc_authRequest: {\n      req: {\n        ttl: N,\n        prompt: !0,\n        tag: 3e3\n      },\n      res: {\n        ttl: N,\n        prompt: !1,\n        tag: 3001\n      }\n    }\n  },\n  U = {\n    min: Le,\n    max: Ke\n  },\n  $ = \"wc\",\n  Q = 1,\n  Z = \"auth\",\n  B = \"authClient\",\n  F = `${$}@${1}:${Z}:`,\n  x = `${F}:PUB_KEY`,\n  Ge = \"expirer\",\n  He = {\n    created: \"expirer_created\",\n    deleted: \"expirer_deleted\",\n    expired: \"expirer_expired\",\n    sync: \"expirer_sync\"\n  },\n  Ye = \"0.3\",\n  Qe = N;\nfunction z(r) {\n  return r?.split(\":\");\n}\nfunction Ze(r) {\n  const t = r && z(r);\n  if (t) return t[3];\n}\nfunction We(r) {\n  const t = r && z(r);\n  if (t) return t[2] + \":\" + t[3];\n}\nfunction W(r) {\n  const t = r && z(r);\n  if (t) return t.pop();\n}\nasync function et(r, t, e, i, n) {\n  switch (e.t) {\n    case \"eip191\":\n      return tt(r, t, e.s);\n    case \"eip1271\":\n      return await rt(r, t, e.s, i, n);\n    default:\n      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${e.t}`);\n  }\n}\nfunction tt(r, t, e) {\n  return Ve(X(t), e).toLowerCase() === r.toLowerCase();\n}\nasync function rt(r, t, e, i, n) {\n  try {\n    const s = \"0x1626ba7e\",\n      o = \"0000000000000000000000000000000000000000000000000000000000000040\",\n      u = \"0000000000000000000000000000000000000000000000000000000000000041\",\n      a = e.substring(2),\n      c = X(t).substring(2),\n      h = s + c + o + u + a,\n      f = await ke(`${Y}/?chainId=${i}&projectId=${n}`, {\n        method: \"POST\",\n        body: JSON.stringify({\n          id: it(),\n          jsonrpc: \"2.0\",\n          method: \"eth_call\",\n          params: [{\n            to: r,\n            data: h\n          }, \"latest\"]\n        })\n      }),\n      {\n        result: p\n      } = await f.json();\n    return p ? p.slice(0, s.length).toLowerCase() === s.toLowerCase() : !1;\n  } catch (s) {\n    return console.error(\"isValidEip1271Signature: \", s), !1;\n  }\n}\nfunction it() {\n  return Date.now() + Math.floor(Math.random() * 1e3);\n}\nfunction ee(r) {\n  return r.getAll().filter(t => \"requester\" in t);\n}\nfunction te(r, t) {\n  return ee(r).find(e => e.id === t);\n}\nfunction nt(r) {\n  const t = Be(r.aud),\n    e = new RegExp(`${r.domain}`).test(r.aud),\n    i = !!r.nonce,\n    n = r.type ? r.type === \"eip4361\" : !0,\n    s = r.expiry;\n  if (s && !ze(s, U)) {\n    const {\n      message: o\n    } = k(\"MISSING_OR_INVALID\", `request() expiry: ${s}. Expiry must be a number (in seconds) between ${U.min} and ${U.max}`);\n    throw new Error(o);\n  }\n  return !!(t && e && i && n);\n}\nfunction st(r, t) {\n  return !!te(t, r.id);\n}\nfunction ot(r = 0) {\n  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(r) : new Uint8Array(r);\n}\nfunction ut(r, t) {\n  if (r.length >= 255) throw new TypeError(\"Alphabet too long\");\n  for (var e = new Uint8Array(256), i = 0; i < e.length; i++) e[i] = 255;\n  for (var n = 0; n < r.length; n++) {\n    var s = r.charAt(n),\n      o = s.charCodeAt(0);\n    if (e[o] !== 255) throw new TypeError(s + \" is ambiguous\");\n    e[o] = n;\n  }\n  var u = r.length,\n    a = r.charAt(0),\n    c = Math.log(u) / Math.log(256),\n    h = Math.log(256) / Math.log(u);\n  function f(D) {\n    if (D instanceof Uint8Array || (ArrayBuffer.isView(D) ? D = new Uint8Array(D.buffer, D.byteOffset, D.byteLength) : Array.isArray(D) && (D = Uint8Array.from(D))), !(D instanceof Uint8Array)) throw new TypeError(\"Expected Uint8Array\");\n    if (D.length === 0) return \"\";\n    for (var l = 0, m = 0, E = 0, y = D.length; E !== y && D[E] === 0;) E++, l++;\n    for (var w = (y - E) * h + 1 >>> 0, g = new Uint8Array(w); E !== y;) {\n      for (var C = D[E], _ = 0, b = w - 1; (C !== 0 || _ < m) && b !== -1; b--, _++) C += 256 * g[b] >>> 0, g[b] = C % u >>> 0, C = C / u >>> 0;\n      if (C !== 0) throw new Error(\"Non-zero carry\");\n      m = _, E++;\n    }\n    for (var v = w - m; v !== w && g[v] === 0;) v++;\n    for (var q = a.repeat(l); v < w; ++v) q += r.charAt(g[v]);\n    return q;\n  }\n  function p(D) {\n    if (typeof D != \"string\") throw new TypeError(\"Expected String\");\n    if (D.length === 0) return new Uint8Array();\n    var l = 0;\n    if (D[l] !== \" \") {\n      for (var m = 0, E = 0; D[l] === a;) m++, l++;\n      for (var y = (D.length - l) * c + 1 >>> 0, w = new Uint8Array(y); D[l];) {\n        var g = e[D.charCodeAt(l)];\n        if (g === 255) return;\n        for (var C = 0, _ = y - 1; (g !== 0 || C < E) && _ !== -1; _--, C++) g += u * w[_] >>> 0, w[_] = g % 256 >>> 0, g = g / 256 >>> 0;\n        if (g !== 0) throw new Error(\"Non-zero carry\");\n        E = C, l++;\n      }\n      if (D[l] !== \" \") {\n        for (var b = y - E; b !== y && w[b] === 0;) b++;\n        for (var v = new Uint8Array(m + (y - b)), q = m; b !== y;) v[q++] = w[b++];\n        return v;\n      }\n    }\n  }\n  function A(D) {\n    var l = p(D);\n    if (l) return l;\n    throw new Error(`Non-${t} character`);\n  }\n  return {\n    encode: f,\n    decodeUnsafe: p,\n    decode: A\n  };\n}\nvar at = ut,\n  Dt = at;\nconst re = r => {\n    if (r instanceof Uint8Array && r.constructor.name === \"Uint8Array\") return r;\n    if (r instanceof ArrayBuffer) return new Uint8Array(r);\n    if (ArrayBuffer.isView(r)) return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);\n    throw new Error(\"Unknown type, must be binary type\");\n  },\n  ct = r => new TextEncoder().encode(r),\n  ht = r => new TextDecoder().decode(r);\nclass lt {\n  constructor(t, e, i) {\n    this.name = t, this.prefix = e, this.baseEncode = i;\n  }\n  encode(t) {\n    if (t instanceof Uint8Array) return `${this.prefix}${this.baseEncode(t)}`;\n    throw Error(\"Unknown type, must be binary type\");\n  }\n}\nclass dt {\n  constructor(t, e, i) {\n    if (this.name = t, this.prefix = e, e.codePointAt(0) === void 0) throw new Error(\"Invalid prefix character\");\n    this.prefixCodePoint = e.codePointAt(0), this.baseDecode = i;\n  }\n  decode(t) {\n    if (typeof t == \"string\") {\n      if (t.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n      return this.baseDecode(t.slice(this.prefix.length));\n    } else throw Error(\"Can only multibase decode strings\");\n  }\n  or(t) {\n    return ie(this, t);\n  }\n}\nclass pt {\n  constructor(t) {\n    this.decoders = t;\n  }\n  or(t) {\n    return ie(this, t);\n  }\n  decode(t) {\n    const e = t[0],\n      i = this.decoders[e];\n    if (i) return i.decode(t);\n    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n  }\n}\nconst ie = (r, t) => new pt({\n  ...(r.decoders || {\n    [r.prefix]: r\n  }),\n  ...(t.decoders || {\n    [t.prefix]: t\n  })\n});\nclass ft {\n  constructor(t, e, i, n) {\n    this.name = t, this.prefix = e, this.baseEncode = i, this.baseDecode = n, this.encoder = new lt(t, e, i), this.decoder = new dt(t, e, n);\n  }\n  encode(t) {\n    return this.encoder.encode(t);\n  }\n  decode(t) {\n    return this.decoder.decode(t);\n  }\n}\nconst O = ({\n    name: r,\n    prefix: t,\n    encode: e,\n    decode: i\n  }) => new ft(r, t, e, i),\n  T = ({\n    prefix: r,\n    name: t,\n    alphabet: e\n  }) => {\n    const {\n      encode: i,\n      decode: n\n    } = Dt(e, t);\n    return O({\n      prefix: r,\n      name: t,\n      encode: i,\n      decode: s => re(n(s))\n    });\n  },\n  gt = (r, t, e, i) => {\n    const n = {};\n    for (let h = 0; h < t.length; ++h) n[t[h]] = h;\n    let s = r.length;\n    for (; r[s - 1] === \"=\";) --s;\n    const o = new Uint8Array(s * e / 8 | 0);\n    let u = 0,\n      a = 0,\n      c = 0;\n    for (let h = 0; h < s; ++h) {\n      const f = n[r[h]];\n      if (f === void 0) throw new SyntaxError(`Non-${i} character`);\n      a = a << e | f, u += e, u >= 8 && (u -= 8, o[c++] = 255 & a >> u);\n    }\n    if (u >= e || 255 & a << 8 - u) throw new SyntaxError(\"Unexpected end of data\");\n    return o;\n  },\n  Et = (r, t, e) => {\n    const i = t[t.length - 1] === \"=\",\n      n = (1 << e) - 1;\n    let s = \"\",\n      o = 0,\n      u = 0;\n    for (let a = 0; a < r.length; ++a) for (u = u << 8 | r[a], o += 8; o > e;) o -= e, s += t[n & u >> o];\n    if (o && (s += t[n & u << e - o]), i) for (; s.length * e & 7;) s += \"=\";\n    return s;\n  },\n  d = ({\n    name: r,\n    prefix: t,\n    bitsPerChar: e,\n    alphabet: i\n  }) => O({\n    prefix: t,\n    name: r,\n    encode(n) {\n      return Et(n, i, e);\n    },\n    decode(n) {\n      return gt(n, i, e, r);\n    }\n  }),\n  bt = O({\n    prefix: \"\\0\",\n    name: \"identity\",\n    encode: r => ht(r),\n    decode: r => ct(r)\n  });\nvar yt = Object.freeze({\n  __proto__: null,\n  identity: bt\n});\nconst wt = d({\n  prefix: \"0\",\n  name: \"base2\",\n  alphabet: \"01\",\n  bitsPerChar: 1\n});\nvar Ct = Object.freeze({\n  __proto__: null,\n  base2: wt\n});\nconst mt = d({\n  prefix: \"7\",\n  name: \"base8\",\n  alphabet: \"01234567\",\n  bitsPerChar: 3\n});\nvar vt = Object.freeze({\n  __proto__: null,\n  base8: mt\n});\nconst At = T({\n  prefix: \"9\",\n  name: \"base10\",\n  alphabet: \"0123456789\"\n});\nvar _t = Object.freeze({\n  __proto__: null,\n  base10: At\n});\nconst xt = d({\n    prefix: \"f\",\n    name: \"base16\",\n    alphabet: \"0123456789abcdef\",\n    bitsPerChar: 4\n  }),\n  Rt = d({\n    prefix: \"F\",\n    name: \"base16upper\",\n    alphabet: \"0123456789ABCDEF\",\n    bitsPerChar: 4\n  });\nvar Ft = Object.freeze({\n  __proto__: null,\n  base16: xt,\n  base16upper: Rt\n});\nconst Tt = d({\n    prefix: \"b\",\n    name: \"base32\",\n    alphabet: \"abcdefghijklmnopqrstuvwxyz234567\",\n    bitsPerChar: 5\n  }),\n  It = d({\n    prefix: \"B\",\n    name: \"base32upper\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n    bitsPerChar: 5\n  }),\n  qt = d({\n    prefix: \"c\",\n    name: \"base32pad\",\n    alphabet: \"abcdefghijklmnopqrstuvwxyz234567=\",\n    bitsPerChar: 5\n  }),\n  Ut = d({\n    prefix: \"C\",\n    name: \"base32padupper\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=\",\n    bitsPerChar: 5\n  }),\n  Ot = d({\n    prefix: \"v\",\n    name: \"base32hex\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuv\",\n    bitsPerChar: 5\n  }),\n  St = d({\n    prefix: \"V\",\n    name: \"base32hexupper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\",\n    bitsPerChar: 5\n  }),\n  Pt = d({\n    prefix: \"t\",\n    name: \"base32hexpad\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuv=\",\n    bitsPerChar: 5\n  }),\n  Nt = d({\n    prefix: \"T\",\n    name: \"base32hexpadupper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV=\",\n    bitsPerChar: 5\n  }),\n  $t = d({\n    prefix: \"h\",\n    name: \"base32z\",\n    alphabet: \"ybndrfg8ejkmcpqxot1uwisza345h769\",\n    bitsPerChar: 5\n  });\nvar Bt = Object.freeze({\n  __proto__: null,\n  base32: Tt,\n  base32upper: It,\n  base32pad: qt,\n  base32padupper: Ut,\n  base32hex: Ot,\n  base32hexupper: St,\n  base32hexpad: Pt,\n  base32hexpadupper: Nt,\n  base32z: $t\n});\nconst zt = T({\n    prefix: \"k\",\n    name: \"base36\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuvwxyz\"\n  }),\n  jt = T({\n    prefix: \"K\",\n    name: \"base36upper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  });\nvar Mt = Object.freeze({\n  __proto__: null,\n  base36: zt,\n  base36upper: jt\n});\nconst Lt = T({\n    name: \"base58btc\",\n    prefix: \"z\",\n    alphabet: \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n  }),\n  Kt = T({\n    name: \"base58flickr\",\n    prefix: \"Z\",\n    alphabet: \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\"\n  });\nvar Vt = Object.freeze({\n  __proto__: null,\n  base58btc: Lt,\n  base58flickr: Kt\n});\nconst kt = d({\n    prefix: \"m\",\n    name: \"base64\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n    bitsPerChar: 6\n  }),\n  Jt = d({\n    prefix: \"M\",\n    name: \"base64pad\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n    bitsPerChar: 6\n  }),\n  Xt = d({\n    prefix: \"u\",\n    name: \"base64url\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\",\n    bitsPerChar: 6\n  }),\n  Gt = d({\n    prefix: \"U\",\n    name: \"base64urlpad\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\",\n    bitsPerChar: 6\n  });\nvar Ht = Object.freeze({\n  __proto__: null,\n  base64: kt,\n  base64pad: Jt,\n  base64url: Xt,\n  base64urlpad: Gt\n});\nconst ne = Array.from(\"\\u{1F680}\\u{1FA90}\\u2604\\u{1F6F0}\\u{1F30C}\\u{1F311}\\u{1F312}\\u{1F313}\\u{1F314}\\u{1F315}\\u{1F316}\\u{1F317}\\u{1F318}\\u{1F30D}\\u{1F30F}\\u{1F30E}\\u{1F409}\\u2600\\u{1F4BB}\\u{1F5A5}\\u{1F4BE}\\u{1F4BF}\\u{1F602}\\u2764\\u{1F60D}\\u{1F923}\\u{1F60A}\\u{1F64F}\\u{1F495}\\u{1F62D}\\u{1F618}\\u{1F44D}\\u{1F605}\\u{1F44F}\\u{1F601}\\u{1F525}\\u{1F970}\\u{1F494}\\u{1F496}\\u{1F499}\\u{1F622}\\u{1F914}\\u{1F606}\\u{1F644}\\u{1F4AA}\\u{1F609}\\u263A\\u{1F44C}\\u{1F917}\\u{1F49C}\\u{1F614}\\u{1F60E}\\u{1F607}\\u{1F339}\\u{1F926}\\u{1F389}\\u{1F49E}\\u270C\\u2728\\u{1F937}\\u{1F631}\\u{1F60C}\\u{1F338}\\u{1F64C}\\u{1F60B}\\u{1F497}\\u{1F49A}\\u{1F60F}\\u{1F49B}\\u{1F642}\\u{1F493}\\u{1F929}\\u{1F604}\\u{1F600}\\u{1F5A4}\\u{1F603}\\u{1F4AF}\\u{1F648}\\u{1F447}\\u{1F3B6}\\u{1F612}\\u{1F92D}\\u2763\\u{1F61C}\\u{1F48B}\\u{1F440}\\u{1F62A}\\u{1F611}\\u{1F4A5}\\u{1F64B}\\u{1F61E}\\u{1F629}\\u{1F621}\\u{1F92A}\\u{1F44A}\\u{1F973}\\u{1F625}\\u{1F924}\\u{1F449}\\u{1F483}\\u{1F633}\\u270B\\u{1F61A}\\u{1F61D}\\u{1F634}\\u{1F31F}\\u{1F62C}\\u{1F643}\\u{1F340}\\u{1F337}\\u{1F63B}\\u{1F613}\\u2B50\\u2705\\u{1F97A}\\u{1F308}\\u{1F608}\\u{1F918}\\u{1F4A6}\\u2714\\u{1F623}\\u{1F3C3}\\u{1F490}\\u2639\\u{1F38A}\\u{1F498}\\u{1F620}\\u261D\\u{1F615}\\u{1F33A}\\u{1F382}\\u{1F33B}\\u{1F610}\\u{1F595}\\u{1F49D}\\u{1F64A}\\u{1F639}\\u{1F5E3}\\u{1F4AB}\\u{1F480}\\u{1F451}\\u{1F3B5}\\u{1F91E}\\u{1F61B}\\u{1F534}\\u{1F624}\\u{1F33C}\\u{1F62B}\\u26BD\\u{1F919}\\u2615\\u{1F3C6}\\u{1F92B}\\u{1F448}\\u{1F62E}\\u{1F646}\\u{1F37B}\\u{1F343}\\u{1F436}\\u{1F481}\\u{1F632}\\u{1F33F}\\u{1F9E1}\\u{1F381}\\u26A1\\u{1F31E}\\u{1F388}\\u274C\\u270A\\u{1F44B}\\u{1F630}\\u{1F928}\\u{1F636}\\u{1F91D}\\u{1F6B6}\\u{1F4B0}\\u{1F353}\\u{1F4A2}\\u{1F91F}\\u{1F641}\\u{1F6A8}\\u{1F4A8}\\u{1F92C}\\u2708\\u{1F380}\\u{1F37A}\\u{1F913}\\u{1F619}\\u{1F49F}\\u{1F331}\\u{1F616}\\u{1F476}\\u{1F974}\\u25B6\\u27A1\\u2753\\u{1F48E}\\u{1F4B8}\\u2B07\\u{1F628}\\u{1F31A}\\u{1F98B}\\u{1F637}\\u{1F57A}\\u26A0\\u{1F645}\\u{1F61F}\\u{1F635}\\u{1F44E}\\u{1F932}\\u{1F920}\\u{1F927}\\u{1F4CC}\\u{1F535}\\u{1F485}\\u{1F9D0}\\u{1F43E}\\u{1F352}\\u{1F617}\\u{1F911}\\u{1F30A}\\u{1F92F}\\u{1F437}\\u260E\\u{1F4A7}\\u{1F62F}\\u{1F486}\\u{1F446}\\u{1F3A4}\\u{1F647}\\u{1F351}\\u2744\\u{1F334}\\u{1F4A3}\\u{1F438}\\u{1F48C}\\u{1F4CD}\\u{1F940}\\u{1F922}\\u{1F445}\\u{1F4A1}\\u{1F4A9}\\u{1F450}\\u{1F4F8}\\u{1F47B}\\u{1F910}\\u{1F92E}\\u{1F3BC}\\u{1F975}\\u{1F6A9}\\u{1F34E}\\u{1F34A}\\u{1F47C}\\u{1F48D}\\u{1F4E3}\\u{1F942}\"),\n  Yt = ne.reduce((r, t, e) => (r[e] = t, r), []),\n  Qt = ne.reduce((r, t, e) => (r[t.codePointAt(0)] = e, r), []);\nfunction Zt(r) {\n  return r.reduce((t, e) => (t += Yt[e], t), \"\");\n}\nfunction Wt(r) {\n  const t = [];\n  for (const e of r) {\n    const i = Qt[e.codePointAt(0)];\n    if (i === void 0) throw new Error(`Non-base256emoji character: ${e}`);\n    t.push(i);\n  }\n  return new Uint8Array(t);\n}\nconst er = O({\n  prefix: \"\\u{1F680}\",\n  name: \"base256emoji\",\n  encode: Zt,\n  decode: Wt\n});\nvar tr = Object.freeze({\n    __proto__: null,\n    base256emoji: er\n  }),\n  rr = oe,\n  se = 128,\n  ir = 127,\n  nr = ~ir,\n  sr = Math.pow(2, 31);\nfunction oe(r, t, e) {\n  t = t || [], e = e || 0;\n  for (var i = e; r >= sr;) t[e++] = r & 255 | se, r /= 128;\n  for (; r & nr;) t[e++] = r & 255 | se, r >>>= 7;\n  return t[e] = r | 0, oe.bytes = e - i + 1, t;\n}\nvar or = j,\n  ur = 128,\n  ue = 127;\nfunction j(r, i) {\n  var e = 0,\n    i = i || 0,\n    n = 0,\n    s = i,\n    o,\n    u = r.length;\n  do {\n    if (s >= u) throw j.bytes = 0, new RangeError(\"Could not decode varint\");\n    o = r[s++], e += n < 28 ? (o & ue) << n : (o & ue) * Math.pow(2, n), n += 7;\n  } while (o >= ur);\n  return j.bytes = s - i, e;\n}\nvar ar = Math.pow(2, 7),\n  Dr = Math.pow(2, 14),\n  cr = Math.pow(2, 21),\n  hr = Math.pow(2, 28),\n  lr = Math.pow(2, 35),\n  dr = Math.pow(2, 42),\n  pr = Math.pow(2, 49),\n  fr = Math.pow(2, 56),\n  gr = Math.pow(2, 63),\n  Er = function (r) {\n    return r < ar ? 1 : r < Dr ? 2 : r < cr ? 3 : r < hr ? 4 : r < lr ? 5 : r < dr ? 6 : r < pr ? 7 : r < fr ? 8 : r < gr ? 9 : 10;\n  },\n  br = {\n    encode: rr,\n    decode: or,\n    encodingLength: Er\n  },\n  ae = br;\nconst De = (r, t, e = 0) => (ae.encode(r, t, e), t),\n  ce = r => ae.encodingLength(r),\n  M = (r, t) => {\n    const e = t.byteLength,\n      i = ce(r),\n      n = i + ce(e),\n      s = new Uint8Array(n + e);\n    return De(r, s, 0), De(e, s, i), s.set(t, n), new yr(r, e, t, s);\n  };\nclass yr {\n  constructor(t, e, i, n) {\n    this.code = t, this.size = e, this.digest = i, this.bytes = n;\n  }\n}\nconst he = ({\n  name: r,\n  code: t,\n  encode: e\n}) => new wr(r, t, e);\nclass wr {\n  constructor(t, e, i) {\n    this.name = t, this.code = e, this.encode = i;\n  }\n  digest(t) {\n    if (t instanceof Uint8Array) {\n      const e = this.encode(t);\n      return e instanceof Uint8Array ? M(this.code, e) : e.then(i => M(this.code, i));\n    } else throw Error(\"Unknown type, must be binary type\");\n  }\n}\nconst le = r => async t => new Uint8Array(await crypto.subtle.digest(r, t)),\n  Cr = he({\n    name: \"sha2-256\",\n    code: 18,\n    encode: le(\"SHA-256\")\n  }),\n  mr = he({\n    name: \"sha2-512\",\n    code: 19,\n    encode: le(\"SHA-512\")\n  });\nvar vr = Object.freeze({\n  __proto__: null,\n  sha256: Cr,\n  sha512: mr\n});\nconst de = 0,\n  Ar = \"identity\",\n  pe = re,\n  _r = r => M(de, pe(r)),\n  xr = {\n    code: de,\n    name: Ar,\n    encode: pe,\n    digest: _r\n  };\nvar Rr = Object.freeze({\n  __proto__: null,\n  identity: xr\n});\nnew TextEncoder(), new TextDecoder();\nconst fe = {\n  ...yt,\n  ...Ct,\n  ...vt,\n  ..._t,\n  ...Ft,\n  ...Bt,\n  ...Mt,\n  ...Vt,\n  ...Ht,\n  ...tr\n};\n({\n  ...vr,\n  ...Rr\n});\nfunction ge(r, t, e, i) {\n  return {\n    name: r,\n    prefix: t,\n    encoder: {\n      name: r,\n      prefix: t,\n      encode: e\n    },\n    decoder: {\n      decode: i\n    }\n  };\n}\nconst Ee = ge(\"utf8\", \"u\", r => \"u\" + new TextDecoder(\"utf8\").decode(r), r => new TextEncoder().encode(r.substring(1))),\n  L = ge(\"ascii\", \"a\", r => {\n    let t = \"a\";\n    for (let e = 0; e < r.length; e++) t += String.fromCharCode(r[e]);\n    return t;\n  }, r => {\n    r = r.substring(1);\n    const t = ot(r.length);\n    for (let e = 0; e < r.length; e++) t[e] = r.charCodeAt(e);\n    return t;\n  }),\n  be = {\n    utf8: Ee,\n    \"utf-8\": Ee,\n    hex: fe.base16,\n    latin1: L,\n    ascii: L,\n    binary: L,\n    ...fe\n  };\nfunction Fr(r, t = \"utf8\") {\n  const e = be[t];\n  if (!e) throw new Error(`Unsupported encoding \"${t}\"`);\n  return (t === \"utf8\" || t === \"utf-8\") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r, \"utf8\") : e.decoder.decode(`${e.prefix}${r}`);\n}\nfunction Tr(r, t = \"utf8\") {\n  const e = be[t];\n  if (!e) throw new Error(`Unsupported encoding \"${t}\"`);\n  return (t === \"utf8\" || t === \"utf-8\") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r.buffer, r.byteOffset, r.byteLength).toString(\"utf8\") : e.encoder.encode(r).substring(1);\n}\nconst Ir = \"base10\",\n  ye = \"base16\",\n  qr = \"base64pad\",\n  we = \"utf8\";\nfunction Ur() {\n  return Je(96);\n}\nfunction K(r) {\n  const t = Xe(Fr(r, we));\n  return Tr(t, ye);\n}\nvar Or = Object.defineProperty,\n  Sr = Object.defineProperties,\n  Pr = Object.getOwnPropertyDescriptors,\n  Ce = Object.getOwnPropertySymbols,\n  Nr = Object.prototype.hasOwnProperty,\n  $r = Object.prototype.propertyIsEnumerable,\n  me = (r, t, e) => t in r ? Or(r, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : r[t] = e,\n  I = (r, t) => {\n    for (var e in t || (t = {})) Nr.call(t, e) && me(r, e, t[e]);\n    if (Ce) for (var e of Ce(t)) $r.call(t, e) && me(r, e, t[e]);\n    return r;\n  },\n  V = (r, t) => Sr(r, Pr(t));\nclass Br extends G {\n  constructor(t) {\n    super(t), this.initialized = !1, this.name = \"authEngine\", this.init = () => {\n      this.initialized || (this.registerRelayerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({\n        methods: Object.keys(R)\n      }), this.initialized = !0);\n    }, this.request = async (e, i) => {\n      if (this.isInitialized(), !nt(e)) throw new Error(\"Invalid request\");\n      if (i != null && i.topic) return await this.requestOnKnownPairing(i.topic, e);\n      const {\n          chainId: n,\n          statement: s,\n          aud: o,\n          domain: u,\n          nonce: a,\n          type: c,\n          exp: h,\n          nbf: f\n        } = e,\n        {\n          topic: p,\n          uri: A\n        } = await this.client.core.pairing.create();\n      this.client.logger.info({\n        message: \"Generated new pairing\",\n        pairing: {\n          topic: p,\n          uri: A\n        }\n      });\n      const D = await this.client.core.crypto.generateKeyPair(),\n        l = J(D);\n      await this.client.authKeys.set(x, {\n        responseTopic: l,\n        publicKey: D\n      }), await this.client.pairingTopics.set(l, {\n        topic: l,\n        pairingTopic: p\n      }), await this.client.core.relayer.subscribe(l), this.client.logger.info(`sending request to new pairing topic: ${p}`);\n      const m = await this.sendRequest(p, \"wc_authRequest\", {\n        payloadParams: {\n          type: c ?? \"eip4361\",\n          chainId: n,\n          statement: s,\n          aud: o,\n          domain: u,\n          version: \"1\",\n          nonce: a,\n          iat: new Date().toISOString(),\n          exp: h,\n          nbf: f\n        },\n        requester: {\n          publicKey: D,\n          metadata: this.client.metadata\n        }\n      }, {}, e.expiry);\n      return this.client.logger.info(`sent request to new pairing topic: ${p}`), {\n        uri: A,\n        id: m\n      };\n    }, this.respond = async (e, i) => {\n      if (this.isInitialized(), !st(e, this.client.requests)) throw new Error(\"Invalid response\");\n      const n = te(this.client.requests, e.id);\n      if (!n) throw new Error(`Could not find pending auth request with id ${e.id}`);\n      const s = n.requester.publicKey,\n        o = await this.client.core.crypto.generateKeyPair(),\n        u = J(s),\n        a = {\n          type: Me,\n          receiverPublicKey: s,\n          senderPublicKey: o\n        };\n      if (\"error\" in e) {\n        await this.sendError(n.id, u, e, a);\n        return;\n      }\n      const c = {\n        h: {\n          t: \"eip4361\"\n        },\n        p: V(I({}, n.cacaoPayload), {\n          iss: i\n        }),\n        s: e.signature\n      };\n      await this.sendResult(n.id, u, c, a), await this.client.core.pairing.activate({\n        topic: n.pairingTopic\n      }), await this.client.requests.update(n.id, I({}, c));\n    }, this.getPendingRequests = () => ee(this.client.requests), this.formatMessage = (e, i) => {\n      this.client.logger.debug(`formatMessage, cacao is: ${JSON.stringify(e)}`);\n      const n = `${e.domain} wants you to sign in with your Ethereum account:`,\n        s = W(i),\n        o = e.statement,\n        u = `URI: ${e.aud}`,\n        a = `Version: ${e.version}`,\n        c = `Chain ID: ${Ze(i)}`,\n        h = `Nonce: ${e.nonce}`,\n        f = `Issued At: ${e.iat}`,\n        p = e.exp ? `Expiry: ${e.exp}` : void 0,\n        A = e.resources && e.resources.length > 0 ? `Resources:\n${e.resources.map(D => `- ${D}`).join(`\n`)}` : void 0;\n      return [n, s, \"\", o, \"\", u, a, c, h, f, p, A].filter(D => D != null).join(`\n`);\n    }, this.setExpiry = async (e, i) => {\n      this.client.core.pairing.pairings.keys.includes(e) && (await this.client.core.pairing.updateExpiry({\n        topic: e,\n        expiry: i\n      })), this.client.core.expirer.set(e, i);\n    }, this.sendRequest = async (e, i, n, s, o) => {\n      const u = qe(i, n),\n        a = await this.client.core.crypto.encode(e, u, s),\n        c = R[i].req;\n      if (o && (c.ttl = o), this.client.core.history.set(e, u), je()) {\n        const h = K(JSON.stringify(u));\n        this.client.core.verify.register({\n          attestationId: h\n        });\n      }\n      return await this.client.core.relayer.publish(e, a, V(I({}, c), {\n        internal: {\n          throwOnFailedPublish: !0\n        }\n      })), u.id;\n    }, this.sendResult = async (e, i, n, s) => {\n      const o = Ue(e, n),\n        u = await this.client.core.crypto.encode(i, o, s),\n        a = await this.client.core.history.get(i, e),\n        c = R[a.request.method].res;\n      return await this.client.core.relayer.publish(i, u, V(I({}, c), {\n        internal: {\n          throwOnFailedPublish: !0\n        }\n      })), await this.client.core.history.resolve(o), o.id;\n    }, this.sendError = async (e, i, n, s) => {\n      const o = Oe(e, n.error),\n        u = await this.client.core.crypto.encode(i, o, s),\n        a = await this.client.core.history.get(i, e),\n        c = R[a.request.method].res;\n      return await this.client.core.relayer.publish(i, u, c), await this.client.core.history.resolve(o), o.id;\n    }, this.requestOnKnownPairing = async (e, i) => {\n      const n = this.client.core.pairing.pairings.getAll({\n        active: !0\n      }).find(A => A.topic === e);\n      if (!n) throw new Error(`Could not find pairing for provided topic ${e}`);\n      const {\n          publicKey: s\n        } = this.client.authKeys.get(x),\n        {\n          chainId: o,\n          statement: u,\n          aud: a,\n          domain: c,\n          nonce: h,\n          type: f\n        } = i,\n        p = await this.sendRequest(n.topic, \"wc_authRequest\", {\n          payloadParams: {\n            type: f ?? \"eip4361\",\n            chainId: o,\n            statement: u,\n            aud: a,\n            domain: c,\n            version: \"1\",\n            nonce: h,\n            iat: new Date().toISOString()\n          },\n          requester: {\n            publicKey: s,\n            metadata: this.client.metadata\n          }\n        }, {}, i.expiry);\n      return this.client.logger.info(`sent request to known pairing topic: ${n.topic}`), {\n        id: p\n      };\n    }, this.onPairingCreated = e => {\n      const i = this.getPendingRequests();\n      if (i) {\n        const n = Object.values(i).find(s => s.pairingTopic === e.topic);\n        n && this.handleAuthRequest(n);\n      }\n    }, this.onRelayEventRequest = e => {\n      const {\n          topic: i,\n          payload: n\n        } = e,\n        s = n.method;\n      switch (s) {\n        case \"wc_authRequest\":\n          return this.onAuthRequest(i, n);\n        default:\n          return this.client.logger.info(`Unsupported request method ${s}`);\n      }\n    }, this.onRelayEventResponse = async e => {\n      const {\n          topic: i,\n          payload: n\n        } = e,\n        s = (await this.client.core.history.get(i, n.id)).request.method;\n      switch (s) {\n        case \"wc_authRequest\":\n          return this.onAuthResponse(i, n);\n        default:\n          return this.client.logger.info(`Unsupported response method ${s}`);\n      }\n    }, this.onAuthRequest = async (e, i) => {\n      const {\n        requester: n,\n        payloadParams: s\n      } = i.params;\n      this.client.logger.info({\n        type: \"onAuthRequest\",\n        topic: e,\n        payload: i\n      });\n      const o = K(JSON.stringify(i)),\n        u = await this.getVerifyContext(o, this.client.metadata),\n        a = {\n          requester: n,\n          pairingTopic: e,\n          id: i.id,\n          cacaoPayload: s,\n          verifyContext: u\n        };\n      await this.client.requests.set(i.id, a), this.handleAuthRequest(a);\n    }, this.handleAuthRequest = async e => {\n      const {\n        id: i,\n        pairingTopic: n,\n        requester: s,\n        cacaoPayload: o,\n        verifyContext: u\n      } = e;\n      try {\n        this.client.emit(\"auth_request\", {\n          id: i,\n          topic: n,\n          params: {\n            requester: s,\n            cacaoPayload: o\n          },\n          verifyContext: u\n        });\n      } catch (a) {\n        await this.sendError(e.id, e.pairingTopic, a), this.client.logger.error(a);\n      }\n    }, this.onAuthResponse = async (e, i) => {\n      const {\n        id: n\n      } = i;\n      if (this.client.logger.info({\n        type: \"onAuthResponse\",\n        topic: e,\n        response: i\n      }), Se(i)) {\n        const {\n          pairingTopic: s\n        } = this.client.pairingTopics.get(e);\n        await this.client.core.pairing.activate({\n          topic: s\n        });\n        const {\n          s: o,\n          p: u\n        } = i.result;\n        await this.client.requests.set(n, I({\n          id: n,\n          pairingTopic: s\n        }, i.result));\n        const a = this.formatMessage(u, u.iss);\n        this.client.logger.debug(`reconstructed message:\n`, JSON.stringify(a)), this.client.logger.debug(\"payload.iss:\", u.iss), this.client.logger.debug(\"signature:\", o);\n        const c = W(u.iss),\n          h = We(u.iss);\n        if (!c) throw new Error(\"Could not derive address from `payload.iss`\");\n        if (!h) throw new Error(\"Could not derive chainId from `payload.iss`\");\n        this.client.logger.debug(\"walletAddress extracted from `payload.iss`:\", c), (await et(c, a, o, h, this.client.projectId)) ? this.client.emit(\"auth_response\", {\n          id: n,\n          topic: e,\n          params: i\n        }) : this.client.emit(\"auth_response\", {\n          id: n,\n          topic: e,\n          params: {\n            message: \"Invalid signature\",\n            code: -1\n          }\n        });\n      } else Pe(i) && this.client.emit(\"auth_response\", {\n        id: n,\n        topic: e,\n        params: i\n      });\n    }, this.getVerifyContext = async (e, i) => {\n      const n = {\n        verified: {\n          verifyUrl: i.verifyUrl || \"\",\n          validation: \"UNKNOWN\",\n          origin: i.url || \"\"\n        }\n      };\n      try {\n        const s = await this.client.core.verify.resolve({\n          attestationId: e,\n          verifyUrl: i.verifyUrl\n        });\n        s && (n.verified.origin = s.origin, n.verified.isScam = s.isScam, n.verified.validation = origin === new URL(i.url).origin ? \"VALID\" : \"INVALID\");\n      } catch (s) {\n        this.client.logger.error(s);\n      }\n      return this.client.logger.info(`Verify context: ${JSON.stringify(n)}`), n;\n    };\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: t\n      } = k(\"NOT_INITIALIZED\", this.name);\n      throw new Error(t);\n    }\n  }\n  registerRelayerEvents() {\n    this.client.core.relayer.on(ve.message, async t => {\n      const {\n          topic: e,\n          message: i\n        } = t,\n        {\n          responseTopic: n,\n          publicKey: s\n        } = this.client.authKeys.keys.includes(x) ? this.client.authKeys.get(x) : {\n          responseTopic: void 0,\n          publicKey: void 0\n        };\n      if (n && e !== n) {\n        this.client.logger.debug(\"[Auth] Ignoring message from unknown topic\", e);\n        return;\n      }\n      const o = await this.client.core.crypto.decode(e, i, {\n        receiverPublicKey: s\n      });\n      Ne(o) ? (this.client.core.history.set(e, o), this.onRelayEventRequest({\n        topic: e,\n        payload: o\n      })) : $e(o) && (await this.client.core.history.resolve(o), this.onRelayEventResponse({\n        topic: e,\n        payload: o\n      }));\n    });\n  }\n  registerPairingEvents() {\n    this.client.core.pairing.events.on(Ae.create, t => this.onPairingCreated(t));\n  }\n}\nclass S extends H {\n  constructor(t) {\n    super(t), this.protocol = $, this.version = Q, this.name = B, this.events = new Ie(), this.emit = (i, n) => this.events.emit(i, n), this.on = (i, n) => this.events.on(i, n), this.once = (i, n) => this.events.once(i, n), this.off = (i, n) => this.events.off(i, n), this.removeListener = (i, n) => this.events.removeListener(i, n), this.request = async (i, n) => {\n      try {\n        return await this.engine.request(i, n);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.respond = async (i, n) => {\n      try {\n        return await this.engine.respond(i, n);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.getPendingRequests = () => {\n      try {\n        return this.engine.getPendingRequests();\n      } catch (i) {\n        throw this.logger.error(i.message), i;\n      }\n    }, this.formatMessage = (i, n) => {\n      try {\n        return this.engine.formatMessage(i, n);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    };\n    const e = typeof t.logger < \"u\" && typeof t.logger != \"string\" ? t.logger : xe(Re({\n      level: t.logger || \"error\"\n    }));\n    this.name = t?.name || B, this.metadata = t.metadata, this.projectId = t.projectId, this.core = t.core || new _e(t), this.logger = Fe(e, this.name), this.authKeys = new P(this.core, this.logger, \"authKeys\", F, () => x), this.pairingTopics = new P(this.core, this.logger, \"pairingTopics\", F), this.requests = new P(this.core, this.logger, \"requests\", F, i => i.id), this.engine = new Br(this);\n  }\n  static async init(t) {\n    const e = new S(t);\n    return await e.initialize(), e;\n  }\n  get context() {\n    return Te(this.logger);\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.core.start(), await this.authKeys.init(), await this.requests.init(), await this.pairingTopics.init(), await this.engine.init(), this.logger.info(\"AuthClient Initialization Success\"), this.logger.info({\n        authClient: this\n      });\n    } catch (t) {\n      throw this.logger.info(\"AuthClient Initialization Failure\"), this.logger.error(t.message), t;\n    }\n  }\n}\nconst zr = S;\nexport { Z as AUTH_CLIENT_CONTEXT, B as AUTH_CLIENT_DEFAULT_NAME, $ as AUTH_CLIENT_PROTOCOL, x as AUTH_CLIENT_PUBLIC_KEY_NAME, F as AUTH_CLIENT_STORAGE_PREFIX, Q as AUTH_CLIENT_VERSION, U as AUTH_REQUEST_EXPIRY_BOUNDARIES, zr as AuthClient, Ir as BASE10, ye as BASE16, qr as BASE64, Y as DEFAULT_RPC_URL, R as ENGINE_RPC_OPTS, Ge as EXPIRER_CONTEXT, Qe as EXPIRER_DEFAULT_TTL, He as EXPIRER_EVENTS, Ye as EXPIRER_STORAGE_VERSION, H as IAuthClient, G as IAuthEngine, we as UTF8, S as default, Ur as generateNonce, K as hashMessage };","map":{"version":3,"names":[],"sources":["C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\@walletconnect\\auth-client\\src\\types\\engine.ts","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\@walletconnect\\auth-client\\src\\types\\client.ts","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\@walletconnect\\auth-client\\src\\constants\\defaults.ts","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\@walletconnect\\auth-client\\src\\constants\\engine.ts","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\@walletconnect\\auth-client\\src\\constants\\client.ts","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\@walletconnect\\auth-client\\src\\constants\\expirer.ts","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\@walletconnect\\auth-client\\src\\utils\\address.ts","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\@walletconnect\\auth-client\\src\\utils\\signature.ts","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\@walletconnect\\auth-client\\src\\utils\\store.ts","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\@walletconnect\\auth-client\\src\\utils\\validators.ts","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\node_modules\\uint8arrays\\esm\\src\\alloc.js","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\node_modules\\multiformats\\esm\\vendor\\base-x.js","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\node_modules\\multiformats\\esm\\src\\bytes.js","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base.js","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\identity.js","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base2.js","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base8.js","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base10.js","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base16.js","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base32.js","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base36.js","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base58.js","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base64.js","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base256emoji.js","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\node_modules\\multiformats\\esm\\vendor\\varint.js","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\node_modules\\multiformats\\esm\\src\\varint.js","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\node_modules\\multiformats\\esm\\src\\hashes\\digest.js","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\node_modules\\multiformats\\esm\\src\\hashes\\hasher.js","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\node_modules\\multiformats\\esm\\src\\hashes\\sha2-browser.js","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\node_modules\\multiformats\\esm\\src\\hashes\\identity.js","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\node_modules\\multiformats\\esm\\src\\codecs\\json.js","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\node_modules\\multiformats\\esm\\src\\basics.js","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\node_modules\\uint8arrays\\esm\\src\\util\\bases.js","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\node_modules\\uint8arrays\\esm\\src\\from-string.js","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\node_modules\\uint8arrays\\esm\\src\\to-string.js","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\@walletconnect\\auth-client\\src\\utils\\crypto.ts","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\@walletconnect\\auth-client\\src\\controllers\\engine.ts","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\@walletconnect\\auth-client\\src\\client.ts","C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\@walletconnect\\auth-client\\src\\index.ts"],"sourcesContent":["import { CryptoTypes, RelayerTypes, Verify } from \"@walletconnect/types\";\n\nimport {\n  ErrorResponse as CommonErrorResponse,\n  JsonRpcError,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  JsonRpcResult,\n} from \"@walletconnect/jsonrpc-utils\";\nimport { AuthClientTypes, IAuthClient } from \"./client\";\nimport { JsonRpcTypes } from \"./jsonrpc\";\n\nexport interface RpcOpts {\n  req: RelayerTypes.PublishOptions;\n  res: RelayerTypes.PublishOptions;\n}\n\nexport declare namespace AuthEngineTypes {\n  interface EventCallback<T extends JsonRpcRequest | JsonRpcResponse> {\n    topic: string;\n    payload: T;\n  }\n\n  // https://github.com/ChainAgnostic/CAIPs/pull/74\n  interface RequestParams {\n    chainId: string;\n    domain: string;\n    nonce: string;\n    aud: string;\n    type?: CacaoHeader[\"t\"];\n    nbf?: string;\n    exp?: string;\n    statement?: string;\n    requestId?: string;\n    resources?: string[];\n    expiry?: number;\n  }\n\n  interface PayloadParams {\n    type: CacaoHeader[\"t\"];\n    chainId: string;\n    domain: string;\n    aud: string;\n    version: string;\n    nonce: string;\n    iat: string;\n    nbf?: string;\n    exp?: string;\n    statement?: string;\n    requestId?: string;\n    resources?: string[];\n  }\n  interface CacaoPayload {\n    iss: string;\n    domain: string;\n    aud: string;\n    version: string;\n    nonce: string;\n    iat: string;\n    nbf?: string;\n    exp?: string;\n    chainId?: string;\n    statement?: string;\n    requestId?: string;\n    resources?: string[];\n  }\n\n  type CacaoRequestPayload = Omit<CacaoPayload, \"iss\">;\n\n  interface CacaoHeader {\n    t: \"eip4361\";\n  }\n\n  interface CacaoSignature {\n    t: \"eip191\" | \"eip1271\";\n    s: string;\n    m?: string;\n  }\n\n  interface Cacao {\n    h: CacaoHeader;\n    p: CacaoPayload;\n    s: CacaoSignature;\n  }\n\n  interface PendingRequest {\n    id: number;\n    pairingTopic: string;\n    requester: {\n      publicKey: string;\n      metadata: AuthClientTypes.Metadata;\n    };\n    cacaoPayload: CacaoRequestPayload;\n    verifyContext: Verify.Context;\n  }\n\n  interface ResultResponse {\n    id: number;\n    signature: CacaoSignature;\n  }\n\n  interface ErrorResponse {\n    id: number;\n    error: CommonErrorResponse;\n  }\n\n  type RespondParams = ResultResponse | ErrorResponse;\n}\n\nexport abstract class IAuthEngine {\n  constructor(public client: IAuthClient) {}\n\n  public abstract init(): void;\n\n  public abstract request(\n    params: AuthEngineTypes.RequestParams,\n    opts?: { topic?: string },\n  ): Promise<{ uri?: string; id: number }>;\n\n  public abstract respond(params: AuthEngineTypes.RespondParams, iss: string): Promise<void>;\n\n  public abstract getPendingRequests(): Record<number, AuthEngineTypes.PendingRequest>;\n\n  public abstract formatMessage(payload: AuthEngineTypes.CacaoRequestPayload, iss: string): string;\n\n  // ---------- Protected Helpers --------------------------------------- //\n\n  protected abstract sendRequest<M extends JsonRpcTypes.WcMethod>(\n    topic: string,\n    method: M,\n    params: JsonRpcTypes.RequestParams[M],\n    encodeOpts?: CryptoTypes.EncodeOptions,\n    expiry?: number,\n  ): Promise<number>;\n\n  protected abstract sendResult<M extends JsonRpcTypes.WcMethod>(\n    id: number,\n    topic: string,\n    result: JsonRpcTypes.Results[M],\n    encodeOpts?: CryptoTypes.EncodeOptions,\n  ): Promise<number>;\n\n  protected abstract sendError(\n    id: number,\n    topic: string,\n    error: AuthEngineTypes.ErrorResponse,\n    opts?: CryptoTypes.EncodeOptions,\n  ): Promise<number>;\n\n  protected abstract setExpiry(topic: string, expiry: number): Promise<void>;\n\n  // ---------- Protected Relay Event Methods ----------------------------------- //\n\n  protected abstract onRelayEventRequest(\n    event: AuthEngineTypes.EventCallback<JsonRpcRequest>,\n  ): void;\n\n  protected abstract onRelayEventResponse(\n    event: AuthEngineTypes.EventCallback<JsonRpcResponse>,\n  ): Promise<void>;\n\n  // ---------- Protected Relay Event Handlers --------------------------------- //\n\n  protected abstract onAuthRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_authRequest\"]>,\n  ): Promise<void>;\n\n  protected abstract onAuthResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_authRequest\"]> | JsonRpcError,\n  ): void;\n}\n","import { ICore, IStore, CoreTypes, Verify } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { AuthEngineTypes } from \"./engine\";\n\nimport { IAuthEngine } from \"../types\";\nimport { JsonRpcError, JsonRpcResult } from \"@walletconnect/jsonrpc-utils\";\nimport { Logger } from \"@walletconnect/logger\";\n\nexport declare namespace AuthClientTypes {\n  type Event = \"auth_request\" | \"auth_response\";\n\n  interface AuthRequestEventArgs {\n    requester: AuthEngineTypes.PendingRequest[\"requester\"];\n    cacaoPayload: AuthEngineTypes.CacaoRequestPayload;\n  }\n\n  type AuthResponseEventArgs =\n    | { message: string; code: number }\n    | JsonRpcResult<AuthEngineTypes.Cacao>\n    | JsonRpcError;\n\n  interface BaseEventArgs<T = unknown> {\n    id: number;\n    topic: string;\n    params: T;\n    verifyContext?: Verify.Context;\n  }\n\n  interface EventArguments {\n    auth_request: BaseEventArgs<AuthRequestEventArgs>;\n    auth_response: BaseEventArgs<AuthResponseEventArgs>;\n  }\n\n  interface Options extends CoreTypes.Options {\n    metadata: Metadata;\n    core?: ICore;\n    projectId: string;\n  }\n\n  interface Metadata {\n    name: string;\n    description: string;\n    url: string;\n    icons: string[];\n    redirect?: {\n      native?: string;\n      universal?: string;\n    };\n    verifyUrl?: string;\n  }\n}\n\nexport abstract class IAuthClient {\n  public abstract readonly protocol: string;\n  public abstract readonly version: number;\n  public abstract readonly name: string;\n\n  public abstract core: ICore;\n  public abstract metadata: AuthClientTypes.Metadata;\n  public abstract projectId: string;\n  public abstract authKeys: IStore<string, { responseTopic: string; publicKey: string }>;\n  public abstract pairingTopics: IStore<string, { topic: string; pairingTopic: string }>;\n  public abstract requests: IStore<\n    number,\n    { id: number } & (AuthEngineTypes.Cacao | AuthEngineTypes.PendingRequest)\n  >;\n\n  public abstract events: EventEmitter;\n  public abstract logger: Logger;\n  public abstract engine: IAuthEngine;\n\n  constructor(public opts: AuthClientTypes.Options) {}\n\n  // ---------- Public Methods ----------------------------------------------- //\n\n  public abstract request: IAuthEngine[\"request\"];\n  public abstract respond: IAuthEngine[\"respond\"];\n  public abstract formatMessage: IAuthEngine[\"formatMessage\"];\n  public abstract getPendingRequests: IAuthEngine[\"getPendingRequests\"];\n\n  // ---------- Event Handlers ----------------------------------------------- //\n\n  public abstract emit: <E extends AuthClientTypes.Event>(\n    event: E,\n    args: AuthClientTypes.EventArguments[E],\n  ) => boolean;\n\n  public abstract on: <E extends AuthClientTypes.Event>(\n    event: E,\n    listener: (args: AuthClientTypes.EventArguments[E]) => void,\n  ) => EventEmitter;\n\n  public abstract once: <E extends AuthClientTypes.Event>(\n    event: E,\n    listener: (args: AuthClientTypes.EventArguments[E]) => void,\n  ) => EventEmitter;\n\n  public abstract off: <E extends AuthClientTypes.Event>(\n    event: E,\n    listener: (args: AuthClientTypes.EventArguments[E]) => void,\n  ) => EventEmitter;\n\n  public abstract removeListener: <E extends AuthClientTypes.Event>(\n    event: E,\n    listener: (args: AuthClientTypes.EventArguments[E]) => void,\n  ) => EventEmitter;\n}\n","export const DEFAULT_RPC_URL = \"https://rpc.walletconnect.com/v1\";\n","import { ONE_DAY, FIVE_MINUTES, SEVEN_DAYS } from \"@walletconnect/time\";\nimport { JsonRpcTypes, RpcOpts } from \"../types\";\n\nexport const ENGINE_RPC_OPTS: Record<JsonRpcTypes.WcMethod, RpcOpts> = {\n  wc_authRequest: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: true,\n      tag: 3000,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 3001,\n    },\n  },\n};\n\nexport const AUTH_REQUEST_EXPIRY_BOUNDARIES = {\n  min: FIVE_MINUTES,\n  max: SEVEN_DAYS,\n};\n","export const AUTH_CLIENT_PROTOCOL = \"wc\";\nexport const AUTH_CLIENT_VERSION = 1;\nexport const AUTH_CLIENT_CONTEXT = \"auth\";\nexport const AUTH_CLIENT_DEFAULT_NAME = \"authClient\";\n\nexport const AUTH_CLIENT_STORAGE_PREFIX = `${AUTH_CLIENT_PROTOCOL}@${AUTH_CLIENT_VERSION}:${AUTH_CLIENT_CONTEXT}:`;\nexport const AUTH_CLIENT_PUBLIC_KEY_NAME = `${AUTH_CLIENT_STORAGE_PREFIX}:PUB_KEY`;\n","import { ONE_DAY } from \"@walletconnect/time\";\n\nexport const EXPIRER_CONTEXT = \"expirer\";\n\nexport const EXPIRER_EVENTS = {\n  created: \"expirer_created\",\n  deleted: \"expirer_deleted\",\n  expired: \"expirer_expired\",\n  sync: \"expirer_sync\",\n};\n\nexport const EXPIRER_STORAGE_VERSION = \"0.3\";\n\nexport const EXPIRER_DEFAULT_TTL = ONE_DAY;\n","export function getDidAddressSegments(iss: string) {\n  return iss?.split(\":\");\n}\n\nexport function getDidChainId(iss: string) {\n  const segments = iss && getDidAddressSegments(iss);\n  if (segments) {\n    return segments[3];\n  }\n  return undefined;\n}\n\nexport function getNamespacedDidChainId(iss: string) {\n  const segments = iss && getDidAddressSegments(iss);\n  if (segments) {\n    return segments[2] + \":\" + segments[3];\n  }\n  return undefined;\n}\n\nexport function getDidAddress(iss: string) {\n  const segments = iss && getDidAddressSegments(iss);\n  if (segments) {\n    return segments.pop();\n  }\n  return undefined;\n}\n","import { hashMessage } from \"@ethersproject/hash\";\nimport { recoverAddress } from \"@ethersproject/transactions\";\nimport fetch from \"isomorphic-unfetch\";\n\nimport { AuthEngineTypes } from \"../types\";\nimport { DEFAULT_RPC_URL } from \"../constants/defaults\";\n\nexport async function verifySignature(\n  address: string,\n  reconstructedMessage: string,\n  cacaoSignature: AuthEngineTypes.CacaoSignature,\n  chainId: string,\n  projectId: string,\n): Promise<boolean> {\n  // Determine if this signature is from an EOA or a contract.\n  switch (cacaoSignature.t) {\n    case \"eip191\":\n      return isValidEip191Signature(address, reconstructedMessage, cacaoSignature.s);\n    case \"eip1271\":\n      return await isValidEip1271Signature(\n        address,\n        reconstructedMessage,\n        cacaoSignature.s,\n        chainId,\n        projectId,\n      );\n    default:\n      throw new Error(\n        `verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${cacaoSignature.t}`,\n      );\n  }\n}\n\nfunction isValidEip191Signature(address: string, message: string, signature: string): boolean {\n  const recoveredAddress = recoverAddress(hashMessage(message), signature);\n  return recoveredAddress.toLowerCase() === address.toLowerCase();\n}\n\nasync function isValidEip1271Signature(\n  address: string,\n  reconstructedMessage: string,\n  signature: string,\n  chainId: string,\n  projectId: string,\n) {\n  try {\n    const eip1271MagicValue = \"0x1626ba7e\";\n    const dynamicTypeOffset = \"0000000000000000000000000000000000000000000000000000000000000040\";\n    const dynamicTypeLength = \"0000000000000000000000000000000000000000000000000000000000000041\";\n    const nonPrefixedSignature = signature.substring(2);\n    const nonPrefixedHashedMessage = hashMessage(reconstructedMessage).substring(2);\n\n    const data =\n      eip1271MagicValue +\n      nonPrefixedHashedMessage +\n      dynamicTypeOffset +\n      dynamicTypeLength +\n      nonPrefixedSignature;\n\n    const response = await fetch(`${DEFAULT_RPC_URL}/?chainId=${chainId}&projectId=${projectId}`, {\n      method: \"POST\",\n      body: JSON.stringify({\n        id: generateJsonRpcId(),\n        jsonrpc: \"2.0\",\n        method: \"eth_call\",\n        params: [{ to: address, data }, \"latest\"],\n      }),\n    });\n    const { result } = await response.json();\n\n    if (!result) return false;\n\n    // Remove right-padded zeros from result to get only the concrete recovered value.\n    const recoveredValue = result.slice(0, eip1271MagicValue.length);\n    return recoveredValue.toLowerCase() === eip1271MagicValue.toLowerCase();\n  } catch (error: any) {\n    console.error(\"isValidEip1271Signature: \", error);\n    return false;\n  }\n}\n\nfunction generateJsonRpcId() {\n  return Date.now() + Math.floor(Math.random() * 1000);\n}\n","import { AuthEngineTypes, IAuthClient } from \"../types\";\n\nexport function getPendingRequests(store: IAuthClient[\"requests\"]) {\n  return store.getAll().filter((request) => \"requester\" in request) as ({\n    id: number;\n  } & AuthEngineTypes.PendingRequest)[];\n}\n\nexport function getCompleteRequests(store: IAuthClient[\"requests\"]) {\n  return store.getAll().filter((request) => !(\"requester\" in request)) as ({\n    id: number;\n  } & AuthEngineTypes.Cacao)[];\n}\n\nexport function getPendingRequest(store: IAuthClient[\"requests\"], id: number) {\n  return getPendingRequests(store).find(\n    (request) => request.id === id,\n  ) as AuthEngineTypes.PendingRequest;\n}\n\nexport function getCompleteResponse(store: IAuthClient[\"requests\"], id: number) {\n  return getCompleteRequests(store).find((request) => request.id === id) as AuthEngineTypes.Cacao;\n}\n","import { IStore } from \"@walletconnect/types\";\nimport { getInternalError, isValidRequestExpiry, isValidUrl } from \"@walletconnect/utils\";\nimport { AUTH_REQUEST_EXPIRY_BOUNDARIES } from \"../constants\";\nimport { AuthEngineTypes } from \"../types\";\nimport { getPendingRequest } from \"./store\";\n\nexport function isValidRequest(params: AuthEngineTypes.RequestParams): boolean {\n  const validAudience = isValidUrl(params.aud);\n  // FIXME: disabling this temporarily since it's failing expected values like `chainId: \"1\"`\n  // const validChainId = isValidChainId(params.chainId);\n  const domainInAud = new RegExp(`${params.domain}`).test(params.aud);\n  const hasNonce = !!params.nonce;\n  const hasValidType = params.type ? params.type === \"eip4361\" : true;\n  const expiry = params.expiry;\n  if (expiry && !isValidRequestExpiry(expiry, AUTH_REQUEST_EXPIRY_BOUNDARIES)) {\n    const { message } = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `request() expiry: ${expiry}. Expiry must be a number (in seconds) between ${AUTH_REQUEST_EXPIRY_BOUNDARIES.min} and ${AUTH_REQUEST_EXPIRY_BOUNDARIES.max}`,\n    );\n    throw new Error(message);\n  }\n\n  return !!(validAudience /*&& validChainId*/ && domainInAud && hasNonce && hasValidType);\n}\n\nexport function isValidRespond(\n  params: AuthEngineTypes.RespondParams,\n  pendingResponses: IStore<number, any>,\n): boolean {\n  const validId = getPendingRequest(pendingResponses, params.id);\n\n  return !!validId;\n}\n","export function alloc(size = 0) {\n  if (globalThis.Buffer != null && globalThis.Buffer.alloc != null) {\n    return globalThis.Buffer.alloc(size);\n  }\n  return new Uint8Array(size);\n}\nexport function allocUnsafe(size = 0) {\n  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {\n    return globalThis.Buffer.allocUnsafe(size);\n  }\n  return new Uint8Array(size);\n}","function base(ALPHABET, name) {\n  if (ALPHABET.length >= 255) {\n    throw new TypeError('Alphabet too long');\n  }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) {\n      throw new TypeError(x + ' is ambiguous');\n    }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256);\n  var iFACTOR = Math.log(256) / Math.log(BASE);\n  function encode(source) {\n    if (source instanceof Uint8Array);\n    else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) {\n      throw new TypeError('Expected Uint8Array');\n    }\n    if (source.length === 0) {\n      return '';\n    }\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n    var b58 = new Uint8Array(size);\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {\n        carry += 256 * b58[it1] >>> 0;\n        b58[it1] = carry % BASE >>> 0;\n        carry = carry / BASE >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n      length = i;\n      pbegin++;\n    }\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) {\n      str += ALPHABET.charAt(b58[it2]);\n    }\n    return str;\n  }\n  function decodeUnsafe(source) {\n    if (typeof source !== 'string') {\n      throw new TypeError('Expected String');\n    }\n    if (source.length === 0) {\n      return new Uint8Array();\n    }\n    var psz = 0;\n    if (source[psz] === ' ') {\n      return;\n    }\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n    var size = (source.length - psz) * FACTOR + 1 >>> 0;\n    var b256 = new Uint8Array(size);\n    while (source[psz]) {\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n      if (carry === 255) {\n        return;\n      }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {\n        carry += BASE * b256[it3] >>> 0;\n        b256[it3] = carry % 256 >>> 0;\n        carry = carry / 256 >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n      length = i;\n      psz++;\n    }\n    if (source[psz] === ' ') {\n      return;\n    }\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch;\n  }\n  function decode(string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) {\n      return buffer;\n    }\n    throw new Error(`Non-${ name } character`);\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  };\n}\nvar src = base;\nvar _brrp__multiformats_scope_baseX = src;\nexport default _brrp__multiformats_scope_baseX;","const empty = new Uint8Array(0);\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '');\nconst fromHex = hex => {\n  const hexes = hex.match(/../g);\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty;\n};\nconst equals = (aa, bb) => {\n  if (aa === bb)\n    return true;\n  if (aa.byteLength !== bb.byteLength) {\n    return false;\n  }\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false;\n    }\n  }\n  return true;\n};\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array')\n    return o;\n  if (o instanceof ArrayBuffer)\n    return new Uint8Array(o);\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);\n  }\n  throw new Error('Unknown type, must be binary type');\n};\nconst isBinary = o => o instanceof ArrayBuffer || ArrayBuffer.isView(o);\nconst fromString = str => new TextEncoder().encode(str);\nconst toString = b => new TextDecoder().decode(b);\nexport {\n  equals,\n  coerce,\n  isBinary,\n  fromHex,\n  toHex,\n  fromString,\n  toString,\n  empty\n};","import basex from '../../vendor/base-x.js';\nimport { coerce } from '../bytes.js';\nclass Encoder {\n  constructor(name, prefix, baseEncode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n  }\n  encode(bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${ this.prefix }${ this.baseEncode(bytes) }`;\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n}\nclass Decoder {\n  constructor(name, prefix, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character');\n    }\n    this.prefixCodePoint = prefix.codePointAt(0);\n    this.baseDecode = baseDecode;\n  }\n  decode(text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${ JSON.stringify(text) }, ${ this.name } decoder only supports inputs prefixed with ${ this.prefix }`);\n      }\n      return this.baseDecode(text.slice(this.prefix.length));\n    } else {\n      throw Error('Can only multibase decode strings');\n    }\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n}\nclass ComposedDecoder {\n  constructor(decoders) {\n    this.decoders = decoders;\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n  decode(input) {\n    const prefix = input[0];\n    const decoder = this.decoders[prefix];\n    if (decoder) {\n      return decoder.decode(input);\n    } else {\n      throw RangeError(`Unable to decode multibase string ${ JSON.stringify(input) }, only inputs prefixed with ${ Object.keys(this.decoders) } are supported`);\n    }\n  }\n}\nexport const or = (left, right) => new ComposedDecoder({\n  ...left.decoders || { [left.prefix]: left },\n  ...right.decoders || { [right.prefix]: right }\n});\nexport class Codec {\n  constructor(name, prefix, baseEncode, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n    this.baseDecode = baseDecode;\n    this.encoder = new Encoder(name, prefix, baseEncode);\n    this.decoder = new Decoder(name, prefix, baseDecode);\n  }\n  encode(input) {\n    return this.encoder.encode(input);\n  }\n  decode(input) {\n    return this.decoder.decode(input);\n  }\n}\nexport const from = ({name, prefix, encode, decode}) => new Codec(name, prefix, encode, decode);\nexport const baseX = ({prefix, name, alphabet}) => {\n  const {encode, decode} = basex(alphabet, name);\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: text => coerce(decode(text))\n  });\n};\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  const codes = {};\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i;\n  }\n  let end = string.length;\n  while (string[end - 1] === '=') {\n    --end;\n  }\n  const out = new Uint8Array(end * bitsPerChar / 8 | 0);\n  let bits = 0;\n  let buffer = 0;\n  let written = 0;\n  for (let i = 0; i < end; ++i) {\n    const value = codes[string[i]];\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${ name } character`);\n    }\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar;\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 255 & buffer >> bits;\n    }\n  }\n  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n  return out;\n};\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '=';\n  const mask = (1 << bitsPerChar) - 1;\n  let out = '';\n  let bits = 0;\n  let buffer = 0;\n  for (let i = 0; i < data.length; ++i) {\n    buffer = buffer << 8 | data[i];\n    bits += 8;\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet[mask & buffer >> bits];\n    }\n  }\n  if (bits) {\n    out += alphabet[mask & buffer << bitsPerChar - bits];\n  }\n  if (pad) {\n    while (out.length * bitsPerChar & 7) {\n      out += '=';\n    }\n  }\n  return out;\n};\nexport const rfc4648 = ({name, prefix, bitsPerChar, alphabet}) => {\n  return from({\n    prefix,\n    name,\n    encode(input) {\n      return encode(input, alphabet, bitsPerChar);\n    },\n    decode(input) {\n      return decode(input, alphabet, bitsPerChar, name);\n    }\n  });\n};","import { from } from './base.js';\nimport {\n  fromString,\n  toString\n} from '../bytes.js';\nexport const identity = from({\n  prefix: '\\0',\n  name: 'identity',\n  encode: buf => toString(buf),\n  decode: str => fromString(str)\n});","import { rfc4648 } from './base.js';\nexport const base2 = rfc4648({\n  prefix: '0',\n  name: 'base2',\n  alphabet: '01',\n  bitsPerChar: 1\n});","import { rfc4648 } from './base.js';\nexport const base8 = rfc4648({\n  prefix: '7',\n  name: 'base8',\n  alphabet: '01234567',\n  bitsPerChar: 3\n});","import { baseX } from './base.js';\nexport const base10 = baseX({\n  prefix: '9',\n  name: 'base10',\n  alphabet: '0123456789'\n});","import { rfc4648 } from './base.js';\nexport const base16 = rfc4648({\n  prefix: 'f',\n  name: 'base16',\n  alphabet: '0123456789abcdef',\n  bitsPerChar: 4\n});\nexport const base16upper = rfc4648({\n  prefix: 'F',\n  name: 'base16upper',\n  alphabet: '0123456789ABCDEF',\n  bitsPerChar: 4\n});","import { rfc4648 } from './base.js';\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n});\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n});\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n});\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n});\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n});\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n});\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n});\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n});\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n});","import { baseX } from './base.js';\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n});\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n});","import { baseX } from './base.js';\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n});\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n});","import { rfc4648 } from './base.js';\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n});\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n});\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n});\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n});","import { from } from './base.js';\nconst alphabet = Array.from('\\uD83D\\uDE80\\uD83E\\uDE90\\u2604\\uD83D\\uDEF0\\uD83C\\uDF0C\\uD83C\\uDF11\\uD83C\\uDF12\\uD83C\\uDF13\\uD83C\\uDF14\\uD83C\\uDF15\\uD83C\\uDF16\\uD83C\\uDF17\\uD83C\\uDF18\\uD83C\\uDF0D\\uD83C\\uDF0F\\uD83C\\uDF0E\\uD83D\\uDC09\\u2600\\uD83D\\uDCBB\\uD83D\\uDDA5\\uD83D\\uDCBE\\uD83D\\uDCBF\\uD83D\\uDE02\\u2764\\uD83D\\uDE0D\\uD83E\\uDD23\\uD83D\\uDE0A\\uD83D\\uDE4F\\uD83D\\uDC95\\uD83D\\uDE2D\\uD83D\\uDE18\\uD83D\\uDC4D\\uD83D\\uDE05\\uD83D\\uDC4F\\uD83D\\uDE01\\uD83D\\uDD25\\uD83E\\uDD70\\uD83D\\uDC94\\uD83D\\uDC96\\uD83D\\uDC99\\uD83D\\uDE22\\uD83E\\uDD14\\uD83D\\uDE06\\uD83D\\uDE44\\uD83D\\uDCAA\\uD83D\\uDE09\\u263A\\uD83D\\uDC4C\\uD83E\\uDD17\\uD83D\\uDC9C\\uD83D\\uDE14\\uD83D\\uDE0E\\uD83D\\uDE07\\uD83C\\uDF39\\uD83E\\uDD26\\uD83C\\uDF89\\uD83D\\uDC9E\\u270C\\u2728\\uD83E\\uDD37\\uD83D\\uDE31\\uD83D\\uDE0C\\uD83C\\uDF38\\uD83D\\uDE4C\\uD83D\\uDE0B\\uD83D\\uDC97\\uD83D\\uDC9A\\uD83D\\uDE0F\\uD83D\\uDC9B\\uD83D\\uDE42\\uD83D\\uDC93\\uD83E\\uDD29\\uD83D\\uDE04\\uD83D\\uDE00\\uD83D\\uDDA4\\uD83D\\uDE03\\uD83D\\uDCAF\\uD83D\\uDE48\\uD83D\\uDC47\\uD83C\\uDFB6\\uD83D\\uDE12\\uD83E\\uDD2D\\u2763\\uD83D\\uDE1C\\uD83D\\uDC8B\\uD83D\\uDC40\\uD83D\\uDE2A\\uD83D\\uDE11\\uD83D\\uDCA5\\uD83D\\uDE4B\\uD83D\\uDE1E\\uD83D\\uDE29\\uD83D\\uDE21\\uD83E\\uDD2A\\uD83D\\uDC4A\\uD83E\\uDD73\\uD83D\\uDE25\\uD83E\\uDD24\\uD83D\\uDC49\\uD83D\\uDC83\\uD83D\\uDE33\\u270B\\uD83D\\uDE1A\\uD83D\\uDE1D\\uD83D\\uDE34\\uD83C\\uDF1F\\uD83D\\uDE2C\\uD83D\\uDE43\\uD83C\\uDF40\\uD83C\\uDF37\\uD83D\\uDE3B\\uD83D\\uDE13\\u2B50\\u2705\\uD83E\\uDD7A\\uD83C\\uDF08\\uD83D\\uDE08\\uD83E\\uDD18\\uD83D\\uDCA6\\u2714\\uD83D\\uDE23\\uD83C\\uDFC3\\uD83D\\uDC90\\u2639\\uD83C\\uDF8A\\uD83D\\uDC98\\uD83D\\uDE20\\u261D\\uD83D\\uDE15\\uD83C\\uDF3A\\uD83C\\uDF82\\uD83C\\uDF3B\\uD83D\\uDE10\\uD83D\\uDD95\\uD83D\\uDC9D\\uD83D\\uDE4A\\uD83D\\uDE39\\uD83D\\uDDE3\\uD83D\\uDCAB\\uD83D\\uDC80\\uD83D\\uDC51\\uD83C\\uDFB5\\uD83E\\uDD1E\\uD83D\\uDE1B\\uD83D\\uDD34\\uD83D\\uDE24\\uD83C\\uDF3C\\uD83D\\uDE2B\\u26BD\\uD83E\\uDD19\\u2615\\uD83C\\uDFC6\\uD83E\\uDD2B\\uD83D\\uDC48\\uD83D\\uDE2E\\uD83D\\uDE46\\uD83C\\uDF7B\\uD83C\\uDF43\\uD83D\\uDC36\\uD83D\\uDC81\\uD83D\\uDE32\\uD83C\\uDF3F\\uD83E\\uDDE1\\uD83C\\uDF81\\u26A1\\uD83C\\uDF1E\\uD83C\\uDF88\\u274C\\u270A\\uD83D\\uDC4B\\uD83D\\uDE30\\uD83E\\uDD28\\uD83D\\uDE36\\uD83E\\uDD1D\\uD83D\\uDEB6\\uD83D\\uDCB0\\uD83C\\uDF53\\uD83D\\uDCA2\\uD83E\\uDD1F\\uD83D\\uDE41\\uD83D\\uDEA8\\uD83D\\uDCA8\\uD83E\\uDD2C\\u2708\\uD83C\\uDF80\\uD83C\\uDF7A\\uD83E\\uDD13\\uD83D\\uDE19\\uD83D\\uDC9F\\uD83C\\uDF31\\uD83D\\uDE16\\uD83D\\uDC76\\uD83E\\uDD74\\u25B6\\u27A1\\u2753\\uD83D\\uDC8E\\uD83D\\uDCB8\\u2B07\\uD83D\\uDE28\\uD83C\\uDF1A\\uD83E\\uDD8B\\uD83D\\uDE37\\uD83D\\uDD7A\\u26A0\\uD83D\\uDE45\\uD83D\\uDE1F\\uD83D\\uDE35\\uD83D\\uDC4E\\uD83E\\uDD32\\uD83E\\uDD20\\uD83E\\uDD27\\uD83D\\uDCCC\\uD83D\\uDD35\\uD83D\\uDC85\\uD83E\\uDDD0\\uD83D\\uDC3E\\uD83C\\uDF52\\uD83D\\uDE17\\uD83E\\uDD11\\uD83C\\uDF0A\\uD83E\\uDD2F\\uD83D\\uDC37\\u260E\\uD83D\\uDCA7\\uD83D\\uDE2F\\uD83D\\uDC86\\uD83D\\uDC46\\uD83C\\uDFA4\\uD83D\\uDE47\\uD83C\\uDF51\\u2744\\uD83C\\uDF34\\uD83D\\uDCA3\\uD83D\\uDC38\\uD83D\\uDC8C\\uD83D\\uDCCD\\uD83E\\uDD40\\uD83E\\uDD22\\uD83D\\uDC45\\uD83D\\uDCA1\\uD83D\\uDCA9\\uD83D\\uDC50\\uD83D\\uDCF8\\uD83D\\uDC7B\\uD83E\\uDD10\\uD83E\\uDD2E\\uD83C\\uDFBC\\uD83E\\uDD75\\uD83D\\uDEA9\\uD83C\\uDF4E\\uD83C\\uDF4A\\uD83D\\uDC7C\\uD83D\\uDC8D\\uD83D\\uDCE3\\uD83E\\uDD42');\nconst alphabetBytesToChars = alphabet.reduce((p, c, i) => {\n  p[i] = c;\n  return p;\n}, []);\nconst alphabetCharsToBytes = alphabet.reduce((p, c, i) => {\n  p[c.codePointAt(0)] = i;\n  return p;\n}, []);\nfunction encode(data) {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c];\n    return p;\n  }, '');\n}\nfunction decode(str) {\n  const byts = [];\n  for (const char of str) {\n    const byt = alphabetCharsToBytes[char.codePointAt(0)];\n    if (byt === undefined) {\n      throw new Error(`Non-base256emoji character: ${ char }`);\n    }\n    byts.push(byt);\n  }\n  return new Uint8Array(byts);\n}\nexport const base256emoji = from({\n  prefix: '\\uD83D\\uDE80',\n  name: 'base256emoji',\n  encode,\n  decode\n});","var encode_1 = encode;\nvar MSB = 128, REST = 127, MSBALL = ~REST, INT = Math.pow(2, 31);\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n  while (num >= INT) {\n    out[offset++] = num & 255 | MSB;\n    num /= 128;\n  }\n  while (num & MSBALL) {\n    out[offset++] = num & 255 | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  encode.bytes = offset - oldOffset + 1;\n  return out;\n}\nvar decode = read;\nvar MSB$1 = 128, REST$1 = 127;\nfunction read(buf, offset) {\n  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint');\n    }\n    b = buf[counter++];\n    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1);\n  read.bytes = counter - offset;\n  return res;\n}\nvar N1 = Math.pow(2, 7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\nvar length = function (value) {\n  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;\n};\nvar varint = {\n  encode: encode_1,\n  decode: decode,\n  encodingLength: length\n};\nvar _brrp_varint = varint;\nexport default _brrp_varint;","import varint from '../vendor/varint.js';\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset);\n  return [\n    code,\n    varint.decode.bytes\n  ];\n};\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset);\n  return target;\n};\nexport const encodingLength = int => {\n  return varint.encodingLength(int);\n};","import {\n  coerce,\n  equals as equalBytes\n} from '../bytes.js';\nimport * as varint from '../varint.js';\nexport const create = (code, digest) => {\n  const size = digest.byteLength;\n  const sizeOffset = varint.encodingLength(code);\n  const digestOffset = sizeOffset + varint.encodingLength(size);\n  const bytes = new Uint8Array(digestOffset + size);\n  varint.encodeTo(code, bytes, 0);\n  varint.encodeTo(size, bytes, sizeOffset);\n  bytes.set(digest, digestOffset);\n  return new Digest(code, size, digest, bytes);\n};\nexport const decode = multihash => {\n  const bytes = coerce(multihash);\n  const [code, sizeOffset] = varint.decode(bytes);\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset));\n  const digest = bytes.subarray(sizeOffset + digestOffset);\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length');\n  }\n  return new Digest(code, size, digest, bytes);\n};\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true;\n  } else {\n    return a.code === b.code && a.size === b.size && equalBytes(a.bytes, b.bytes);\n  }\n};\nexport class Digest {\n  constructor(code, size, digest, bytes) {\n    this.code = code;\n    this.size = size;\n    this.digest = digest;\n    this.bytes = bytes;\n  }\n}","import * as Digest from './digest.js';\nexport const from = ({name, code, encode}) => new Hasher(name, code, encode);\nexport class Hasher {\n  constructor(name, code, encode) {\n    this.name = name;\n    this.code = code;\n    this.encode = encode;\n  }\n  digest(input) {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input);\n      return result instanceof Uint8Array ? Digest.create(this.code, result) : result.then(digest => Digest.create(this.code, digest));\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n}","import { from } from './hasher.js';\nconst sha = name => async data => new Uint8Array(await crypto.subtle.digest(name, data));\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 18,\n  encode: sha('SHA-256')\n});\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 19,\n  encode: sha('SHA-512')\n});","import { coerce } from '../bytes.js';\nimport * as Digest from './digest.js';\nconst code = 0;\nconst name = 'identity';\nconst encode = coerce;\nconst digest = input => Digest.create(code, encode(input));\nexport const identity = {\n  code,\n  name,\n  encode,\n  digest\n};","const textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\nexport const name = 'json';\nexport const code = 512;\nexport const encode = node => textEncoder.encode(JSON.stringify(node));\nexport const decode = data => JSON.parse(textDecoder.decode(data));","import * as identityBase from './bases/identity.js';\nimport * as base2 from './bases/base2.js';\nimport * as base8 from './bases/base8.js';\nimport * as base10 from './bases/base10.js';\nimport * as base16 from './bases/base16.js';\nimport * as base32 from './bases/base32.js';\nimport * as base36 from './bases/base36.js';\nimport * as base58 from './bases/base58.js';\nimport * as base64 from './bases/base64.js';\nimport * as base256emoji from './bases/base256emoji.js';\nimport * as sha2 from './hashes/sha2.js';\nimport * as identity from './hashes/identity.js';\nimport * as raw from './codecs/raw.js';\nimport * as json from './codecs/json.js';\nimport {\n  CID,\n  hasher,\n  digest,\n  varint,\n  bytes\n} from './index.js';\nconst bases = {\n  ...identityBase,\n  ...base2,\n  ...base8,\n  ...base10,\n  ...base16,\n  ...base32,\n  ...base36,\n  ...base58,\n  ...base64,\n  ...base256emoji\n};\nconst hashes = {\n  ...sha2,\n  ...identity\n};\nconst codecs = {\n  raw,\n  json\n};\nexport {\n  CID,\n  hasher,\n  digest,\n  varint,\n  bytes,\n  hashes,\n  bases,\n  codecs\n};","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '../alloc.js';\nfunction createCodec(name, prefix, encode, decode) {\n  return {\n    name,\n    prefix,\n    encoder: {\n      name,\n      prefix,\n      encode\n    },\n    decoder: { decode }\n  };\n}\nconst string = createCodec('utf8', 'u', buf => {\n  const decoder = new TextDecoder('utf8');\n  return 'u' + decoder.decode(buf);\n}, str => {\n  const encoder = new TextEncoder();\n  return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', buf => {\n  let string = 'a';\n  for (let i = 0; i < buf.length; i++) {\n    string += String.fromCharCode(buf[i]);\n  }\n  return string;\n}, str => {\n  str = str.substring(1);\n  const buf = allocUnsafe(str.length);\n  for (let i = 0; i < str.length; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n});\nconst BASES = {\n  utf8: string,\n  'utf-8': string,\n  hex: bases.base16,\n  latin1: ascii,\n  ascii: ascii,\n  binary: ascii,\n  ...bases\n};\nexport default BASES;","import bases from './util/bases.js';\nexport function fromString(string, encoding = 'utf8') {\n  const base = bases[encoding];\n  if (!base) {\n    throw new Error(`Unsupported encoding \"${ encoding }\"`);\n  }\n  if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {\n    return globalThis.Buffer.from(string, 'utf8');\n  }\n  return base.decoder.decode(`${ base.prefix }${ string }`);\n}","import bases from './util/bases.js';\nexport function toString(array, encoding = 'utf8') {\n  const base = bases[encoding];\n  if (!base) {\n    throw new Error(`Unsupported encoding \"${ encoding }\"`);\n  }\n  if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {\n    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString('utf8');\n  }\n  return base.encoder.encode(array).substring(1);\n}","import { randomStringForEntropy } from \"@stablelib/random\";\nimport { hash } from \"@stablelib/sha256\";\nimport { fromString, toString } from \"uint8arrays\";\n\nexport const BASE10 = \"base10\";\nexport const BASE16 = \"base16\";\nexport const BASE64 = \"base64pad\";\nexport const UTF8 = \"utf8\";\n\n// Reference implementation:\n// https://github.com/spruceid/siwe/blob/38140330e54af91b1fab8ba1a8169e1fcbd8d271/packages/siwe/lib/utils.ts#L44\nexport function generateNonce(): string {\n  return randomStringForEntropy(96);\n}\n\nexport function hashMessage(message: string): string {\n  const result = hash(fromString(message, UTF8));\n  return toString(result, BASE16);\n}\n","import { PAIRING_EVENTS, RELAYER_EVENTS } from \"@walletconnect/core\";\nimport {\n  formatJsonRpcError,\n  formatJsonRpcRequest,\n  formatJsonRpcResult,\n  isJsonRpcError,\n  isJsonRpcRequest,\n  isJsonRpcResponse,\n  isJsonRpcResult,\n} from \"@walletconnect/jsonrpc-utils\";\nimport { PairingTypes, RelayerTypes, Verify } from \"@walletconnect/types\";\nimport { getInternalError, hashKey, isBrowser, TYPE_1 } from \"@walletconnect/utils\";\nimport { AUTH_CLIENT_PUBLIC_KEY_NAME, ENGINE_RPC_OPTS } from \"../constants\";\nimport { AuthClientTypes, AuthEngineTypes, IAuthEngine, JsonRpcTypes } from \"../types\";\nimport { getDidAddress, getDidChainId, getNamespacedDidChainId } from \"../utils/address\";\nimport { verifySignature } from \"../utils/signature\";\nimport { getPendingRequest, getPendingRequests } from \"../utils/store\";\nimport { isValidRequest, isValidRespond } from \"../utils/validators\";\nimport { hashMessage } from \"../utils/crypto\";\n\nexport class AuthEngine extends IAuthEngine {\n  private initialized = false;\n  public name = \"authEngine\";\n\n  constructor(client: IAuthEngine[\"client\"]) {\n    super(client);\n  }\n\n  public init: IAuthEngine[\"init\"] = () => {\n    if (!this.initialized) {\n      this.registerRelayerEvents();\n      this.registerPairingEvents();\n      this.client.core.pairing.register({ methods: Object.keys(ENGINE_RPC_OPTS) });\n      this.initialized = true;\n    }\n  };\n\n  // ---------- Public ------------------------------------------------ //\n\n  public request: IAuthEngine[\"request\"] = async (params, opts) => {\n    this.isInitialized();\n\n    if (!isValidRequest(params)) {\n      throw new Error(\"Invalid request\");\n    }\n\n    if (opts?.topic) {\n      return await this.requestOnKnownPairing(opts.topic, params);\n    }\n\n    // SPEC: A will construct an authentication request.\n    const { chainId, statement, aud, domain, nonce, type, exp, nbf } = params;\n\n    const { topic: pairingTopic, uri } = await this.client.core.pairing.create();\n\n    this.client.logger.info({\n      message: \"Generated new pairing\",\n      pairing: { topic: pairingTopic, uri },\n    });\n\n    const publicKey = await this.client.core.crypto.generateKeyPair();\n    const responseTopic = hashKey(publicKey);\n\n    await this.client.authKeys.set(AUTH_CLIENT_PUBLIC_KEY_NAME, { responseTopic, publicKey });\n    await this.client.pairingTopics.set(responseTopic, { topic: responseTopic, pairingTopic });\n\n    // Subscribe to auth_response topic\n    await this.client.core.relayer.subscribe(responseTopic);\n\n    this.client.logger.info(`sending request to new pairing topic: ${pairingTopic}`);\n\n    // SPEC: A encrypts reuqest with symKey S\n    // SPEC: A publishes encrypted request to topic\n    const id = await this.sendRequest(\n      pairingTopic,\n      \"wc_authRequest\",\n      {\n        payloadParams: {\n          type: type ?? \"eip4361\",\n          chainId,\n          statement,\n          aud,\n          domain,\n          version: \"1\",\n          nonce,\n          iat: new Date().toISOString(),\n          exp,\n          nbf,\n        },\n        requester: { publicKey, metadata: this.client.metadata },\n      },\n      {},\n      params.expiry,\n    );\n\n    this.client.logger.info(`sent request to new pairing topic: ${pairingTopic}`);\n\n    return { uri, id };\n  };\n\n  public respond: IAuthEngine[\"respond\"] = async (respondParams, iss) => {\n    this.isInitialized();\n\n    if (!isValidRespond(respondParams, this.client.requests)) {\n      throw new Error(\"Invalid response\");\n    }\n\n    const pendingRequest = getPendingRequest(this.client.requests, respondParams.id);\n    if (!pendingRequest) {\n      throw new Error(`Could not find pending auth request with id ${respondParams.id}`);\n    }\n\n    const receiverPublicKey = pendingRequest.requester.publicKey;\n    const senderPublicKey = await this.client.core.crypto.generateKeyPair();\n    const responseTopic = hashKey(receiverPublicKey);\n    const encodeOpts = {\n      type: TYPE_1,\n      receiverPublicKey,\n      senderPublicKey,\n    };\n\n    if (\"error\" in respondParams) {\n      await this.sendError(pendingRequest.id, responseTopic, respondParams, encodeOpts);\n      return;\n    }\n\n    const cacao: AuthEngineTypes.Cacao = {\n      h: {\n        t: \"eip4361\",\n      },\n      p: {\n        ...pendingRequest.cacaoPayload,\n        iss,\n      },\n      s: respondParams.signature,\n    };\n\n    await this.sendResult<\"wc_authRequest\">(pendingRequest.id, responseTopic, cacao, encodeOpts);\n    await this.client.core.pairing.activate({ topic: pendingRequest.pairingTopic });\n    await this.client.requests.update(pendingRequest.id, { ...cacao });\n  };\n\n  public getPendingRequests: IAuthEngine[\"getPendingRequests\"] = () => {\n    const pendingRequests = getPendingRequests(this.client.requests);\n    return pendingRequests;\n  };\n\n  public formatMessage = (cacao: AuthEngineTypes.CacaoPayload, iss: string) => {\n    this.client.logger.debug(`formatMessage, cacao is: ${JSON.stringify(cacao)}`);\n\n    const header = `${cacao.domain} wants you to sign in with your Ethereum account:`;\n    const walletAddress = getDidAddress(iss);\n    const statement = cacao.statement;\n    const uri = `URI: ${cacao.aud}`;\n    const version = `Version: ${cacao.version}`;\n    const chainId = `Chain ID: ${getDidChainId(iss)}`;\n    const nonce = `Nonce: ${cacao.nonce}`;\n    const issuedAt = `Issued At: ${cacao.iat}`;\n    const expiry = cacao.exp ? `Expiry: ${cacao.exp}` : undefined;\n    const resources =\n      cacao.resources && cacao.resources.length > 0\n        ? `Resources:\\n${cacao.resources.map((resource) => `- ${resource}`).join(\"\\n\")}`\n        : undefined;\n\n    const message = [\n      header,\n      walletAddress,\n      ``,\n      statement,\n      ``,\n      uri,\n      version,\n      chainId,\n      nonce,\n      issuedAt,\n      expiry,\n      resources,\n    ]\n      .filter((val) => val !== undefined && val !== null) // remove unnecessary empty lines\n      .join(\"\\n\");\n\n    return message;\n  };\n\n  // ---------- Protected/Private Helpers --------------------------------------- //\n\n  protected setExpiry: IAuthEngine[\"setExpiry\"] = async (topic, expiry) => {\n    if (this.client.core.pairing.pairings.keys.includes(topic)) {\n      await this.client.core.pairing.updateExpiry({ topic, expiry });\n    }\n    this.client.core.expirer.set(topic, expiry);\n  };\n\n  protected sendRequest: IAuthEngine[\"sendRequest\"] = async (\n    topic,\n    method,\n    params,\n    encodeOpts,\n    expiry,\n  ) => {\n    const payload = formatJsonRpcRequest(method, params);\n    const message = await this.client.core.crypto.encode(topic, payload, encodeOpts);\n    const rpcOpts = ENGINE_RPC_OPTS[method].req;\n    if (expiry) rpcOpts.ttl = expiry;\n    this.client.core.history.set(topic, payload);\n    if (isBrowser()) {\n      const hash = hashMessage(JSON.stringify(payload));\n      this.client.core.verify.register({ attestationId: hash });\n    }\n    await this.client.core.relayer.publish(topic, message, {\n      ...rpcOpts,\n      internal: {\n        throwOnFailedPublish: true,\n      },\n    });\n    return payload.id;\n  };\n\n  protected sendResult: IAuthEngine[\"sendResult\"] = async (id, topic, result, encodeOpts) => {\n    const payload = formatJsonRpcResult(id, result);\n    const message = await this.client.core.crypto.encode(topic, payload, encodeOpts);\n    const record = await this.client.core.history.get(topic, id);\n    const rpcOpts = ENGINE_RPC_OPTS[record.request.method].res;\n\n    await this.client.core.relayer.publish(topic, message, {\n      ...rpcOpts,\n      internal: {\n        throwOnFailedPublish: true,\n      },\n    });\n    await this.client.core.history.resolve(payload);\n    return payload.id;\n  };\n\n  protected sendError: IAuthEngine[\"sendError\"] = async (id, topic, params, encodeOpts) => {\n    const payload = formatJsonRpcError(id, params.error);\n    const message = await this.client.core.crypto.encode(topic, payload, encodeOpts);\n    const record = await this.client.core.history.get(topic, id);\n    const rpcOpts = ENGINE_RPC_OPTS[record.request.method].res;\n\n    await this.client.core.relayer.publish(topic, message, rpcOpts);\n    await this.client.core.history.resolve(payload);\n\n    return payload.id;\n  };\n\n  private requestOnKnownPairing = async (topic: string, params: AuthEngineTypes.RequestParams) => {\n    const knownPairing = this.client.core.pairing.pairings\n      .getAll({ active: true })\n      .find((pairing) => pairing.topic === topic);\n\n    if (!knownPairing) throw new Error(`Could not find pairing for provided topic ${topic}`);\n\n    const { publicKey } = this.client.authKeys.get(AUTH_CLIENT_PUBLIC_KEY_NAME);\n    const { chainId, statement, aud, domain, nonce, type } = params;\n\n    // Send request to existing pairing\n    const id = await this.sendRequest(\n      knownPairing.topic,\n      \"wc_authRequest\",\n      {\n        payloadParams: {\n          type: type ?? \"eip4361\",\n          chainId,\n          statement,\n          aud,\n          domain,\n          version: \"1\",\n          nonce,\n          iat: new Date().toISOString(),\n        },\n        requester: { publicKey, metadata: this.client.metadata },\n      },\n      {},\n      params.expiry,\n    );\n\n    this.client.logger.info(`sent request to known pairing topic: ${knownPairing.topic}`);\n    return { id };\n  };\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n\n  // ---------- Relay Events Router ----------------------------------- //\n\n  private registerRelayerEvents() {\n    this.client.core.relayer.on(\n      RELAYER_EVENTS.message,\n      async (event: RelayerTypes.MessageEvent) => {\n        const { topic, message } = event;\n\n        // Retrieve the public key (if defined) to decrypt possible `auth_request` response\n        const { responseTopic, publicKey } = this.client.authKeys.keys.includes(\n          AUTH_CLIENT_PUBLIC_KEY_NAME,\n        )\n          ? this.client.authKeys.get(AUTH_CLIENT_PUBLIC_KEY_NAME)\n          : { responseTopic: undefined, publicKey: undefined };\n\n        // If there's an expected responseTopic/publicKey, we only proceed if this message's topic matches,\n        // otherwise we're attempting to decrypt another client's TYPE_1 envelope with the wrong publicKey.\n        if (responseTopic && topic !== responseTopic) {\n          this.client.logger.debug(\"[Auth] Ignoring message from unknown topic\", topic);\n          return;\n        }\n\n        const payload = await this.client.core.crypto.decode(topic, message, {\n          receiverPublicKey: publicKey,\n        });\n        if (isJsonRpcRequest(payload)) {\n          this.client.core.history.set(topic, payload);\n          this.onRelayEventRequest({ topic, payload });\n        } else if (isJsonRpcResponse(payload)) {\n          await this.client.core.history.resolve(payload);\n          this.onRelayEventResponse({ topic, payload });\n        }\n      },\n    );\n  }\n\n  // ---------- Pairing Events Router --------------------------------- //\n  private registerPairingEvents() {\n    this.client.core.pairing.events.on(PAIRING_EVENTS.create, (pairing: PairingTypes.Struct) =>\n      this.onPairingCreated(pairing),\n    );\n  }\n\n  private onPairingCreated = (pairing: PairingTypes.Struct) => {\n    const pendingRequests = this.getPendingRequests();\n    if (pendingRequests) {\n      const request = Object.values(pendingRequests).find(\n        (request) => request.pairingTopic === pairing.topic,\n      );\n      if (request) this.handleAuthRequest(request);\n    }\n  };\n\n  protected onRelayEventRequest: IAuthEngine[\"onRelayEventRequest\"] = (event) => {\n    const { topic, payload } = event;\n    const reqMethod = payload.method as JsonRpcTypes.WcMethod;\n\n    switch (reqMethod) {\n      case \"wc_authRequest\":\n        return this.onAuthRequest(topic, payload);\n      default:\n        return this.client.logger.info(`Unsupported request method ${reqMethod}`);\n    }\n  };\n\n  protected onRelayEventResponse: IAuthEngine[\"onRelayEventResponse\"] = async (event) => {\n    const { topic, payload } = event;\n    const record = await this.client.core.history.get(topic, payload.id);\n    const resMethod = record.request.method as JsonRpcTypes.WcMethod;\n\n    switch (resMethod) {\n      case \"wc_authRequest\":\n        return this.onAuthResponse(topic, payload);\n      default:\n        return this.client.logger.info(`Unsupported response method ${resMethod}`);\n    }\n  };\n  // ---------- Relay Event Handlers --------------------------------- //\n\n  protected onAuthRequest: IAuthEngine[\"onAuthRequest\"] = async (topic, payload) => {\n    const { requester, payloadParams } = payload.params;\n    this.client.logger.info({ type: \"onAuthRequest\", topic, payload });\n    const hash = hashMessage(JSON.stringify(payload));\n    const verifyContext = await this.getVerifyContext(hash, this.client.metadata);\n    const pendingRequest = {\n      requester,\n      pairingTopic: topic,\n      id: payload.id,\n      cacaoPayload: payloadParams,\n      verifyContext,\n    };\n    await this.client.requests.set(payload.id, pendingRequest);\n    this.handleAuthRequest(pendingRequest);\n  };\n\n  private handleAuthRequest = async (request: AuthEngineTypes.PendingRequest) => {\n    const { id, pairingTopic, requester, cacaoPayload, verifyContext } = request;\n    try {\n      this.client.emit(\"auth_request\", {\n        id,\n        topic: pairingTopic,\n        params: {\n          requester,\n          cacaoPayload,\n        },\n        verifyContext,\n      });\n    } catch (err: any) {\n      await this.sendError(request.id, request.pairingTopic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  protected onAuthResponse: IAuthEngine[\"onAuthResponse\"] = async (topic, response) => {\n    const { id } = response;\n    this.client.logger.info({ type: \"onAuthResponse\", topic, response });\n\n    if (isJsonRpcResult(response)) {\n      const { pairingTopic } = this.client.pairingTopics.get(topic);\n      await this.client.core.pairing.activate({ topic: pairingTopic });\n\n      const { s: signature, p: payload } = response.result;\n      await this.client.requests.set(id, { id, pairingTopic, ...response.result });\n      const reconstructed = this.formatMessage(payload, payload.iss);\n      this.client.logger.debug(\"reconstructed message:\\n\", JSON.stringify(reconstructed));\n      this.client.logger.debug(\"payload.iss:\", payload.iss);\n      this.client.logger.debug(\"signature:\", signature);\n\n      const walletAddress = getDidAddress(payload.iss);\n      const chainId = getNamespacedDidChainId(payload.iss);\n\n      if (!walletAddress) {\n        throw new Error(\"Could not derive address from `payload.iss`\");\n      }\n      if (!chainId) {\n        throw new Error(\"Could not derive chainId from `payload.iss`\");\n      }\n      this.client.logger.debug(\"walletAddress extracted from `payload.iss`:\", walletAddress);\n\n      const isValid = await verifySignature(\n        walletAddress,\n        reconstructed,\n        signature,\n        chainId,\n        this.client.projectId,\n      );\n\n      if (!isValid) {\n        this.client.emit(\"auth_response\", {\n          id,\n          topic,\n          params: { message: \"Invalid signature\", code: -1 },\n        });\n      } else {\n        this.client.emit(\"auth_response\", { id, topic, params: response });\n      }\n    } else if (isJsonRpcError(response)) {\n      this.client.emit(\"auth_response\", { id, topic, params: response });\n    }\n  };\n\n  private getVerifyContext = async (hash: string, metadata: AuthClientTypes.Metadata) => {\n    const context: Verify.Context = {\n      verified: {\n        verifyUrl: metadata.verifyUrl || \"\",\n        validation: \"UNKNOWN\",\n        origin: metadata.url || \"\",\n      },\n    };\n\n    try {\n      const result = await this.client.core.verify.resolve({\n        attestationId: hash,\n        verifyUrl: metadata.verifyUrl,\n      });\n      if (result) {\n        context.verified.origin = result.origin;\n        context.verified.isScam = result.isScam;\n        context.verified.validation = origin === new URL(metadata.url).origin ? \"VALID\" : \"INVALID\";\n      }\n    } catch (e) {\n      this.client.logger.error(e);\n    }\n\n    this.client.logger.info(`Verify context: ${JSON.stringify(context)}`);\n    return context;\n  };\n}\n","import { Core, Store } from \"@walletconnect/core\";\nimport {\n  generateChildLogger,\n  getDefaultLoggerOptions,\n  getLoggerContext,\n  pino,\n} from \"@walletconnect/logger\";\nimport { EventEmitter } from \"events\";\n\nimport { AuthClientTypes, AuthEngineTypes, IAuthClient } from \"./types\";\nimport { AuthEngine } from \"./controllers\";\nimport {\n  AUTH_CLIENT_PROTOCOL,\n  AUTH_CLIENT_STORAGE_PREFIX,\n  AUTH_CLIENT_VERSION,\n  AUTH_CLIENT_DEFAULT_NAME,\n  AUTH_CLIENT_PUBLIC_KEY_NAME,\n} from \"./constants\";\n\nexport class AuthClient extends IAuthClient {\n  public readonly protocol = AUTH_CLIENT_PROTOCOL;\n  public readonly version = AUTH_CLIENT_VERSION;\n\n  public name: IAuthClient[\"name\"] = AUTH_CLIENT_DEFAULT_NAME;\n  public core: IAuthClient[\"core\"];\n  public metadata: IAuthClient[\"metadata\"];\n  public projectId: IAuthClient[\"projectId\"];\n  public logger: IAuthClient[\"logger\"];\n  public events: IAuthClient[\"events\"] = new EventEmitter();\n  public engine: IAuthClient[\"engine\"];\n  public authKeys: IAuthClient[\"authKeys\"];\n  public pairingTopics: IAuthClient[\"pairingTopics\"];\n  public requests: IAuthClient[\"requests\"];\n\n  static async init(opts: AuthClientTypes.Options) {\n    const client = new AuthClient(opts);\n    await client.initialize();\n\n    return client;\n  }\n\n  constructor(opts: AuthClientTypes.Options) {\n    super(opts);\n\n    const logger =\n      typeof opts.logger !== \"undefined\" && typeof opts.logger !== \"string\"\n        ? opts.logger\n        : pino(\n            getDefaultLoggerOptions({\n              level: opts.logger || \"error\",\n            }),\n          );\n\n    this.name = opts?.name || AUTH_CLIENT_DEFAULT_NAME;\n    this.metadata = opts.metadata;\n    this.projectId = opts.projectId;\n    this.core = opts.core || new Core(opts);\n    this.logger = generateChildLogger(logger, this.name);\n    this.authKeys = new Store(\n      this.core,\n      this.logger,\n      \"authKeys\",\n      AUTH_CLIENT_STORAGE_PREFIX,\n      () => AUTH_CLIENT_PUBLIC_KEY_NAME,\n    );\n    this.pairingTopics = new Store(\n      this.core,\n      this.logger,\n      \"pairingTopics\",\n      AUTH_CLIENT_STORAGE_PREFIX,\n    );\n    this.requests = new Store(\n      this.core,\n      this.logger,\n      \"requests\",\n      AUTH_CLIENT_STORAGE_PREFIX,\n      (val: AuthEngineTypes.PendingRequest) => val.id,\n    );\n    this.engine = new AuthEngine(this);\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  // ---------- Events ----------------------------------------------- //\n\n  public emit: IAuthClient[\"emit\"] = (name, listener) => {\n    return this.events.emit(name, listener);\n  };\n\n  public on: IAuthClient[\"on\"] = (name, listener) => {\n    return this.events.on(name, listener);\n  };\n\n  public once: IAuthClient[\"once\"] = (name, listener) => {\n    return this.events.once(name, listener);\n  };\n\n  public off: IAuthClient[\"off\"] = (name, listener) => {\n    return this.events.off(name, listener);\n  };\n\n  public removeListener: IAuthClient[\"removeListener\"] = (name, listener) => {\n    return this.events.removeListener(name, listener);\n  };\n\n  // ---------- Engine ----------------------------------------------- //\n\n  // request wallet authentication\n  public request: IAuthClient[\"request\"] = async (params, opts) => {\n    try {\n      return await this.engine.request(params, opts);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  // respond wallet authentication\n  public respond: IAuthClient[\"respond\"] = async (params, iss) => {\n    try {\n      return await this.engine.respond(params, iss);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public getPendingRequests: IAuthClient[\"getPendingRequests\"] = () => {\n    try {\n      return this.engine.getPendingRequests();\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public formatMessage: IAuthClient[\"formatMessage\"] = (payload, iss) => {\n    try {\n      return this.engine.formatMessage(payload, iss);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async initialize() {\n    this.logger.trace(`Initialized`);\n    try {\n      await this.core.start();\n      await this.authKeys.init();\n      await this.requests.init();\n      await this.pairingTopics.init();\n      await this.engine.init();\n      this.logger.info(`AuthClient Initialization Success`);\n      this.logger.info({ authClient: this });\n    } catch (error: any) {\n      this.logger.info(`AuthClient Initialization Failure`);\n      this.logger.error(error.message);\n      throw error;\n    }\n  }\n}\n","import { AuthClient as Client } from \"./client\";\n\nexport * from \"./constants\";\nexport * from \"./types\";\nexport * from \"./utils/crypto\";\n\nexport const AuthClient = Client;\nexport default Client;\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}