{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ACESFilmicToneMapping, EventDispatcher, sRGBEncoding, Vector2, WebGLRenderer } from 'three';\nimport { $updateEnvironment } from '../features/environment.js';\nimport { $canvas, $tick, $updateSize } from '../model-viewer-base.js';\nimport { clamp, isDebugMode, resolveDpr } from '../utilities.js';\nimport { ARRenderer } from './ARRenderer.js';\nimport { CachingGLTFLoader } from './CachingGLTFLoader.js';\nimport { Debugger } from './Debugger.js';\nimport { ModelViewerGLTFInstance } from './gltf-instance/ModelViewerGLTFInstance.js';\nimport TextureUtils from './TextureUtils.js';\n// Between 0 and 1: larger means the average responds faster and is less smooth.\nconst DURATION_DECAY = 0.2;\nconst LOW_FRAME_DURATION_MS = 40;\nconst HIGH_FRAME_DURATION_MS = 60;\nconst MAX_AVG_CHANGE_MS = 5;\nconst SCALE_STEPS = [1, 0.79, 0.62, 0.5, 0.4, 0.31, 0.25];\nconst DEFAULT_LAST_STEP = 3;\nexport const DEFAULT_POWER_PREFERENCE = 'high-performance';\n/**\n * Registers canvases with Canvas2DRenderingContexts and renders them\n * all in the same WebGLRenderingContext, spitting out textures to apply\n * to the canvases. Creates a fullscreen WebGL canvas that is not added\n * to the DOM, and on each frame, renders each registered canvas on a portion\n * of the WebGL canvas, and applies the texture on the registered canvas.\n *\n * In the future, can use ImageBitmapRenderingContext instead of\n * Canvas2DRenderingContext if supported for cheaper transferring of\n * the texture.\n */\nexport class Renderer extends EventDispatcher {\n  constructor(options) {\n    super();\n    this.loader = new CachingGLTFLoader(ModelViewerGLTFInstance);\n    this.width = 0;\n    this.height = 0;\n    this.dpr = 1;\n    this.debugger = null;\n    this.scenes = new Set();\n    this.multipleScenesVisible = false;\n    this.lastTick = performance.now();\n    this.renderedLastFrame = false;\n    this.scaleStep = 0;\n    this.lastStep = DEFAULT_LAST_STEP;\n    this.avgFrameDuration = (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;\n    this.onWebGLContextLost = event => {\n      this.dispatchEvent({\n        type: 'contextlost',\n        sourceEvent: event\n      });\n    };\n    this.onWebGLContextRestored = () => {\n      var _a;\n      (_a = this.textureUtils) === null || _a === void 0 ? void 0 : _a.dispose();\n      this.textureUtils = new TextureUtils(this.threeRenderer);\n      for (const scene of this.scenes) {\n        scene.element[$updateEnvironment]();\n      }\n    };\n    this.dpr = resolveDpr();\n    this.canvas3D = document.createElement('canvas');\n    this.canvas3D.id = 'webgl-canvas';\n    this.canvas3D.classList.add('show');\n    try {\n      this.threeRenderer = new WebGLRenderer({\n        canvas: this.canvas3D,\n        alpha: true,\n        antialias: true,\n        powerPreference: options.powerPreference,\n        preserveDrawingBuffer: true\n      });\n      this.threeRenderer.autoClear = true;\n      this.threeRenderer.outputEncoding = sRGBEncoding;\n      this.threeRenderer.physicallyCorrectLights = true;\n      this.threeRenderer.setPixelRatio(1); // handle pixel ratio externally\n      this.debugger = !!options.debug ? new Debugger(this) : null;\n      this.threeRenderer.debug = {\n        checkShaderErrors: !!this.debugger\n      };\n      // ACESFilmicToneMapping appears to be the most \"saturated\",\n      // and similar to Filament's gltf-viewer.\n      this.threeRenderer.toneMapping = ACESFilmicToneMapping;\n    } catch (error) {\n      console.warn(error);\n    }\n    this.arRenderer = new ARRenderer(this);\n    this.textureUtils = this.canRender ? new TextureUtils(this.threeRenderer) : null;\n    CachingGLTFLoader.initializeKTX2Loader(this.threeRenderer);\n    this.canvas3D.addEventListener('webglcontextlost', this.onWebGLContextLost);\n    this.canvas3D.addEventListener('webglcontextrestored', this.onWebGLContextRestored);\n    this.updateRendererSize();\n  }\n  static get singleton() {\n    return this._singleton;\n  }\n  static resetSingleton() {\n    const elements = this._singleton.dispose();\n    for (const element of elements) {\n      element.disconnectedCallback();\n    }\n    this._singleton = new Renderer({\n      powerPreference: (self.ModelViewerElement || {}).powerPreference || DEFAULT_POWER_PREFERENCE,\n      debug: isDebugMode()\n    });\n    for (const element of elements) {\n      element.connectedCallback();\n    }\n  }\n  get canRender() {\n    return this.threeRenderer != null;\n  }\n  get scaleFactor() {\n    return SCALE_STEPS[this.scaleStep];\n  }\n  set minScale(scale) {\n    let i = 1;\n    while (i < SCALE_STEPS.length) {\n      if (SCALE_STEPS[i] < scale) {\n        break;\n      }\n      ++i;\n    }\n    this.lastStep = i - 1;\n  }\n  registerScene(scene) {\n    this.scenes.add(scene);\n    scene.forceRescale();\n    const size = new Vector2();\n    this.threeRenderer.getSize(size);\n    scene.canvas.width = size.x;\n    scene.canvas.height = size.y;\n    if (this.canRender && this.scenes.size > 0) {\n      this.threeRenderer.setAnimationLoop((time, frame) => this.render(time, frame));\n    }\n    if (this.debugger != null) {\n      this.debugger.addScene(scene);\n    }\n  }\n  unregisterScene(scene) {\n    this.scenes.delete(scene);\n    if (this.canvas3D.parentElement === scene.canvas.parentElement) {\n      scene.canvas.parentElement.removeChild(this.canvas3D);\n    }\n    if (this.canRender && this.scenes.size === 0) {\n      this.threeRenderer.setAnimationLoop(null);\n    }\n    if (this.debugger != null) {\n      this.debugger.removeScene(scene);\n    }\n  }\n  displayCanvas(scene) {\n    return this.multipleScenesVisible ? scene.element[$canvas] : this.canvas3D;\n  }\n  /**\n   * The function enables an optimization, where when there is only a single\n   * <model-viewer> element, we can use the renderer's 3D canvas directly for\n   * display. Otherwise we need to use the element's 2D canvas and copy the\n   * renderer's result into it.\n   */\n  countVisibleScenes() {\n    const {\n      canvas3D\n    } = this;\n    let visibleScenes = 0;\n    let canvas3DScene = null;\n    for (const scene of this.scenes) {\n      const {\n        element\n      } = scene;\n      if (element.modelIsVisible && scene.externalRenderer == null) {\n        ++visibleScenes;\n      }\n      if (canvas3D.parentElement === scene.canvas.parentElement) {\n        canvas3DScene = scene;\n      }\n    }\n    const multipleScenesVisible = visibleScenes > 1;\n    if (canvas3DScene != null) {\n      const newlyMultiple = multipleScenesVisible && !this.multipleScenesVisible;\n      const disappearing = !canvas3DScene.element.modelIsVisible;\n      if (newlyMultiple || disappearing) {\n        const {\n          width,\n          height\n        } = this.sceneSize(canvas3DScene);\n        this.copyPixels(canvas3DScene, width, height);\n        canvas3D.parentElement.removeChild(canvas3D);\n      }\n    }\n    this.multipleScenesVisible = multipleScenesVisible;\n  }\n  /**\n   * Updates the renderer's size based on the largest scene and any changes to\n   * device pixel ratio.\n   */\n  updateRendererSize() {\n    const dpr = resolveDpr();\n    if (dpr !== this.dpr) {\n      // If the device pixel ratio has changed due to page zoom, elements\n      // specified by % width do not fire a resize event even though their CSS\n      // pixel dimensions change, so we force them to update their size here.\n      for (const scene of this.scenes) {\n        const {\n          element\n        } = scene;\n        element[$updateSize](element.getBoundingClientRect());\n      }\n    }\n    // Make the renderer the size of the largest scene\n    let width = 0;\n    let height = 0;\n    for (const scene of this.scenes) {\n      width = Math.max(width, scene.width);\n      height = Math.max(height, scene.height);\n    }\n    if (width === this.width && height === this.height && dpr === this.dpr) {\n      return;\n    }\n    this.width = width;\n    this.height = height;\n    this.dpr = dpr;\n    width = Math.ceil(width * dpr);\n    height = Math.ceil(height * dpr);\n    if (this.canRender) {\n      this.threeRenderer.setSize(width, height, false);\n    }\n    // Each scene's canvas must match the renderer size. In general they can be\n    // larger than the element that contains them, but the overflow is hidden\n    // and only the portion that is shown is copied over.\n    for (const scene of this.scenes) {\n      const {\n        canvas\n      } = scene;\n      canvas.width = width;\n      canvas.height = height;\n      scene.forceRescale();\n    }\n  }\n  updateRendererScale(delta) {\n    const scaleStep = this.scaleStep;\n    this.avgFrameDuration += clamp(DURATION_DECAY * (delta - this.avgFrameDuration), -MAX_AVG_CHANGE_MS, MAX_AVG_CHANGE_MS);\n    if (this.avgFrameDuration > HIGH_FRAME_DURATION_MS) {\n      ++this.scaleStep;\n    } else if (this.avgFrameDuration < LOW_FRAME_DURATION_MS && this.scaleStep > 0) {\n      --this.scaleStep;\n    }\n    this.scaleStep = Math.min(this.scaleStep, this.lastStep);\n    if (scaleStep !== this.scaleStep) {\n      this.avgFrameDuration = (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;\n    }\n  }\n  shouldRender(scene) {\n    if (!scene.shouldRender()) {\n      // The first frame we stop rendering the scene (because it stops moving),\n      // trigger one extra render at full scale.\n      if (scene.scaleStep != 0) {\n        scene.scaleStep = 0;\n        this.rescaleCanvas(scene);\n      } else {\n        return false;\n      }\n    } else if (scene.scaleStep != this.scaleStep) {\n      // Update render scale\n      scene.scaleStep = this.scaleStep;\n      this.rescaleCanvas(scene);\n    }\n    return true;\n  }\n  rescaleCanvas(scene) {\n    const scale = SCALE_STEPS[scene.scaleStep];\n    const width = Math.ceil(this.width / scale);\n    const height = Math.ceil(this.height / scale);\n    const {\n      style\n    } = scene.canvas;\n    style.width = `${width}px`;\n    style.height = `${height}px`;\n    this.canvas3D.style.width = `${width}px`;\n    this.canvas3D.style.height = `${height}px`;\n    const renderedDpr = this.dpr * scale;\n    const reason = scale < 1 ? 'GPU throttling' : this.dpr !== window.devicePixelRatio ? 'No meta viewport tag' : '';\n    scene.element.dispatchEvent(new CustomEvent('render-scale', {\n      detail: {\n        reportedDpr: window.devicePixelRatio,\n        renderedDpr: renderedDpr,\n        minimumDpr: this.dpr * SCALE_STEPS[this.lastStep],\n        pixelWidth: Math.ceil(scene.width * renderedDpr),\n        pixelHeight: Math.ceil(scene.height * renderedDpr),\n        reason: reason\n      }\n    }));\n  }\n  sceneSize(scene) {\n    const {\n      dpr\n    } = this;\n    const scaleFactor = SCALE_STEPS[scene.scaleStep];\n    // We avoid using the Three.js PixelRatio and handle it ourselves here so\n    // that we can do proper rounding and avoid white boundary pixels.\n    const width = Math.min(Math.ceil(scene.width * scaleFactor * dpr), this.canvas3D.width);\n    const height = Math.min(Math.ceil(scene.height * scaleFactor * dpr), this.canvas3D.height);\n    return {\n      width,\n      height\n    };\n  }\n  copyPixels(scene, width, height) {\n    const context2D = scene.context;\n    if (context2D == null) {\n      console.log('could not acquire 2d context');\n      return;\n    }\n    context2D.clearRect(0, 0, width, height);\n    context2D.drawImage(this.canvas3D, 0, 0, width, height, 0, 0, width, height);\n    scene.canvas.classList.add('show');\n  }\n  /**\n   * Returns an array version of this.scenes where the non-visible ones are\n   * first. This allows eager scenes to be rendered before they are visible,\n   * without needing the multi-canvas render path.\n   */\n  orderedScenes() {\n    const scenes = [];\n    for (const visible of [false, true]) {\n      for (const scene of this.scenes) {\n        if (scene.element.modelIsVisible === visible) {\n          scenes.push(scene);\n        }\n      }\n    }\n    return scenes;\n  }\n  get isPresenting() {\n    return this.arRenderer.isPresenting;\n  }\n  /**\n   * This method takes care of updating the element and renderer state based on\n   * the time that has passed since the last rendered frame.\n   */\n  preRender(scene, t, delta) {\n    const {\n      element,\n      exposure\n    } = scene;\n    element[$tick](t, delta);\n    const exposureIsNumber = typeof exposure === 'number' && !Number.isNaN(exposure);\n    this.threeRenderer.toneMappingExposure = exposureIsNumber ? exposure : 1.0;\n  }\n  render(t, frame) {\n    if (frame != null) {\n      this.arRenderer.onWebXRFrame(t, frame);\n      return;\n    }\n    const delta = t - this.lastTick;\n    this.lastTick = t;\n    if (!this.canRender || this.isPresenting) {\n      return;\n    }\n    this.countVisibleScenes();\n    this.updateRendererSize();\n    if (this.renderedLastFrame) {\n      this.updateRendererScale(delta);\n      this.renderedLastFrame = false;\n    }\n    const {\n      canvas3D\n    } = this;\n    for (const scene of this.orderedScenes()) {\n      const {\n        element\n      } = scene;\n      if (!element.loaded || !element.modelIsVisible && scene.renderCount > 0) {\n        continue;\n      }\n      this.preRender(scene, t, delta);\n      if (!this.shouldRender(scene)) {\n        continue;\n      }\n      if (scene.externalRenderer != null) {\n        const camera = scene.getCamera();\n        camera.updateMatrix();\n        const {\n          matrix,\n          projectionMatrix\n        } = camera;\n        const viewMatrix = matrix.elements.slice();\n        const target = scene.getTarget();\n        viewMatrix[12] += target.x;\n        viewMatrix[13] += target.y;\n        viewMatrix[14] += target.z;\n        scene.externalRenderer.render({\n          viewMatrix: viewMatrix,\n          projectionMatrix: projectionMatrix.elements\n        });\n        continue;\n      }\n      if (!element.modelIsVisible && !this.multipleScenesVisible) {\n        // Here we are pre-rendering on the visible canvas, so we must mark the\n        // visible scene dirty to ensure it overwrites us.\n        for (const visibleScene of this.scenes) {\n          if (visibleScene.element.modelIsVisible) {\n            visibleScene.queueRender();\n          }\n        }\n      }\n      const {\n        width,\n        height\n      } = this.sceneSize(scene);\n      scene.renderShadow(this.threeRenderer);\n      // Need to set the render target in order to prevent\n      // clearing the depth from a different buffer\n      this.threeRenderer.setRenderTarget(null);\n      this.threeRenderer.setViewport(0, Math.ceil(this.height * this.dpr) - height, width, height);\n      this.threeRenderer.render(scene, scene.camera);\n      if (this.multipleScenesVisible || scene.renderCount === 0) {\n        this.copyPixels(scene, width, height);\n      } else {\n        if (canvas3D.parentElement !== scene.canvas.parentElement) {\n          scene.canvas.parentElement.appendChild(canvas3D);\n          scene.canvas.classList.remove('show');\n        }\n      }\n      scene.hasRendered();\n      ++scene.renderCount;\n      this.renderedLastFrame = true;\n    }\n  }\n  dispose() {\n    if (this.textureUtils != null) {\n      this.textureUtils.dispose();\n    }\n    if (this.threeRenderer != null) {\n      this.threeRenderer.dispose();\n    }\n    this.textureUtils = null;\n    this.threeRenderer = null;\n    const elements = [];\n    for (const scene of this.scenes) {\n      elements.push(scene.element);\n    }\n    this.canvas3D.removeEventListener('webglcontextlost', this.onWebGLContextLost);\n    this.canvas3D.removeEventListener('webglcontextrestored', this.onWebGLContextRestored);\n    return elements;\n  }\n}\nRenderer._singleton = new Renderer({\n  powerPreference: (self.ModelViewerElement || {}).powerPreference || DEFAULT_POWER_PREFERENCE,\n  debug: isDebugMode()\n});","map":{"version":3,"names":["ACESFilmicToneMapping","EventDispatcher","sRGBEncoding","Vector2","WebGLRenderer","$updateEnvironment","$canvas","$tick","$updateSize","clamp","isDebugMode","resolveDpr","ARRenderer","CachingGLTFLoader","Debugger","ModelViewerGLTFInstance","TextureUtils","DURATION_DECAY","LOW_FRAME_DURATION_MS","HIGH_FRAME_DURATION_MS","MAX_AVG_CHANGE_MS","SCALE_STEPS","DEFAULT_LAST_STEP","DEFAULT_POWER_PREFERENCE","Renderer","constructor","options","loader","width","height","dpr","debugger","scenes","Set","multipleScenesVisible","lastTick","performance","now","renderedLastFrame","scaleStep","lastStep","avgFrameDuration","onWebGLContextLost","event","dispatchEvent","type","sourceEvent","onWebGLContextRestored","_a","textureUtils","dispose","threeRenderer","scene","element","canvas3D","document","createElement","id","classList","add","canvas","alpha","antialias","powerPreference","preserveDrawingBuffer","autoClear","outputEncoding","physicallyCorrectLights","setPixelRatio","debug","checkShaderErrors","toneMapping","error","console","warn","arRenderer","canRender","initializeKTX2Loader","addEventListener","updateRendererSize","singleton","_singleton","resetSingleton","elements","disconnectedCallback","self","ModelViewerElement","connectedCallback","scaleFactor","minScale","scale","i","length","registerScene","forceRescale","size","getSize","x","y","setAnimationLoop","time","frame","render","addScene","unregisterScene","delete","parentElement","removeChild","removeScene","displayCanvas","countVisibleScenes","visibleScenes","canvas3DScene","modelIsVisible","externalRenderer","newlyMultiple","disappearing","sceneSize","copyPixels","getBoundingClientRect","Math","max","ceil","setSize","updateRendererScale","delta","min","shouldRender","rescaleCanvas","style","renderedDpr","reason","window","devicePixelRatio","CustomEvent","detail","reportedDpr","minimumDpr","pixelWidth","pixelHeight","context2D","context","log","clearRect","drawImage","orderedScenes","visible","push","isPresenting","preRender","t","exposure","exposureIsNumber","Number","isNaN","toneMappingExposure","onWebXRFrame","loaded","renderCount","camera","getCamera","updateMatrix","matrix","projectionMatrix","viewMatrix","slice","target","getTarget","z","visibleScene","queueRender","renderShadow","setRenderTarget","setViewport","appendChild","remove","hasRendered","removeEventListener"],"sources":["C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\@google\\model-viewer\\src\\three-components\\Renderer.ts"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {ACESFilmicToneMapping, Event, EventDispatcher, sRGBEncoding, Vector2, WebGLRenderer} from 'three';\n\nimport {$updateEnvironment} from '../features/environment.js';\nimport {ModelViewerGlobalConfig} from '../features/loading.js';\nimport ModelViewerElementBase, {$canvas, $tick, $updateSize} from '../model-viewer-base.js';\nimport {clamp, isDebugMode, resolveDpr} from '../utilities.js';\n\nimport {ARRenderer} from './ARRenderer.js';\nimport {CachingGLTFLoader} from './CachingGLTFLoader.js';\nimport {Debugger} from './Debugger.js';\nimport {ModelViewerGLTFInstance} from './gltf-instance/ModelViewerGLTFInstance.js';\nimport {ModelScene} from './ModelScene.js';\nimport TextureUtils from './TextureUtils.js';\n\nexport interface RendererOptions {\n  powerPreference: string;\n  debug?: boolean;\n}\n\nexport interface ContextLostEvent extends Event {\n  type: 'contextlost';\n  sourceEvent: WebGLContextEvent;\n}\n\n// Between 0 and 1: larger means the average responds faster and is less smooth.\nconst DURATION_DECAY = 0.2;\nconst LOW_FRAME_DURATION_MS = 40;\nconst HIGH_FRAME_DURATION_MS = 60;\nconst MAX_AVG_CHANGE_MS = 5;\nconst SCALE_STEPS = [1, 0.79, 0.62, 0.5, 0.4, 0.31, 0.25];\nconst DEFAULT_LAST_STEP = 3;\n\nexport const DEFAULT_POWER_PREFERENCE: string = 'high-performance';\n\n/**\n * Registers canvases with Canvas2DRenderingContexts and renders them\n * all in the same WebGLRenderingContext, spitting out textures to apply\n * to the canvases. Creates a fullscreen WebGL canvas that is not added\n * to the DOM, and on each frame, renders each registered canvas on a portion\n * of the WebGL canvas, and applies the texture on the registered canvas.\n *\n * In the future, can use ImageBitmapRenderingContext instead of\n * Canvas2DRenderingContext if supported for cheaper transferring of\n * the texture.\n */\nexport class Renderer extends EventDispatcher {\n  private static _singleton = new Renderer({\n    powerPreference:\n        (((self as any).ModelViewerElement || {}) as ModelViewerGlobalConfig)\n            .powerPreference ||\n        DEFAULT_POWER_PREFERENCE,\n    debug: isDebugMode()\n  });\n\n  static get singleton() {\n    return this._singleton;\n  }\n\n  static resetSingleton() {\n    const elements = this._singleton.dispose();\n    for (const element of elements) {\n      element.disconnectedCallback();\n    }\n\n    this._singleton = new Renderer({\n      powerPreference:\n          (((self as any).ModelViewerElement || {}) as ModelViewerGlobalConfig)\n              .powerPreference ||\n          DEFAULT_POWER_PREFERENCE,\n      debug: isDebugMode()\n    });\n\n    for (const element of elements) {\n      element.connectedCallback();\n    }\n  }\n\n  public threeRenderer!: WebGLRenderer;\n  public canvas3D: HTMLCanvasElement;\n  public textureUtils: TextureUtils|null;\n  public arRenderer: ARRenderer;\n  public loader = new CachingGLTFLoader(ModelViewerGLTFInstance);\n  public width = 0;\n  public height = 0;\n  public dpr = 1;\n\n  protected debugger: Debugger|null = null;\n  private scenes: Set<ModelScene> = new Set();\n  private multipleScenesVisible = false;\n  private lastTick = performance.now();\n  private renderedLastFrame = false;\n  private scaleStep = 0;\n  private lastStep = DEFAULT_LAST_STEP;\n  private avgFrameDuration =\n      (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;\n\n  get canRender() {\n    return this.threeRenderer != null;\n  }\n\n  get scaleFactor() {\n    return SCALE_STEPS[this.scaleStep];\n  }\n\n  set minScale(scale: number) {\n    let i = 1;\n    while (i < SCALE_STEPS.length) {\n      if (SCALE_STEPS[i] < scale) {\n        break;\n      }\n      ++i;\n    }\n    this.lastStep = i - 1;\n  }\n\n  constructor(options: RendererOptions) {\n    super();\n\n    this.dpr = resolveDpr();\n\n    this.canvas3D = document.createElement('canvas');\n    this.canvas3D.id = 'webgl-canvas';\n    this.canvas3D.classList.add('show');\n\n    try {\n      this.threeRenderer = new WebGLRenderer({\n        canvas: this.canvas3D,\n        alpha: true,\n        antialias: true,\n        powerPreference: options.powerPreference as WebGLPowerPreference,\n        preserveDrawingBuffer: true\n      });\n      this.threeRenderer.autoClear = true;\n      this.threeRenderer.outputEncoding = sRGBEncoding;\n      this.threeRenderer.physicallyCorrectLights = true;\n      this.threeRenderer.setPixelRatio(1);  // handle pixel ratio externally\n\n      this.debugger = !!options.debug ? new Debugger(this) : null;\n      this.threeRenderer.debug = {checkShaderErrors: !!this.debugger};\n\n      // ACESFilmicToneMapping appears to be the most \"saturated\",\n      // and similar to Filament's gltf-viewer.\n      this.threeRenderer.toneMapping = ACESFilmicToneMapping;\n    } catch (error) {\n      console.warn(error);\n    }\n\n    this.arRenderer = new ARRenderer(this);\n    this.textureUtils =\n        this.canRender ? new TextureUtils(this.threeRenderer) : null;\n    CachingGLTFLoader.initializeKTX2Loader(this.threeRenderer);\n\n    this.canvas3D.addEventListener('webglcontextlost', this.onWebGLContextLost);\n    this.canvas3D.addEventListener(\n        'webglcontextrestored', this.onWebGLContextRestored);\n\n    this.updateRendererSize();\n  }\n\n  registerScene(scene: ModelScene) {\n    this.scenes.add(scene);\n\n    scene.forceRescale();\n\n    const size = new Vector2();\n    this.threeRenderer.getSize(size);\n    scene.canvas.width = size.x;\n    scene.canvas.height = size.y;\n\n    if (this.canRender && this.scenes.size > 0) {\n      this.threeRenderer.setAnimationLoop(\n          (time: number, frame?: any) => this.render(time, frame));\n    }\n\n    if (this.debugger != null) {\n      this.debugger.addScene(scene);\n    }\n  }\n\n  unregisterScene(scene: ModelScene) {\n    this.scenes.delete(scene);\n\n    if (this.canvas3D.parentElement === scene.canvas.parentElement) {\n      scene.canvas.parentElement!.removeChild(this.canvas3D);\n    }\n\n    if (this.canRender && this.scenes.size === 0) {\n      this.threeRenderer.setAnimationLoop(null);\n    }\n\n    if (this.debugger != null) {\n      this.debugger.removeScene(scene);\n    }\n  }\n\n  displayCanvas(scene: ModelScene): HTMLCanvasElement {\n    return this.multipleScenesVisible ? scene.element[$canvas] : this.canvas3D;\n  }\n\n  /**\n   * The function enables an optimization, where when there is only a single\n   * <model-viewer> element, we can use the renderer's 3D canvas directly for\n   * display. Otherwise we need to use the element's 2D canvas and copy the\n   * renderer's result into it.\n   */\n  private countVisibleScenes() {\n    const {canvas3D} = this;\n    let visibleScenes = 0;\n    let canvas3DScene = null;\n    for (const scene of this.scenes) {\n      const {element} = scene;\n      if (element.modelIsVisible && scene.externalRenderer == null) {\n        ++visibleScenes;\n      }\n      if (canvas3D.parentElement === scene.canvas.parentElement) {\n        canvas3DScene = scene;\n      }\n    }\n    const multipleScenesVisible = visibleScenes > 1;\n\n    if (canvas3DScene != null) {\n      const newlyMultiple =\n          multipleScenesVisible && !this.multipleScenesVisible;\n      const disappearing = !canvas3DScene.element.modelIsVisible;\n      if (newlyMultiple || disappearing) {\n        const {width, height} = this.sceneSize(canvas3DScene);\n        this.copyPixels(canvas3DScene, width, height);\n        canvas3D.parentElement!.removeChild(canvas3D);\n      }\n    }\n    this.multipleScenesVisible = multipleScenesVisible;\n  }\n\n  /**\n   * Updates the renderer's size based on the largest scene and any changes to\n   * device pixel ratio.\n   */\n  private updateRendererSize() {\n    const dpr = resolveDpr();\n    if (dpr !== this.dpr) {\n      // If the device pixel ratio has changed due to page zoom, elements\n      // specified by % width do not fire a resize event even though their CSS\n      // pixel dimensions change, so we force them to update their size here.\n      for (const scene of this.scenes) {\n        const {element} = scene;\n        element[$updateSize](element.getBoundingClientRect());\n      }\n    }\n\n    // Make the renderer the size of the largest scene\n    let width = 0;\n    let height = 0;\n    for (const scene of this.scenes) {\n      width = Math.max(width, scene.width);\n      height = Math.max(height, scene.height);\n    }\n\n    if (width === this.width && height === this.height && dpr === this.dpr) {\n      return;\n    }\n    this.width = width;\n    this.height = height;\n    this.dpr = dpr;\n    width = Math.ceil(width * dpr);\n    height = Math.ceil(height * dpr);\n\n    if (this.canRender) {\n      this.threeRenderer.setSize(width, height, false);\n    }\n\n    // Each scene's canvas must match the renderer size. In general they can be\n    // larger than the element that contains them, but the overflow is hidden\n    // and only the portion that is shown is copied over.\n    for (const scene of this.scenes) {\n      const {canvas} = scene;\n      canvas.width = width;\n      canvas.height = height;\n      scene.forceRescale();\n    }\n  }\n\n  private updateRendererScale(delta: number) {\n    const scaleStep = this.scaleStep;\n\n    this.avgFrameDuration += clamp(\n        DURATION_DECAY * (delta - this.avgFrameDuration),\n        -MAX_AVG_CHANGE_MS,\n        MAX_AVG_CHANGE_MS);\n\n    if (this.avgFrameDuration > HIGH_FRAME_DURATION_MS) {\n      ++this.scaleStep;\n    } else if (\n        this.avgFrameDuration < LOW_FRAME_DURATION_MS && this.scaleStep > 0) {\n      --this.scaleStep;\n    }\n    this.scaleStep = Math.min(this.scaleStep, this.lastStep);\n\n    if (scaleStep !== this.scaleStep) {\n      this.avgFrameDuration =\n          (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;\n    }\n  }\n\n  private shouldRender(scene: ModelScene): boolean {\n    if (!scene.shouldRender()) {\n      // The first frame we stop rendering the scene (because it stops moving),\n      // trigger one extra render at full scale.\n      if (scene.scaleStep != 0) {\n        scene.scaleStep = 0;\n        this.rescaleCanvas(scene);\n      } else {\n        return false;\n      }\n    } else if (scene.scaleStep != this.scaleStep) {\n      // Update render scale\n      scene.scaleStep = this.scaleStep;\n      this.rescaleCanvas(scene);\n    }\n    return true;\n  }\n\n  private rescaleCanvas(scene: ModelScene) {\n    const scale = SCALE_STEPS[scene.scaleStep];\n    const width = Math.ceil(this.width / scale);\n    const height = Math.ceil(this.height / scale);\n\n    const {style} = scene.canvas;\n    style.width = `${width}px`;\n    style.height = `${height}px`;\n    this.canvas3D.style.width = `${width}px`;\n    this.canvas3D.style.height = `${height}px`;\n\n    const renderedDpr = this.dpr * scale;\n    const reason = scale < 1                 ? 'GPU throttling' :\n        this.dpr !== window.devicePixelRatio ? 'No meta viewport tag' :\n                                               '';\n    scene.element.dispatchEvent(new CustomEvent('render-scale', {\n      detail: {\n        reportedDpr: window.devicePixelRatio,\n        renderedDpr: renderedDpr,\n        minimumDpr: this.dpr * SCALE_STEPS[this.lastStep],\n        pixelWidth: Math.ceil(scene.width * renderedDpr),\n        pixelHeight: Math.ceil(scene.height * renderedDpr),\n        reason: reason\n      }\n    }));\n  }\n\n  private sceneSize(scene: ModelScene) {\n    const {dpr} = this;\n    const scaleFactor = SCALE_STEPS[scene.scaleStep];\n    // We avoid using the Three.js PixelRatio and handle it ourselves here so\n    // that we can do proper rounding and avoid white boundary pixels.\n    const width = Math.min(\n        Math.ceil(scene.width * scaleFactor * dpr), this.canvas3D.width);\n    const height = Math.min(\n        Math.ceil(scene.height * scaleFactor * dpr), this.canvas3D.height);\n    return {width, height};\n  }\n\n  private copyPixels(scene: ModelScene, width: number, height: number) {\n    const context2D = scene.context;\n    if (context2D == null) {\n      console.log('could not acquire 2d context');\n      return;\n    }\n    context2D.clearRect(0, 0, width, height);\n    context2D.drawImage(\n        this.canvas3D, 0, 0, width, height, 0, 0, width, height);\n    scene.canvas.classList.add('show');\n  }\n\n  /**\n   * Returns an array version of this.scenes where the non-visible ones are\n   * first. This allows eager scenes to be rendered before they are visible,\n   * without needing the multi-canvas render path.\n   */\n  private orderedScenes(): Array<ModelScene> {\n    const scenes = [];\n    for (const visible of [false, true]) {\n      for (const scene of this.scenes) {\n        if (scene.element.modelIsVisible === visible) {\n          scenes.push(scene);\n        }\n      }\n    }\n    return scenes;\n  }\n\n  get isPresenting(): boolean {\n    return this.arRenderer.isPresenting;\n  }\n\n  /**\n   * This method takes care of updating the element and renderer state based on\n   * the time that has passed since the last rendered frame.\n   */\n  preRender(scene: ModelScene, t: number, delta: number) {\n    const {element, exposure} = scene;\n\n    element[$tick](t, delta);\n\n    const exposureIsNumber =\n        typeof exposure === 'number' && !Number.isNaN(exposure);\n    this.threeRenderer.toneMappingExposure = exposureIsNumber ? exposure : 1.0;\n  }\n\n  render(t: number, frame?: XRFrame) {\n    if (frame != null) {\n      this.arRenderer.onWebXRFrame(t, frame);\n      return;\n    }\n\n    const delta = t - this.lastTick;\n    this.lastTick = t;\n\n    if (!this.canRender || this.isPresenting) {\n      return;\n    }\n\n    this.countVisibleScenes();\n    this.updateRendererSize();\n    if (this.renderedLastFrame) {\n      this.updateRendererScale(delta);\n      this.renderedLastFrame = false;\n    }\n\n    const {canvas3D} = this;\n\n    for (const scene of this.orderedScenes()) {\n      const {element} = scene;\n      if (!element.loaded ||\n          (!element.modelIsVisible && scene.renderCount > 0)) {\n        continue;\n      }\n\n      this.preRender(scene, t, delta);\n\n      if (!this.shouldRender(scene)) {\n        continue;\n      }\n\n      if (scene.externalRenderer != null) {\n        const camera = scene.getCamera();\n        camera.updateMatrix();\n        const {matrix, projectionMatrix} = camera;\n        const viewMatrix = matrix.elements.slice();\n        const target = scene.getTarget();\n        viewMatrix[12] += target.x;\n        viewMatrix[13] += target.y;\n        viewMatrix[14] += target.z;\n\n        scene.externalRenderer.render({\n          viewMatrix: viewMatrix,\n          projectionMatrix: projectionMatrix.elements\n        });\n        continue;\n      }\n\n      if (!element.modelIsVisible && !this.multipleScenesVisible) {\n        // Here we are pre-rendering on the visible canvas, so we must mark the\n        // visible scene dirty to ensure it overwrites us.\n        for (const visibleScene of this.scenes) {\n          if (visibleScene.element.modelIsVisible) {\n            visibleScene.queueRender();\n          }\n        }\n      }\n\n      const {width, height} = this.sceneSize(scene);\n\n      scene.renderShadow(this.threeRenderer);\n\n      // Need to set the render target in order to prevent\n      // clearing the depth from a different buffer\n      this.threeRenderer.setRenderTarget(null);\n      this.threeRenderer.setViewport(\n          0, Math.ceil(this.height * this.dpr) - height, width, height);\n      this.threeRenderer.render(scene, scene.camera);\n\n      if (this.multipleScenesVisible || scene.renderCount === 0) {\n        this.copyPixels(scene, width, height);\n      } else {\n        if (canvas3D.parentElement !== scene.canvas.parentElement) {\n          scene.canvas.parentElement!.appendChild(canvas3D);\n          scene.canvas.classList.remove('show');\n        }\n      }\n\n      scene.hasRendered();\n      ++scene.renderCount;\n      this.renderedLastFrame = true;\n    }\n  }\n\n  dispose(): Array<ModelViewerElementBase> {\n    if (this.textureUtils != null) {\n      this.textureUtils.dispose();\n    }\n\n    if (this.threeRenderer != null) {\n      this.threeRenderer.dispose();\n    }\n\n    this.textureUtils = null;\n    (this as any).threeRenderer = null;\n\n    const elements = [];\n    for (const scene of this.scenes) {\n      elements.push(scene.element);\n    }\n\n    this.canvas3D.removeEventListener(\n        'webglcontextlost', this.onWebGLContextLost);\n    this.canvas3D.removeEventListener(\n        'webglcontextrestored', this.onWebGLContextRestored);\n\n    return elements;\n  }\n\n  onWebGLContextLost = (event: Event) => {\n    this.dispatchEvent(\n        {type: 'contextlost', sourceEvent: event} as ContextLostEvent);\n  };\n\n  onWebGLContextRestored = () => {\n    this.textureUtils?.dispose();\n    this.textureUtils = new TextureUtils(this.threeRenderer);\n    for (const scene of this.scenes) {\n      (scene.element as any)[$updateEnvironment]();\n    }\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}