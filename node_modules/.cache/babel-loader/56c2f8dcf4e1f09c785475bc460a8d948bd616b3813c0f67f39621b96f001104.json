{"ast":null,"code":"import { _ as _defineProperty } from './defineProperty-c8ecdc07.browser.esm.js';\nimport { a as AbstractClientWallet } from './base-eec23f27.browser.esm.js';\nimport { w as walletIds } from './walletIds-e41b240b.browser.esm.js';\nimport { _ as _classPrivateMethodInitSpec, a as _classPrivateMethodGet } from './classPrivateMethodGet-ea199cc3.browser.esm.js';\nimport { _ as _classPrivateFieldInitSpec, a as _classPrivateFieldSet, b as _classPrivateFieldGet } from './classPrivateFieldSet-a5db7c83.browser.esm.js';\nimport { Core } from '@walletconnect/core';\nimport { Web3Wallet } from '@walletconnect/web3wallet';\nimport { utils } from 'ethers';\nimport EventEmitter from 'eventemitter3';\nimport { T as TW_WC_PROJECT_ID, W as WC_RELAY_URL, E as EIP155_SIGNING_METHODS } from './wc-c6a6a61c.browser.esm.js';\nimport { formatJsonRpcResult } from '@walletconnect/jsonrpc-utils';\nimport { getValidChainRPCs } from '@thirdweb-dev/chains';\nimport { isContractDeployed, ThirdwebSDK } from '@thirdweb-dev/sdk';\n\n// connect dapp support through wcv2 protocol\n\nclass WalletConnectHandler extends EventEmitter {}\nvar _core = /*#__PURE__*/new WeakMap();\nvar _wcWallet = /*#__PURE__*/new WeakMap();\nvar _session = /*#__PURE__*/new WeakMap();\nvar _wcMetadata = /*#__PURE__*/new WeakMap();\nvar _activeProposal = /*#__PURE__*/new WeakMap();\nvar _activeRequestEvent = /*#__PURE__*/new WeakMap();\nvar _setupWalletConnectEventsListeners = /*#__PURE__*/new WeakSet();\nvar _getSignParamsMessage = /*#__PURE__*/new WeakSet();\nclass WalletConnectV2Handler extends WalletConnectHandler {\n  constructor(options) {\n    super();\n    /**\n     * Gets message from various signing request methods by filtering out\n     * a value that is not an address (thus is a message).\n     * If it is a hex string, it gets converted to utf8 string\n     */\n    _classPrivateMethodInitSpec(this, _getSignParamsMessage);\n    _classPrivateMethodInitSpec(this, _setupWalletConnectEventsListeners);\n    _classPrivateFieldInitSpec(this, _core, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _wcWallet, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _session, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _wcMetadata, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _activeProposal, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _activeRequestEvent, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _wcMetadata, options?.walletConnectWalletMetadata || {\n      name: \"Thirdweb Smart Wallet\",\n      description: \"Thirdweb Smart Wallet\",\n      url: \"https://thirdweb.com\",\n      icons: [\"https://thirdweb.com/favicon.ico\"]\n    });\n    _classPrivateFieldSet(this, _core, new Core({\n      projectId: options?.walletConnectV2ProjectId || TW_WC_PROJECT_ID,\n      relayUrl: options?.walletConnectV2RelayUrl || WC_RELAY_URL\n    }));\n  }\n  async init() {\n    _classPrivateFieldSet(this, _wcWallet, await Web3Wallet.init({\n      core: _classPrivateFieldGet(this, _core),\n      metadata: _classPrivateFieldGet(this, _wcMetadata)\n    }));\n    const sessions = _classPrivateFieldGet(this, _wcWallet).getActiveSessions();\n    const keys = Object.keys(sessions);\n    if (keys[0]) {\n      _classPrivateFieldSet(this, _session, sessions[keys[0]]);\n    }\n    _classPrivateMethodGet(this, _setupWalletConnectEventsListeners, _setupWalletConnectEventsListeners2).call(this);\n  }\n  async connectApp(wcUri) {\n    if (!_classPrivateFieldGet(this, _wcWallet)) {\n      throw new Error(\"Please, init the wallet before connecting an app.\");\n    }\n    await _classPrivateFieldGet(this, _wcWallet).core.pairing.pair({\n      uri: wcUri\n    });\n  }\n  async approveSession(wallet) {\n    if (!_classPrivateFieldGet(this, _wcWallet)) {\n      throw new Error(\"Please, init the wallet before making session requests.\");\n    }\n    if (!_classPrivateFieldGet(this, _activeProposal)) {\n      throw new Error(\"Please, pass a valid proposal.\");\n    }\n    const account = await wallet.getAddress();\n    const {\n      id,\n      params\n    } = _classPrivateFieldGet(this, _activeProposal);\n    const {\n      requiredNamespaces,\n      relays\n    } = params;\n    const namespaces = {};\n    Object.keys(requiredNamespaces).forEach(key => {\n      const accounts = [];\n      const namespace = requiredNamespaces[key];\n      if (namespace) {\n        namespace.chains?.map(chain => {\n          accounts.push(`${chain}:${account}`);\n        });\n        namespaces[key] = {\n          accounts,\n          methods: namespace.methods,\n          events: namespace.events\n        };\n      }\n    });\n    _classPrivateFieldSet(this, _session, await _classPrivateFieldGet(this, _wcWallet).approveSession({\n      id,\n      relayProtocol: relays[0]?.protocol,\n      namespaces\n    }));\n    this.emit(\"session_approved\");\n  }\n  async rejectSession() {\n    if (!_classPrivateFieldGet(this, _wcWallet)) {\n      throw new Error(\"Please, init the wallet before making session requests.\");\n    }\n    if (!_classPrivateFieldGet(this, _activeProposal)) {\n      throw new Error(\"Please, pass a valid proposal.\");\n    }\n    const {\n      id\n    } = _classPrivateFieldGet(this, _activeProposal);\n    await _classPrivateFieldGet(this, _wcWallet).rejectSession({\n      id,\n      reason: {\n        message: \"User rejected methods.\",\n        code: 5002\n      }\n    });\n  }\n  async approveEIP155Request(wallet) {\n    if (!_classPrivateFieldGet(this, _activeRequestEvent)) {\n      return;\n    }\n    const {\n      topic,\n      params,\n      id\n    } = _classPrivateFieldGet(this, _activeRequestEvent);\n    const {\n      request\n    } = params;\n    let response;\n    switch (request.method) {\n      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:\n      case EIP155_SIGNING_METHODS.ETH_SIGN:\n        const message = _classPrivateMethodGet(this, _getSignParamsMessage, _getSignParamsMessage2).call(this, request.params);\n        const signedMessage = await wallet.signMessage(message || \"\"); // TODO: handle empty message\n\n        response = formatJsonRpcResult(id, signedMessage);\n        break;\n      // case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA:\n      // case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V3:\n      // case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V4:\n      //   const {\n      //     domain,\n      //     types,\n      //     message: data,\n      //   } = getSignTypedDataParamsData(request.params);\n      //   // https://github.com/ethers-io/ethers.js/issues/687#issuecomment-714069471\n      //   delete types.EIP712Domain;\n      //   const signedData = await wallet._signTypedData(domain, types, data);\n      //   return formatJsonRpcResult(id, signedData);\n      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:\n        const signer = await wallet.getSigner();\n        const sendTransaction = request.params[0];\n        const tx = await signer.sendTransaction(sendTransaction);\n        const {\n          transactionHash\n        } = await tx.wait();\n        response = formatJsonRpcResult(id, transactionHash);\n        break;\n      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:\n        const signerSign = await wallet.getSigner();\n        const signTransaction = request.params[0];\n        const signature = await signerSign.signTransaction(signTransaction);\n        response = formatJsonRpcResult(id, signature);\n        break;\n      default:\n        const error = {\n          id,\n          jsonrpc: \"2.0\",\n          error: {\n            message: \"Invalid event.\",\n            code: 1002\n          }\n        };\n        return _classPrivateFieldGet(this, _wcWallet)?.respondSessionRequest({\n          topic,\n          response: error\n        });\n    }\n    return _classPrivateFieldGet(this, _wcWallet)?.respondSessionRequest({\n      topic,\n      response\n    });\n  }\n  async rejectEIP155Request() {\n    if (!_classPrivateFieldGet(this, _activeRequestEvent)) {\n      return;\n    }\n    const {\n      topic,\n      id\n    } = _classPrivateFieldGet(this, _activeRequestEvent);\n    const response = {\n      id,\n      jsonrpc: \"2.0\",\n      error: {\n        message: \"User rejected methods.\",\n        code: 5002\n      }\n    };\n    return _classPrivateFieldGet(this, _wcWallet)?.respondSessionRequest({\n      topic,\n      response\n    });\n  }\n  getActiveSessions() {\n    if (!_classPrivateFieldGet(this, _wcWallet)) {\n      throw new Error(\"Please, init the wallet before getting sessions.\");\n    }\n    const sessions = _classPrivateFieldGet(this, _wcWallet).getActiveSessions();\n    const sessionKeys = Object.keys(sessions);\n    if (!sessions || sessionKeys.length === 0) {\n      return [];\n    }\n    const thisSessions = [];\n    for (const sessionKey of sessionKeys) {\n      const session = sessions[sessionKey];\n      if (session) {\n        const topic = session.topic;\n        const peerMeta = session.peer.metadata;\n        thisSessions.push({\n          topic,\n          peer: {\n            metadata: peerMeta\n          }\n        });\n      }\n    }\n    return thisSessions;\n  }\n  disconnectSession() {\n    if (!_classPrivateFieldGet(this, _wcWallet)) {\n      throw new Error(\"Please, init the wallet before disconnecting sessions.\");\n    }\n    if (!_classPrivateFieldGet(this, _session)) {\n      return Promise.resolve();\n    }\n    const params = {\n      topic: _classPrivateFieldGet(this, _session).topic,\n      reason: {\n        message: \"User disconnected.\",\n        code: 6000\n      }\n    };\n    return _classPrivateFieldGet(this, _wcWallet)?.disconnectSession(params);\n  }\n}\nfunction _setupWalletConnectEventsListeners2() {\n  if (!_classPrivateFieldGet(this, _wcWallet)) {\n    throw new Error(\"Please, init the wallet before making session requests.\");\n  }\n  _classPrivateFieldGet(this, _wcWallet).on(\"session_proposal\", proposal => {\n    _classPrivateFieldSet(this, _activeProposal, proposal);\n    this.emit(\"session_proposal\", {\n      proposer: {\n        metadata: proposal.params.proposer.metadata\n      }\n    });\n  });\n  _classPrivateFieldGet(this, _wcWallet).on(\"session_delete\", session => {\n    _classPrivateFieldSet(this, _session, undefined);\n    _classPrivateFieldSet(this, _activeProposal, undefined);\n    this.emit(\"session_delete\", {\n      topic: session.topic\n    });\n  });\n  _classPrivateFieldGet(this, _wcWallet).on(\"session_request\", async requestEvent => {\n    if (!_classPrivateFieldGet(this, _session)) {\n      return;\n    }\n    const {\n      params: requestParams\n    } = requestEvent;\n    const {\n      request\n    } = requestParams;\n    const {\n      params\n    } = request;\n    switch (request.method) {\n      case EIP155_SIGNING_METHODS.ETH_SIGN:\n      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:\n        _classPrivateFieldSet(this, _activeRequestEvent, requestEvent);\n        const message = params[0];\n        const decodedMessage = new TextDecoder().decode(utils.arrayify(message));\n        const paramsCopy = [...params];\n        paramsCopy[0] = decodedMessage;\n        this.emit(\"session_request\", {\n          topic: _classPrivateFieldGet(this, _session).topic,\n          params: paramsCopy,\n          peer: {\n            metadata: _classPrivateFieldGet(this, _session).peer.metadata\n          },\n          method: request.method\n        });\n        return;\n      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:\n      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:\n        _classPrivateFieldSet(this, _activeRequestEvent, requestEvent);\n        this.emit(\"session_request\", {\n          topic: _classPrivateFieldGet(this, _session).topic,\n          params: requestEvent.params.request.params,\n          peer: {\n            metadata: _classPrivateFieldGet(this, _session).peer.metadata\n          },\n          method: request.method\n        });\n        return;\n      default:\n        throw new Error(`WCV2.Method not supported: ${request.method}`);\n    }\n  });\n}\nfunction _getSignParamsMessage2(params) {\n  const message = params.filter(p => !utils.isAddress(p))[0] || \"\"; // TODO: handle empty message\n\n  if (utils.isHexString(message)) {\n    return utils.toUtf8String(message);\n  }\n  return message;\n}\nclass NoOpWalletConnectHandler extends WalletConnectHandler {\n  init() {\n    return Promise.resolve();\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  connectApp(uri) {\n    return Promise.resolve();\n  }\n  approveSession(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  wallet) {\n    return Promise.resolve();\n  }\n  rejectSession() {\n    return Promise.resolve();\n  }\n  approveEIP155Request(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  wallet) {\n    return Promise.resolve();\n  }\n  rejectEIP155Request() {\n    return Promise.resolve();\n  }\n  getActiveSessions() {\n    return [];\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  disconnectSession() {\n    return Promise.resolve();\n  }\n}\nconst sdkCache = new Map();\nfunction getSDK(chain) {\n  const cached = sdkCache.get(chain);\n  if (cached) {\n    return cached;\n  }\n  const sdk = new ThirdwebSDK(chain);\n  sdkCache.set(chain, sdk);\n  return sdk;\n}\n\n/**\n * Get all the signers added to the given smart wallet (excluding owner)\n * @param chain\n * @param factoryAddress\n * @param smartWalletAddress\n * @returns\n */\nasync function getAllSigners(chain, factoryAddress, smartWalletAddress) {\n  const readOnlySDK = getSDK(chain);\n  const factoryContract = await readOnlySDK.getContract(factoryAddress);\n  const signers = await factoryContract.call(\"getSignersOfAccount\", [smartWalletAddress]);\n  return signers;\n}\n\n/**\n * Get all the smart wallets associated with a personal wallet address\n * @param chain\n * @param factoryAddress\n * @param personalWalletAddress\n * @returns\n */\nasync function getAllSmartWallets(chain, factoryAddress, personalWalletAddress) {\n  const readOnlySDK = getSDK(chain);\n  const factoryContract = await readOnlySDK.getContract(factoryAddress);\n  const ownedAccount = await getSmartWalletAddress(chain, factoryAddress, personalWalletAddress);\n  const accessibleAccounts = await factoryContract.call(\"getAccountsOfSigner\", [personalWalletAddress]);\n  return {\n    owned: ownedAccount,\n    hasSignerRole: accessibleAccounts\n  };\n}\n\n/**\n * Check if a smart wallet is deployed for a given personal wallet address\n * @param chain\n * @param factoryAddress\n * @param personalWalletAddress\n * @returns\n */\nasync function isSmartWalletDeployed(chain, factoryAddress, personalWalletAddress) {\n  let data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"0x\";\n  const readOnlySDK = getSDK(chain);\n  const factoryContract = await readOnlySDK.getContract(factoryAddress);\n  const accountAddress = await factoryContract.call(\"getAddress\", [personalWalletAddress, data]);\n  const isDeployed = await isContractDeployed(accountAddress, readOnlySDK.getProvider());\n  return isDeployed;\n}\n\n/**\n * Get the associated smart wallet address for a given personal wallet address\n * @param chain\n * @param factoryAddress\n * @param personalWalletAddress\n * @returns\n */\nasync function getSmartWalletAddress(chain, factoryAddress, personalWalletAddress) {\n  let data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"0x\";\n  const readOnlySDK = getSDK(chain);\n  const factoryContract = await readOnlySDK.getContract(factoryAddress);\n  const accountAddress = await factoryContract.call(\"getAddress\", [personalWalletAddress, data]);\n  return accountAddress;\n}\nclass SmartWallet extends AbstractClientWallet {\n  get walletName() {\n    return \"Smart Wallet\";\n  }\n  constructor(options) {\n    if (options.clientId && typeof options.chain === \"object\") {\n      try {\n        options.chain = {\n          ...options.chain,\n          rpc: getValidChainRPCs(options.chain, options.clientId)\n        };\n      } catch {}\n    }\n    super(SmartWallet.id, {\n      ...options\n    });\n    _defineProperty(this, \"enableConnectApp\", false);\n    this.enableConnectApp = options?.enableConnectApp || false;\n    this.wcWallet = this.enableConnectApp ? new WalletConnectV2Handler({\n      walletConnectWalletMetadata: options?.walletConnectWalletMetadata,\n      walletConnectV2ProjectId: options?.walletConnectV2ProjectId,\n      walletConnectV2RelayUrl: options?.walletConnectV2RelayUrl\n    }) : new NoOpWalletConnectHandler();\n  }\n  async getConnector() {\n    if (!this.connector) {\n      if (this.enableConnectApp) {\n        await this.wcWallet.init();\n        this.setupWalletConnectEventsListeners();\n      }\n      const {\n        SmartWalletConnector\n      } = await import('../evm/connectors/smart-wallet/dist/thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm.js');\n      this.connector = new SmartWalletConnector(this.options);\n    }\n    return this.connector;\n  }\n  getPersonalWallet() {\n    return this.connector?.personalWallet;\n  }\n\n  /**\n   * Check whether the connected signer can execute a given transaction using the smart wallet.\n   * @param transaction the transaction to execute using the smart wallet.\n   * @returns whether the connected signer can execute the transaction using the smart wallet.\n   */\n  async hasPermissionToExecute(transaction) {\n    const connector = await this.getConnector();\n    return connector.hasPermissionToExecute(transaction);\n  }\n\n  /**\n   * Send a single transaction without waiting for confirmations\n   * @param transactions\n   * @returns the transaction result\n   */\n  async send(transaction) {\n    const connector = await this.getConnector();\n    return connector.send(transaction);\n  }\n\n  /**\n   * Execute a single transaction and wait for confirmations\n   * @param transactions\n   * @returns the transaction receipt\n   */\n  async execute(transaction) {\n    const connector = await this.getConnector();\n    return connector.execute(transaction);\n  }\n\n  /**\n   * Send a multiple transaction in a batch without waiting for confirmations\n   * @param transactions\n   * @returns the transaction result\n   */\n  async sendBatch(transactions) {\n    const connector = await this.getConnector();\n    return connector.sendBatch(transactions);\n  }\n\n  /**\n   * Execute multiple transactions in a single batch and wait for confirmations\n   * @param transactions\n   * @returns the transaction receipt\n   */\n  async executeBatch(transactions) {\n    const connector = await this.getConnector();\n    return connector.executeBatch(transactions);\n  }\n\n  /**\n   * Send a single raw transaction without waiting for confirmations\n   * @param transaction\n   * @returns the transaction result\n   */\n  async sendRaw(transaction) {\n    const connector = await this.getConnector();\n    return connector.sendRaw(transaction);\n  }\n\n  /**\n   * Execute a single raw transaction and wait for confirmations\n   * @param transaction\n   * @returns the transaction receipt\n   */\n  async executeRaw(transaction) {\n    const connector = await this.getConnector();\n    return connector.executeRaw(transaction);\n  }\n\n  /**\n   * Estimate the gas cost of a single transaction\n   * @param transaction\n   * @returns\n   */\n  async estimate(transaction) {\n    const connector = await this.getConnector();\n    return connector.estimate(transaction);\n  }\n\n  /**\n   * Estimate the gas cost of a batch of transactions\n   * @param transaction\n   * @returns\n   */\n  async estimateBatch(transactions) {\n    const connector = await this.getConnector();\n    return connector.estimateBatch(transactions);\n  }\n\n  /**\n   * Estimate the gas cost of a single raw transaction\n   * @param transaction\n   * @returns\n   */\n  async estimateRaw(transactions) {\n    const connector = await this.getConnector();\n    return connector.estimateRaw(transactions);\n  }\n\n  /**\n   * Estimate the gas cost of a batch of raw transactions\n   * @param transaction\n   * @returns\n   */\n  async estimateBatchRaw(transactions) {\n    const connector = await this.getConnector();\n    return connector.estimateBatchRaw(transactions);\n  }\n\n  /**\n   * Send multiple raw transaction in a batch without waiting for confirmations\n   * @param transaction\n   * @returns the transaction result\n   */\n  async sendBatchRaw(transactions) {\n    const connector = await this.getConnector();\n    return connector.sendBatchRaw(transactions);\n  }\n\n  /**\n   * Execute multiple raw transactions in a single batch and wait for confirmations\n   * @param transaction\n   * @returns the transaction receipt\n   */\n  async executeBatchRaw(transactions) {\n    const connector = await this.getConnector();\n    return connector.executeBatchRaw(transactions);\n  }\n\n  /**\n   * Manually deploy the smart wallet contract. If already deployed this will throw an error.\n   * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.\n   * @returns the transaction receipt\n   */\n  async deploy() {\n    const connector = await this.getConnector();\n    return connector.deploy();\n  }\n\n  /**\n   * Manually deploy the smart wallet contract. If already deployed this will do nothing.\n   * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.\n   * @returns the transaction receipt\n   */\n  async deployIfNeeded() {\n    const connector = await this.getConnector();\n    return connector.deployIfNeeded();\n  }\n\n  /**\n   * Check if the smart wallet contract is deployed\n   * @returns true if the smart wallet contract is deployed\n   */\n  async isDeployed() {\n    const connector = await this.getConnector();\n    return connector.isDeployed();\n  }\n\n  /**\n   * Create and add a session key to the smart wallet.\n   * @param keyAddress the address of the session key to add.\n   * @param permissions the permissions to grant to the session key.\n   */\n  async createSessionKey(keyAddress, permissions) {\n    const connector = await this.getConnector();\n    return connector.grantPermissions(keyAddress, permissions);\n  }\n\n  /**\n   * Remove a session key from the smart wallet.\n   * @param keyAddress the address of the session key to remove.\n   */\n  async revokeSessionKey(keyAddress) {\n    const connector = await this.getConnector();\n    return connector.revokePermissions(keyAddress);\n  }\n\n  /**\n   * Add another admin to the smart wallet.\n   * @param adminAddress the address of the admin to add.\n   */\n  async addAdmin(adminAddress) {\n    const connector = await this.getConnector();\n    return connector.addAdmin(adminAddress);\n  }\n\n  /**\n   * Remove an admin from the smart wallet.\n   * @param adminAddress the address of the admin to remove.\n   */\n  async removeAdmin(adminAddress) {\n    const connector = await this.getConnector();\n    return connector.removeAdmin(adminAddress);\n  }\n\n  /**\n   * Get all the admins and session keys active on the smart wallet.\n   */\n  async getAllActiveSigners() {\n    const connector = await this.getConnector();\n    return connector.getAllActiveSigners();\n  }\n\n  /**\n   * Get the underlying account contract of the smart wallet.\n   * @returns the account contract of the smart wallet.\n   */\n  async getAccountContract() {\n    const connector = await this.getConnector();\n    return connector.getAccountContract();\n  }\n\n  /**\n   * Get the underlying account factory contract of the smart wallet.\n   * @returns the account factory contract.\n   */\n  async getFactoryContract() {\n    const connector = await this.getConnector();\n    return connector.getFactoryContract();\n  }\n  autoConnect(params) {\n    return this.connect(params);\n  }\n\n  // wcv2\n  async connectApp(uri) {\n    if (!this.enableConnectApp) {\n      throw new Error(\"enableConnectApp is set to false in this wallet config\");\n    }\n    this.wcWallet?.connectApp(uri);\n  }\n  async approveSession() {\n    await this.wcWallet.approveSession(this);\n    this.emit(\"message\", {\n      type: \"session_approved\"\n    });\n  }\n  rejectSession() {\n    return this.wcWallet.rejectSession();\n  }\n  approveRequest() {\n    return this.wcWallet.approveEIP155Request(this);\n  }\n  rejectRequest() {\n    return this.wcWallet.rejectEIP155Request();\n  }\n  getActiveSessions() {\n    if (!this.wcWallet) {\n      throw new Error(\"Please, init the wallet before making session requests.\");\n    }\n    return this.wcWallet.getActiveSessions();\n  }\n  disconnectSession() {\n    return this.wcWallet?.disconnectSession();\n  }\n  isWCReceiverEnabled() {\n    return this.enableConnectApp;\n  }\n  setupWalletConnectEventsListeners() {\n    if (!this.wcWallet) {\n      throw new Error(\"Please, init the wallet before making session requests.\");\n    }\n    this.wcWallet.on(\"session_proposal\", proposal => {\n      this.emit(\"message\", {\n        type: \"session_proposal\",\n        data: proposal\n      });\n    });\n    this.wcWallet.on(\"session_delete\", () => {\n      this.emit(\"message\", {\n        type: \"session_delete\"\n      });\n    });\n    this.wcWallet.on(\"switch_chain\", request => {\n      const chainId = request.params[0].chainId;\n      this.emit(\"message\", {\n        type: \"switch_chain\",\n        data: {\n          chainId\n        }\n      });\n      this.wcWallet.disconnectSession();\n    });\n    this.wcWallet.on(\"session_request\", request => {\n      this.emit(\"message\", {\n        type: \"session_request\",\n        data: request\n      });\n    });\n  }\n}\n_defineProperty(SmartWallet, \"meta\", {\n  name: \"Smart Wallet\",\n  iconURL: \"ipfs://QmeAJVqn17aDNQhjEU3kcWVZCFBrfta8LzaDGkS8Egdiyk/smart-wallet.svg\"\n});\n_defineProperty(SmartWallet, \"id\", walletIds.smartWallet);\nexport { SmartWallet as S, WalletConnectV2Handler as W, WalletConnectHandler as a, getAllSmartWallets as b, getSmartWalletAddress as c, getAllSigners as g, isSmartWalletDeployed as i };","map":{"version":3,"names":["_","_defineProperty","a","AbstractClientWallet","w","walletIds","_classPrivateMethodInitSpec","_classPrivateMethodGet","_classPrivateFieldInitSpec","_classPrivateFieldSet","b","_classPrivateFieldGet","Core","Web3Wallet","utils","EventEmitter","T","TW_WC_PROJECT_ID","W","WC_RELAY_URL","E","EIP155_SIGNING_METHODS","formatJsonRpcResult","getValidChainRPCs","isContractDeployed","ThirdwebSDK","WalletConnectHandler","_core","WeakMap","_wcWallet","_session","_wcMetadata","_activeProposal","_activeRequestEvent","_setupWalletConnectEventsListeners","WeakSet","_getSignParamsMessage","WalletConnectV2Handler","constructor","options","writable","value","walletConnectWalletMetadata","name","description","url","icons","projectId","walletConnectV2ProjectId","relayUrl","walletConnectV2RelayUrl","init","core","metadata","sessions","getActiveSessions","keys","Object","_setupWalletConnectEventsListeners2","call","connectApp","wcUri","Error","pairing","pair","uri","approveSession","wallet","account","getAddress","id","params","requiredNamespaces","relays","namespaces","forEach","key","accounts","namespace","chains","map","chain","push","methods","events","relayProtocol","protocol","emit","rejectSession","reason","message","code","approveEIP155Request","topic","request","response","method","PERSONAL_SIGN","ETH_SIGN","_getSignParamsMessage2","signedMessage","signMessage","ETH_SEND_TRANSACTION","signer","getSigner","sendTransaction","tx","transactionHash","wait","ETH_SIGN_TRANSACTION","signerSign","signTransaction","signature","error","jsonrpc","respondSessionRequest","rejectEIP155Request","sessionKeys","length","thisSessions","sessionKey","session","peerMeta","peer","disconnectSession","Promise","resolve","on","proposal","proposer","undefined","requestEvent","requestParams","decodedMessage","TextDecoder","decode","arrayify","paramsCopy","filter","p","isAddress","isHexString","toUtf8String","NoOpWalletConnectHandler","sdkCache","Map","getSDK","cached","get","sdk","set","getAllSigners","factoryAddress","smartWalletAddress","readOnlySDK","factoryContract","getContract","signers","getAllSmartWallets","personalWalletAddress","ownedAccount","getSmartWalletAddress","accessibleAccounts","owned","hasSignerRole","isSmartWalletDeployed","data","arguments","accountAddress","isDeployed","getProvider","SmartWallet","walletName","clientId","rpc","enableConnectApp","wcWallet","getConnector","connector","setupWalletConnectEventsListeners","SmartWalletConnector","getPersonalWallet","personalWallet","hasPermissionToExecute","transaction","send","execute","sendBatch","transactions","executeBatch","sendRaw","executeRaw","estimate","estimateBatch","estimateRaw","estimateBatchRaw","sendBatchRaw","executeBatchRaw","deploy","deployIfNeeded","createSessionKey","keyAddress","permissions","grantPermissions","revokeSessionKey","revokePermissions","addAdmin","adminAddress","removeAdmin","getAllActiveSigners","getAccountContract","getFactoryContract","autoConnect","connect","type","approveRequest","rejectRequest","isWCReceiverEnabled","chainId","iconURL","smartWallet","S","c","g","i"],"sources":["C:/Users/SUMAN K/meta_transfer/node_modules/@thirdweb-dev/wallets/dist/smart-wallet-87ec1d05.browser.esm.js"],"sourcesContent":["import { _ as _defineProperty } from './defineProperty-c8ecdc07.browser.esm.js';\nimport { a as AbstractClientWallet } from './base-eec23f27.browser.esm.js';\nimport { w as walletIds } from './walletIds-e41b240b.browser.esm.js';\nimport { _ as _classPrivateMethodInitSpec, a as _classPrivateMethodGet } from './classPrivateMethodGet-ea199cc3.browser.esm.js';\nimport { _ as _classPrivateFieldInitSpec, a as _classPrivateFieldSet, b as _classPrivateFieldGet } from './classPrivateFieldSet-a5db7c83.browser.esm.js';\nimport { Core } from '@walletconnect/core';\nimport { Web3Wallet } from '@walletconnect/web3wallet';\nimport { utils } from 'ethers';\nimport EventEmitter from 'eventemitter3';\nimport { T as TW_WC_PROJECT_ID, W as WC_RELAY_URL, E as EIP155_SIGNING_METHODS } from './wc-c6a6a61c.browser.esm.js';\nimport { formatJsonRpcResult } from '@walletconnect/jsonrpc-utils';\nimport { getValidChainRPCs } from '@thirdweb-dev/chains';\nimport { isContractDeployed, ThirdwebSDK } from '@thirdweb-dev/sdk';\n\n// connect dapp support through wcv2 protocol\n\nclass WalletConnectHandler extends EventEmitter {}\n\nvar _core = /*#__PURE__*/new WeakMap();\nvar _wcWallet = /*#__PURE__*/new WeakMap();\nvar _session = /*#__PURE__*/new WeakMap();\nvar _wcMetadata = /*#__PURE__*/new WeakMap();\nvar _activeProposal = /*#__PURE__*/new WeakMap();\nvar _activeRequestEvent = /*#__PURE__*/new WeakMap();\nvar _setupWalletConnectEventsListeners = /*#__PURE__*/new WeakSet();\nvar _getSignParamsMessage = /*#__PURE__*/new WeakSet();\nclass WalletConnectV2Handler extends WalletConnectHandler {\n  constructor(options) {\n    super();\n    /**\n     * Gets message from various signing request methods by filtering out\n     * a value that is not an address (thus is a message).\n     * If it is a hex string, it gets converted to utf8 string\n     */\n    _classPrivateMethodInitSpec(this, _getSignParamsMessage);\n    _classPrivateMethodInitSpec(this, _setupWalletConnectEventsListeners);\n    _classPrivateFieldInitSpec(this, _core, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _wcWallet, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _session, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _wcMetadata, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _activeProposal, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _activeRequestEvent, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _wcMetadata, options?.walletConnectWalletMetadata || {\n      name: \"Thirdweb Smart Wallet\",\n      description: \"Thirdweb Smart Wallet\",\n      url: \"https://thirdweb.com\",\n      icons: [\"https://thirdweb.com/favicon.ico\"]\n    });\n    _classPrivateFieldSet(this, _core, new Core({\n      projectId: options?.walletConnectV2ProjectId || TW_WC_PROJECT_ID,\n      relayUrl: options?.walletConnectV2RelayUrl || WC_RELAY_URL\n    }));\n  }\n  async init() {\n    _classPrivateFieldSet(this, _wcWallet, await Web3Wallet.init({\n      core: _classPrivateFieldGet(this, _core),\n      metadata: _classPrivateFieldGet(this, _wcMetadata)\n    }));\n    const sessions = _classPrivateFieldGet(this, _wcWallet).getActiveSessions();\n    const keys = Object.keys(sessions);\n    if (keys[0]) {\n      _classPrivateFieldSet(this, _session, sessions[keys[0]]);\n    }\n    _classPrivateMethodGet(this, _setupWalletConnectEventsListeners, _setupWalletConnectEventsListeners2).call(this);\n  }\n  async connectApp(wcUri) {\n    if (!_classPrivateFieldGet(this, _wcWallet)) {\n      throw new Error(\"Please, init the wallet before connecting an app.\");\n    }\n    await _classPrivateFieldGet(this, _wcWallet).core.pairing.pair({\n      uri: wcUri\n    });\n  }\n  async approveSession(wallet) {\n    if (!_classPrivateFieldGet(this, _wcWallet)) {\n      throw new Error(\"Please, init the wallet before making session requests.\");\n    }\n    if (!_classPrivateFieldGet(this, _activeProposal)) {\n      throw new Error(\"Please, pass a valid proposal.\");\n    }\n    const account = await wallet.getAddress();\n    const {\n      id,\n      params\n    } = _classPrivateFieldGet(this, _activeProposal);\n    const {\n      requiredNamespaces,\n      relays\n    } = params;\n    const namespaces = {};\n    Object.keys(requiredNamespaces).forEach(key => {\n      const accounts = [];\n      const namespace = requiredNamespaces[key];\n      if (namespace) {\n        namespace.chains?.map(chain => {\n          accounts.push(`${chain}:${account}`);\n        });\n        namespaces[key] = {\n          accounts,\n          methods: namespace.methods,\n          events: namespace.events\n        };\n      }\n    });\n    _classPrivateFieldSet(this, _session, await _classPrivateFieldGet(this, _wcWallet).approveSession({\n      id,\n      relayProtocol: relays[0]?.protocol,\n      namespaces\n    }));\n    this.emit(\"session_approved\");\n  }\n  async rejectSession() {\n    if (!_classPrivateFieldGet(this, _wcWallet)) {\n      throw new Error(\"Please, init the wallet before making session requests.\");\n    }\n    if (!_classPrivateFieldGet(this, _activeProposal)) {\n      throw new Error(\"Please, pass a valid proposal.\");\n    }\n    const {\n      id\n    } = _classPrivateFieldGet(this, _activeProposal);\n    await _classPrivateFieldGet(this, _wcWallet).rejectSession({\n      id,\n      reason: {\n        message: \"User rejected methods.\",\n        code: 5002\n      }\n    });\n  }\n  async approveEIP155Request(wallet) {\n    if (!_classPrivateFieldGet(this, _activeRequestEvent)) {\n      return;\n    }\n    const {\n      topic,\n      params,\n      id\n    } = _classPrivateFieldGet(this, _activeRequestEvent);\n    const {\n      request\n    } = params;\n    let response;\n    switch (request.method) {\n      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:\n      case EIP155_SIGNING_METHODS.ETH_SIGN:\n        const message = _classPrivateMethodGet(this, _getSignParamsMessage, _getSignParamsMessage2).call(this, request.params);\n        const signedMessage = await wallet.signMessage(message || \"\"); // TODO: handle empty message\n\n        response = formatJsonRpcResult(id, signedMessage);\n        break;\n      // case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA:\n      // case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V3:\n      // case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V4:\n      //   const {\n      //     domain,\n      //     types,\n      //     message: data,\n      //   } = getSignTypedDataParamsData(request.params);\n      //   // https://github.com/ethers-io/ethers.js/issues/687#issuecomment-714069471\n      //   delete types.EIP712Domain;\n      //   const signedData = await wallet._signTypedData(domain, types, data);\n      //   return formatJsonRpcResult(id, signedData);\n      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:\n        const signer = await wallet.getSigner();\n        const sendTransaction = request.params[0];\n        const tx = await signer.sendTransaction(sendTransaction);\n        const {\n          transactionHash\n        } = await tx.wait();\n        response = formatJsonRpcResult(id, transactionHash);\n        break;\n      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:\n        const signerSign = await wallet.getSigner();\n        const signTransaction = request.params[0];\n        const signature = await signerSign.signTransaction(signTransaction);\n        response = formatJsonRpcResult(id, signature);\n        break;\n      default:\n        const error = {\n          id,\n          jsonrpc: \"2.0\",\n          error: {\n            message: \"Invalid event.\",\n            code: 1002\n          }\n        };\n        return _classPrivateFieldGet(this, _wcWallet)?.respondSessionRequest({\n          topic,\n          response: error\n        });\n    }\n    return _classPrivateFieldGet(this, _wcWallet)?.respondSessionRequest({\n      topic,\n      response\n    });\n  }\n  async rejectEIP155Request() {\n    if (!_classPrivateFieldGet(this, _activeRequestEvent)) {\n      return;\n    }\n    const {\n      topic,\n      id\n    } = _classPrivateFieldGet(this, _activeRequestEvent);\n    const response = {\n      id,\n      jsonrpc: \"2.0\",\n      error: {\n        message: \"User rejected methods.\",\n        code: 5002\n      }\n    };\n    return _classPrivateFieldGet(this, _wcWallet)?.respondSessionRequest({\n      topic,\n      response\n    });\n  }\n  getActiveSessions() {\n    if (!_classPrivateFieldGet(this, _wcWallet)) {\n      throw new Error(\"Please, init the wallet before getting sessions.\");\n    }\n    const sessions = _classPrivateFieldGet(this, _wcWallet).getActiveSessions();\n    const sessionKeys = Object.keys(sessions);\n    if (!sessions || sessionKeys.length === 0) {\n      return [];\n    }\n    const thisSessions = [];\n    for (const sessionKey of sessionKeys) {\n      const session = sessions[sessionKey];\n      if (session) {\n        const topic = session.topic;\n        const peerMeta = session.peer.metadata;\n        thisSessions.push({\n          topic,\n          peer: {\n            metadata: peerMeta\n          }\n        });\n      }\n    }\n    return thisSessions;\n  }\n  disconnectSession() {\n    if (!_classPrivateFieldGet(this, _wcWallet)) {\n      throw new Error(\"Please, init the wallet before disconnecting sessions.\");\n    }\n    if (!_classPrivateFieldGet(this, _session)) {\n      return Promise.resolve();\n    }\n    const params = {\n      topic: _classPrivateFieldGet(this, _session).topic,\n      reason: {\n        message: \"User disconnected.\",\n        code: 6000\n      }\n    };\n    return _classPrivateFieldGet(this, _wcWallet)?.disconnectSession(params);\n  }\n}\nfunction _setupWalletConnectEventsListeners2() {\n  if (!_classPrivateFieldGet(this, _wcWallet)) {\n    throw new Error(\"Please, init the wallet before making session requests.\");\n  }\n  _classPrivateFieldGet(this, _wcWallet).on(\"session_proposal\", proposal => {\n    _classPrivateFieldSet(this, _activeProposal, proposal);\n    this.emit(\"session_proposal\", {\n      proposer: {\n        metadata: proposal.params.proposer.metadata\n      }\n    });\n  });\n  _classPrivateFieldGet(this, _wcWallet).on(\"session_delete\", session => {\n    _classPrivateFieldSet(this, _session, undefined);\n    _classPrivateFieldSet(this, _activeProposal, undefined);\n    this.emit(\"session_delete\", {\n      topic: session.topic\n    });\n  });\n  _classPrivateFieldGet(this, _wcWallet).on(\"session_request\", async requestEvent => {\n    if (!_classPrivateFieldGet(this, _session)) {\n      return;\n    }\n    const {\n      params: requestParams\n    } = requestEvent;\n    const {\n      request\n    } = requestParams;\n    const {\n      params\n    } = request;\n    switch (request.method) {\n      case EIP155_SIGNING_METHODS.ETH_SIGN:\n      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:\n        _classPrivateFieldSet(this, _activeRequestEvent, requestEvent);\n        const message = params[0];\n        const decodedMessage = new TextDecoder().decode(utils.arrayify(message));\n        const paramsCopy = [...params];\n        paramsCopy[0] = decodedMessage;\n        this.emit(\"session_request\", {\n          topic: _classPrivateFieldGet(this, _session).topic,\n          params: paramsCopy,\n          peer: {\n            metadata: _classPrivateFieldGet(this, _session).peer.metadata\n          },\n          method: request.method\n        });\n        return;\n      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:\n      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:\n        _classPrivateFieldSet(this, _activeRequestEvent, requestEvent);\n        this.emit(\"session_request\", {\n          topic: _classPrivateFieldGet(this, _session).topic,\n          params: requestEvent.params.request.params,\n          peer: {\n            metadata: _classPrivateFieldGet(this, _session).peer.metadata\n          },\n          method: request.method\n        });\n        return;\n      default:\n        throw new Error(`WCV2.Method not supported: ${request.method}`);\n    }\n  });\n}\nfunction _getSignParamsMessage2(params) {\n  const message = params.filter(p => !utils.isAddress(p))[0] || \"\"; // TODO: handle empty message\n\n  if (utils.isHexString(message)) {\n    return utils.toUtf8String(message);\n  }\n  return message;\n}\n\nclass NoOpWalletConnectHandler extends WalletConnectHandler {\n  init() {\n    return Promise.resolve();\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  connectApp(uri) {\n    return Promise.resolve();\n  }\n  approveSession(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  wallet) {\n    return Promise.resolve();\n  }\n  rejectSession() {\n    return Promise.resolve();\n  }\n  approveEIP155Request(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  wallet) {\n    return Promise.resolve();\n  }\n  rejectEIP155Request() {\n    return Promise.resolve();\n  }\n  getActiveSessions() {\n    return [];\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  disconnectSession() {\n    return Promise.resolve();\n  }\n}\n\nconst sdkCache = new Map();\nfunction getSDK(chain) {\n  const cached = sdkCache.get(chain);\n  if (cached) {\n    return cached;\n  }\n  const sdk = new ThirdwebSDK(chain);\n  sdkCache.set(chain, sdk);\n  return sdk;\n}\n\n/**\n * Get all the signers added to the given smart wallet (excluding owner)\n * @param chain\n * @param factoryAddress\n * @param smartWalletAddress\n * @returns\n */\nasync function getAllSigners(chain, factoryAddress, smartWalletAddress) {\n  const readOnlySDK = getSDK(chain);\n  const factoryContract = await readOnlySDK.getContract(factoryAddress);\n  const signers = await factoryContract.call(\"getSignersOfAccount\", [smartWalletAddress]);\n  return signers;\n}\n\n/**\n * Get all the smart wallets associated with a personal wallet address\n * @param chain\n * @param factoryAddress\n * @param personalWalletAddress\n * @returns\n */\nasync function getAllSmartWallets(chain, factoryAddress, personalWalletAddress) {\n  const readOnlySDK = getSDK(chain);\n  const factoryContract = await readOnlySDK.getContract(factoryAddress);\n  const ownedAccount = await getSmartWalletAddress(chain, factoryAddress, personalWalletAddress);\n  const accessibleAccounts = await factoryContract.call(\"getAccountsOfSigner\", [personalWalletAddress]);\n  return {\n    owned: ownedAccount,\n    hasSignerRole: accessibleAccounts\n  };\n}\n\n/**\n * Check if a smart wallet is deployed for a given personal wallet address\n * @param chain\n * @param factoryAddress\n * @param personalWalletAddress\n * @returns\n */\nasync function isSmartWalletDeployed(chain, factoryAddress, personalWalletAddress) {\n  let data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"0x\";\n  const readOnlySDK = getSDK(chain);\n  const factoryContract = await readOnlySDK.getContract(factoryAddress);\n  const accountAddress = await factoryContract.call(\"getAddress\", [personalWalletAddress, data]);\n  const isDeployed = await isContractDeployed(accountAddress, readOnlySDK.getProvider());\n  return isDeployed;\n}\n\n/**\n * Get the associated smart wallet address for a given personal wallet address\n * @param chain\n * @param factoryAddress\n * @param personalWalletAddress\n * @returns\n */\nasync function getSmartWalletAddress(chain, factoryAddress, personalWalletAddress) {\n  let data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"0x\";\n  const readOnlySDK = getSDK(chain);\n  const factoryContract = await readOnlySDK.getContract(factoryAddress);\n  const accountAddress = await factoryContract.call(\"getAddress\", [personalWalletAddress, data]);\n  return accountAddress;\n}\n\nclass SmartWallet extends AbstractClientWallet {\n  get walletName() {\n    return \"Smart Wallet\";\n  }\n  constructor(options) {\n    if (options.clientId && typeof options.chain === \"object\") {\n      try {\n        options.chain = {\n          ...options.chain,\n          rpc: getValidChainRPCs(options.chain, options.clientId)\n        };\n      } catch {}\n    }\n    super(SmartWallet.id, {\n      ...options\n    });\n    _defineProperty(this, \"enableConnectApp\", false);\n    this.enableConnectApp = options?.enableConnectApp || false;\n    this.wcWallet = this.enableConnectApp ? new WalletConnectV2Handler({\n      walletConnectWalletMetadata: options?.walletConnectWalletMetadata,\n      walletConnectV2ProjectId: options?.walletConnectV2ProjectId,\n      walletConnectV2RelayUrl: options?.walletConnectV2RelayUrl\n    }) : new NoOpWalletConnectHandler();\n  }\n  async getConnector() {\n    if (!this.connector) {\n      if (this.enableConnectApp) {\n        await this.wcWallet.init();\n        this.setupWalletConnectEventsListeners();\n      }\n      const {\n        SmartWalletConnector\n      } = await import('../evm/connectors/smart-wallet/dist/thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm.js');\n      this.connector = new SmartWalletConnector(this.options);\n    }\n    return this.connector;\n  }\n  getPersonalWallet() {\n    return this.connector?.personalWallet;\n  }\n\n  /**\n   * Check whether the connected signer can execute a given transaction using the smart wallet.\n   * @param transaction the transaction to execute using the smart wallet.\n   * @returns whether the connected signer can execute the transaction using the smart wallet.\n   */\n  async hasPermissionToExecute(transaction) {\n    const connector = await this.getConnector();\n    return connector.hasPermissionToExecute(transaction);\n  }\n\n  /**\n   * Send a single transaction without waiting for confirmations\n   * @param transactions\n   * @returns the transaction result\n   */\n  async send(transaction) {\n    const connector = await this.getConnector();\n    return connector.send(transaction);\n  }\n\n  /**\n   * Execute a single transaction and wait for confirmations\n   * @param transactions\n   * @returns the transaction receipt\n   */\n  async execute(transaction) {\n    const connector = await this.getConnector();\n    return connector.execute(transaction);\n  }\n\n  /**\n   * Send a multiple transaction in a batch without waiting for confirmations\n   * @param transactions\n   * @returns the transaction result\n   */\n  async sendBatch(transactions) {\n    const connector = await this.getConnector();\n    return connector.sendBatch(transactions);\n  }\n\n  /**\n   * Execute multiple transactions in a single batch and wait for confirmations\n   * @param transactions\n   * @returns the transaction receipt\n   */\n  async executeBatch(transactions) {\n    const connector = await this.getConnector();\n    return connector.executeBatch(transactions);\n  }\n\n  /**\n   * Send a single raw transaction without waiting for confirmations\n   * @param transaction\n   * @returns the transaction result\n   */\n  async sendRaw(transaction) {\n    const connector = await this.getConnector();\n    return connector.sendRaw(transaction);\n  }\n\n  /**\n   * Execute a single raw transaction and wait for confirmations\n   * @param transaction\n   * @returns the transaction receipt\n   */\n  async executeRaw(transaction) {\n    const connector = await this.getConnector();\n    return connector.executeRaw(transaction);\n  }\n\n  /**\n   * Estimate the gas cost of a single transaction\n   * @param transaction\n   * @returns\n   */\n  async estimate(transaction) {\n    const connector = await this.getConnector();\n    return connector.estimate(transaction);\n  }\n\n  /**\n   * Estimate the gas cost of a batch of transactions\n   * @param transaction\n   * @returns\n   */\n  async estimateBatch(transactions) {\n    const connector = await this.getConnector();\n    return connector.estimateBatch(transactions);\n  }\n\n  /**\n   * Estimate the gas cost of a single raw transaction\n   * @param transaction\n   * @returns\n   */\n  async estimateRaw(transactions) {\n    const connector = await this.getConnector();\n    return connector.estimateRaw(transactions);\n  }\n\n  /**\n   * Estimate the gas cost of a batch of raw transactions\n   * @param transaction\n   * @returns\n   */\n  async estimateBatchRaw(transactions) {\n    const connector = await this.getConnector();\n    return connector.estimateBatchRaw(transactions);\n  }\n\n  /**\n   * Send multiple raw transaction in a batch without waiting for confirmations\n   * @param transaction\n   * @returns the transaction result\n   */\n  async sendBatchRaw(transactions) {\n    const connector = await this.getConnector();\n    return connector.sendBatchRaw(transactions);\n  }\n\n  /**\n   * Execute multiple raw transactions in a single batch and wait for confirmations\n   * @param transaction\n   * @returns the transaction receipt\n   */\n  async executeBatchRaw(transactions) {\n    const connector = await this.getConnector();\n    return connector.executeBatchRaw(transactions);\n  }\n\n  /**\n   * Manually deploy the smart wallet contract. If already deployed this will throw an error.\n   * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.\n   * @returns the transaction receipt\n   */\n  async deploy() {\n    const connector = await this.getConnector();\n    return connector.deploy();\n  }\n\n  /**\n   * Manually deploy the smart wallet contract. If already deployed this will do nothing.\n   * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.\n   * @returns the transaction receipt\n   */\n  async deployIfNeeded() {\n    const connector = await this.getConnector();\n    return connector.deployIfNeeded();\n  }\n\n  /**\n   * Check if the smart wallet contract is deployed\n   * @returns true if the smart wallet contract is deployed\n   */\n  async isDeployed() {\n    const connector = await this.getConnector();\n    return connector.isDeployed();\n  }\n\n  /**\n   * Create and add a session key to the smart wallet.\n   * @param keyAddress the address of the session key to add.\n   * @param permissions the permissions to grant to the session key.\n   */\n  async createSessionKey(keyAddress, permissions) {\n    const connector = await this.getConnector();\n    return connector.grantPermissions(keyAddress, permissions);\n  }\n\n  /**\n   * Remove a session key from the smart wallet.\n   * @param keyAddress the address of the session key to remove.\n   */\n  async revokeSessionKey(keyAddress) {\n    const connector = await this.getConnector();\n    return connector.revokePermissions(keyAddress);\n  }\n\n  /**\n   * Add another admin to the smart wallet.\n   * @param adminAddress the address of the admin to add.\n   */\n  async addAdmin(adminAddress) {\n    const connector = await this.getConnector();\n    return connector.addAdmin(adminAddress);\n  }\n\n  /**\n   * Remove an admin from the smart wallet.\n   * @param adminAddress the address of the admin to remove.\n   */\n  async removeAdmin(adminAddress) {\n    const connector = await this.getConnector();\n    return connector.removeAdmin(adminAddress);\n  }\n\n  /**\n   * Get all the admins and session keys active on the smart wallet.\n   */\n  async getAllActiveSigners() {\n    const connector = await this.getConnector();\n    return connector.getAllActiveSigners();\n  }\n\n  /**\n   * Get the underlying account contract of the smart wallet.\n   * @returns the account contract of the smart wallet.\n   */\n  async getAccountContract() {\n    const connector = await this.getConnector();\n    return connector.getAccountContract();\n  }\n\n  /**\n   * Get the underlying account factory contract of the smart wallet.\n   * @returns the account factory contract.\n   */\n  async getFactoryContract() {\n    const connector = await this.getConnector();\n    return connector.getFactoryContract();\n  }\n  autoConnect(params) {\n    return this.connect(params);\n  }\n\n  // wcv2\n  async connectApp(uri) {\n    if (!this.enableConnectApp) {\n      throw new Error(\"enableConnectApp is set to false in this wallet config\");\n    }\n    this.wcWallet?.connectApp(uri);\n  }\n  async approveSession() {\n    await this.wcWallet.approveSession(this);\n    this.emit(\"message\", {\n      type: \"session_approved\"\n    });\n  }\n  rejectSession() {\n    return this.wcWallet.rejectSession();\n  }\n  approveRequest() {\n    return this.wcWallet.approveEIP155Request(this);\n  }\n  rejectRequest() {\n    return this.wcWallet.rejectEIP155Request();\n  }\n  getActiveSessions() {\n    if (!this.wcWallet) {\n      throw new Error(\"Please, init the wallet before making session requests.\");\n    }\n    return this.wcWallet.getActiveSessions();\n  }\n  disconnectSession() {\n    return this.wcWallet?.disconnectSession();\n  }\n  isWCReceiverEnabled() {\n    return this.enableConnectApp;\n  }\n  setupWalletConnectEventsListeners() {\n    if (!this.wcWallet) {\n      throw new Error(\"Please, init the wallet before making session requests.\");\n    }\n    this.wcWallet.on(\"session_proposal\", proposal => {\n      this.emit(\"message\", {\n        type: \"session_proposal\",\n        data: proposal\n      });\n    });\n    this.wcWallet.on(\"session_delete\", () => {\n      this.emit(\"message\", {\n        type: \"session_delete\"\n      });\n    });\n    this.wcWallet.on(\"switch_chain\", request => {\n      const chainId = request.params[0].chainId;\n      this.emit(\"message\", {\n        type: \"switch_chain\",\n        data: {\n          chainId\n        }\n      });\n      this.wcWallet.disconnectSession();\n    });\n    this.wcWallet.on(\"session_request\", request => {\n      this.emit(\"message\", {\n        type: \"session_request\",\n        data: request\n      });\n    });\n  }\n}\n_defineProperty(SmartWallet, \"meta\", {\n  name: \"Smart Wallet\",\n  iconURL: \"ipfs://QmeAJVqn17aDNQhjEU3kcWVZCFBrfta8LzaDGkS8Egdiyk/smart-wallet.svg\"\n});\n_defineProperty(SmartWallet, \"id\", walletIds.smartWallet);\n\nexport { SmartWallet as S, WalletConnectV2Handler as W, WalletConnectHandler as a, getAllSmartWallets as b, getSmartWalletAddress as c, getAllSigners as g, isSmartWalletDeployed as i };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}