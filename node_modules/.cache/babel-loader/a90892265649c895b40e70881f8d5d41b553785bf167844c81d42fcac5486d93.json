{"ast":null,"code":"import { _ as _classPrivateMethodInitSpec, a as _classPrivateMethodGet } from '../../../../dist/classPrivateMethodGet-ea199cc3.browser.esm.js';\nimport { _ as _defineProperty } from '../../../../dist/defineProperty-c8ecdc07.browser.esm.js';\nimport { _ as _classPrivateFieldInitSpec, a as _classPrivateFieldSet, b as _classPrivateFieldGet } from '../../../../dist/classPrivateFieldSet-a5db7c83.browser.esm.js';\nimport { w as walletIds } from '../../../../dist/walletIds-e41b240b.browser.esm.js';\nimport { a as AbstractClientWallet, c as createAsyncLocalStorage } from '../../../../dist/base-eec23f27.browser.esm.js';\nimport { updateChainRPCs, defaultChains, Ethereum } from '@thirdweb-dev/chains';\nimport { utils, Wallet } from 'ethers';\nimport '../../abstract/dist/thirdweb-dev-wallets-evm-wallets-abstract.browser.esm.js';\nimport 'eventemitter3';\nimport '@thirdweb-dev/sdk';\n\n// eslint-disable-next-line @typescript-eslint/ban-types\n\nconst STORAGE_KEY_WALLET_DATA = \"localWalletData\";\nvar _storage2 = /*#__PURE__*/new WeakMap();\nvar _saveData = /*#__PURE__*/new WeakSet();\nclass LocalWallet extends AbstractClientWallet {\n  get walletName() {\n    return \"Local Wallet\";\n  }\n  constructor(options) {\n    super(LocalWallet.id, options);\n    /**\n     * store the wallet data to storage\n     */\n    _classPrivateMethodInitSpec(this, _saveData);\n    _classPrivateFieldInitSpec(this, _storage2, {\n      writable: true,\n      value: void 0\n    });\n    if (options?.chain && options.clientId) {\n      options.chain = updateChainRPCs(options.chain, options.clientId);\n    }\n    this.options = options || {};\n    _classPrivateFieldSet(this, _storage2, options?.storage || createAsyncLocalStorage(walletIds.localWallet));\n  }\n  async getConnector() {\n    if (!this.connector) {\n      const {\n        LocalWalletConnector: LocalWalletConnector\n      } = await import('../../../connectors/local-wallet/dist/thirdweb-dev-wallets-evm-connectors-local-wallet.browser.esm.js');\n      if (!this.ethersWallet) {\n        throw new Error(\"wallet is not initialized\");\n      }\n      const defaults = (this.options.chain ? [...defaultChains, this.options.chain] : defaultChains).map(c => updateChainRPCs(c, this.options.clientId));\n      this.connector = new LocalWalletConnector({\n        chain: this.options.chain || updateChainRPCs(Ethereum, this.options.clientId),\n        ethersWallet: this.ethersWallet,\n        chains: this.chains || defaults,\n        clientId: this.options.clientId,\n        secretKey: this.options.secretKey\n      });\n    }\n    return this.connector;\n  }\n\n  /**\n   * load saved wallet data from storage or generate a new one and save it.\n   */\n  async loadOrCreate(options) {\n    if (await this.getSavedData(options.storage)) {\n      await this.load(options);\n    } else {\n      await this.generate();\n      await this.save(options);\n    }\n  }\n\n  /**\n   * creates a new random wallet\n   * @returns the address of the newly created wallet\n   */\n  async generate() {\n    if (this.ethersWallet) {\n      throw new Error(\"wallet is already initialized\");\n    }\n    const random = utils.randomBytes(32);\n    this.ethersWallet = new Wallet(random);\n    return this.ethersWallet.address;\n  }\n\n  /**\n   * create local wallet from an \"encryptedJson\", \"privateKey\" or \"mnemonic\"\n   * @returns\n   */\n  async import(options) {\n    if (this.ethersWallet) {\n      throw new Error(\"wallet is already initialized\");\n    }\n    if (\"encryptedJson\" in options) {\n      this.ethersWallet = await Wallet.fromEncryptedJson(options.encryptedJson, options.password);\n      return this.ethersWallet.address;\n    }\n    if (\"privateKey\" in options) {\n      if (!options.encryption && !isValidPrivateKey(options.privateKey)) {\n        throw new Error(\"invalid private key\");\n      }\n      const privateKey = await getDecryptor(options.encryption)(options.privateKey);\n      if (options.encryption && (privateKey === \"\" || !isValidPrivateKey(privateKey))) {\n        throw new Error(\"invalid password\");\n      }\n      this.ethersWallet = new Wallet(privateKey);\n      return this.ethersWallet.address;\n    }\n    if (\"mnemonic\" in options) {\n      if (!options.encryption && !utils.isValidMnemonic(options.mnemonic)) {\n        throw new Error(\"invalid mnemonic\");\n      }\n      const mnemonic = await getDecryptor(options.encryption)(options.mnemonic);\n      if (options.encryption && (mnemonic === \"\" || !utils.isValidMnemonic(mnemonic))) {\n        throw new Error(\"invalid password\");\n      }\n      this.ethersWallet = Wallet.fromMnemonic(mnemonic);\n      return this.ethersWallet.address;\n    }\n    throw new Error(\"invalid import strategy\");\n  }\n\n  /**\n   * initialize the wallet from saved data on storage\n   * @param password - password used for encrypting the wallet\n   */\n  async load(options) {\n    if (this.ethersWallet) {\n      throw new Error(\"wallet is already initialized\");\n    }\n    const walletData = await this.getSavedData(options.storage);\n    if (!walletData) {\n      throw new Error(\"No Saved wallet found in storage\");\n    }\n\n    // strategy mismatch\n    if (walletData.strategy !== options.strategy) {\n      throw new Error(`Saved wallet data is not ${options.strategy}, it is ${walletData.strategy}`);\n    }\n    if (options.strategy === \"encryptedJson\") {\n      return this.import({\n        encryptedJson: walletData.data,\n        password: options.password\n      });\n    }\n\n    // encryption mismatch\n    if (walletData.isEncrypted && !options.encryption) {\n      throw new Error(\"Saved wallet data is encrypted, but no password is provided\");\n    }\n    if (!walletData.isEncrypted && options.encryption) {\n      throw new Error(\"Saved wallet data is not encrypted, but encryption config is provided\");\n    }\n    if (options.strategy === \"privateKey\") {\n      return this.import({\n        privateKey: walletData.data,\n        encryption: options.encryption\n      });\n    }\n    if (options.strategy === \"mnemonic\") {\n      return this.import({\n        mnemonic: walletData.data,\n        encryption: options.encryption\n      });\n    }\n    throw new Error(\"invalid load strategy\");\n  }\n\n  /**\n   * Save the wallet data to storage\n   */\n  async save(options) {\n    const wallet = this.ethersWallet;\n    if (!wallet) {\n      throw new Error(\"Wallet is not initialized\");\n    }\n    if (options.strategy === \"encryptedJson\") {\n      const encryptedData = await wallet.encrypt(options.password, {\n        scrypt: {\n          N: 1 << 32\n        }\n      });\n      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {\n        address: wallet.address,\n        data: encryptedData,\n        strategy: \"encryptedJson\",\n        isEncrypted: true\n      }, options.storage);\n    }\n    if (options.strategy === \"privateKey\") {\n      const privateKey = await getEncryptor(options.encryption)(wallet.privateKey);\n      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {\n        address: wallet.address,\n        data: privateKey,\n        strategy: \"privateKey\",\n        isEncrypted: !!options.encryption\n      }, options.storage);\n    }\n    if (options.strategy === \"mnemonic\") {\n      if (!wallet.mnemonic) {\n        throw new Error(\"mnemonic can not be computed if wallet is created from a private key or generated using generate()\");\n      }\n      const mnemonic = await getEncryptor(options.encryption)(wallet.mnemonic.phrase);\n      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {\n        address: wallet.address,\n        data: mnemonic,\n        strategy: \"mnemonic\",\n        isEncrypted: !!options.encryption\n      }, options.storage);\n    }\n  }\n\n  /**\n   * @returns true if initialized wallet's data is saved in storage\n   */\n  async isSaved() {\n    try {\n      const data = await this.getSavedData();\n      const address = await this.getAddress();\n      if (data?.address === address) {\n        return true;\n      }\n      return false;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * deletes the saved wallet data from storage\n   */\n  async deleteSaved() {\n    await _classPrivateFieldGet(this, _storage2).removeItem(STORAGE_KEY_WALLET_DATA);\n  }\n\n  /**\n   * encrypts the wallet with given password and returns the encrypted wallet\n   * @param password - password for encrypting the wallet data\n   */\n  async export(options) {\n    const wallet = this.ethersWallet;\n    if (!wallet) {\n      throw new Error(\"Wallet is not initialized\");\n    }\n    if (options.strategy === \"encryptedJson\") {\n      return wallet.encrypt(options.password, {\n        scrypt: {\n          N: 1 << 32\n        }\n      });\n    }\n    if (options.strategy === \"privateKey\") {\n      return getEncryptor(options.encryption)(wallet.privateKey);\n    }\n    if (options.strategy === \"mnemonic\") {\n      if (!wallet.mnemonic) {\n        throw new Error(\"mnemonic can not be computed if wallet is created from a private key or generated using generate()\");\n      }\n      return getEncryptor(options.encryption)(wallet.mnemonic.phrase);\n    }\n    throw new Error(\"Invalid export strategy\");\n  }\n\n  /**\n   * Get the saved wallet data from storage\n   */\n  async getSavedData(storage) {\n    const _storage = storage || _classPrivateFieldGet(this, _storage2);\n    try {\n      const savedDataStr = await _storage.getItem(STORAGE_KEY_WALLET_DATA);\n      if (!savedDataStr) {\n        return null;\n      }\n      const savedData = JSON.parse(savedDataStr);\n      if (!savedData) {\n        return null;\n      }\n      return savedData;\n    } catch (e) {\n      return null;\n    }\n  }\n  async disconnect() {\n    await super.disconnect();\n    this.ethersWallet = undefined;\n  }\n}\nasync function _saveData2(data, storage) {\n  const _storage = storage || _classPrivateFieldGet(this, _storage2);\n  await _storage.setItem(STORAGE_KEY_WALLET_DATA, JSON.stringify(data));\n}\n_defineProperty(LocalWallet, \"id\", walletIds.localWallet);\n_defineProperty(LocalWallet, \"meta\", {\n  name: \"Local Wallet\",\n  iconURL: \"ipfs://QmbQzSNGvmNYZzem9jZRuYeLe9K2W4pqbdnVUp7Y6edQ8Y/local-wallet.svg\"\n}); // omit the mnemonic strategy option from LoadOptions\nasync function defaultEncrypt(message, password) {\n  const cryptoJS = (await import('crypto-js')).default;\n  return cryptoJS.AES.encrypt(message, password).toString();\n}\nasync function defaultDecrypt(message, password) {\n  const cryptoJS = (await import('crypto-js')).default;\n  return cryptoJS.AES.decrypt(message, password).toString(cryptoJS.enc.Utf8);\n}\n\n/**\n * if encryption object is provided\n *  - return the encryption.decrypt function if given, else return the default decrypt function\n * if encryption object is not provided\n * - return a noop function\n * @returns\n */\nfunction getDecryptor(encryption) {\n  const noop = async msg => msg;\n  return encryption ? msg => (encryption.decrypt || defaultDecrypt)(msg, encryption.password) : noop;\n}\n\n/**\n * if encryption object is provided\n *  - return the encryption.encrypt function if given, else return the default encrypt function\n * if encryption object is not provided\n * - return a noop function\n * @returns\n */\nfunction getEncryptor(encryption) {\n  const noop = async msg => msg;\n  return encryption ? msg => (encryption.encrypt || defaultEncrypt)(msg, encryption.password) : noop;\n}\nfunction isValidPrivateKey(value) {\n  return !!value.match(/^(0x)?[0-9a-f]{64}$/i);\n}\nexport { LocalWallet, isValidPrivateKey };","map":{"version":3,"names":["_","_classPrivateMethodInitSpec","a","_classPrivateMethodGet","_defineProperty","_classPrivateFieldInitSpec","_classPrivateFieldSet","b","_classPrivateFieldGet","w","walletIds","AbstractClientWallet","c","createAsyncLocalStorage","updateChainRPCs","defaultChains","Ethereum","utils","Wallet","STORAGE_KEY_WALLET_DATA","_storage2","WeakMap","_saveData","WeakSet","LocalWallet","walletName","constructor","options","id","writable","value","chain","clientId","storage","localWallet","getConnector","connector","LocalWalletConnector","ethersWallet","Error","defaults","map","chains","secretKey","loadOrCreate","getSavedData","load","generate","save","random","randomBytes","address","import","fromEncryptedJson","encryptedJson","password","encryption","isValidPrivateKey","privateKey","getDecryptor","isValidMnemonic","mnemonic","fromMnemonic","walletData","strategy","data","isEncrypted","wallet","encryptedData","encrypt","scrypt","N","_saveData2","call","getEncryptor","phrase","isSaved","getAddress","e","deleteSaved","removeItem","export","_storage","savedDataStr","getItem","savedData","JSON","parse","disconnect","undefined","setItem","stringify","name","iconURL","defaultEncrypt","message","cryptoJS","default","AES","toString","defaultDecrypt","decrypt","enc","Utf8","noop","msg","match"],"sources":["C:/Users/SUMAN K/meta_transfer/node_modules/@thirdweb-dev/wallets/evm/wallets/local-wallet/dist/thirdweb-dev-wallets-evm-wallets-local-wallet.browser.esm.js"],"sourcesContent":["import { _ as _classPrivateMethodInitSpec, a as _classPrivateMethodGet } from '../../../../dist/classPrivateMethodGet-ea199cc3.browser.esm.js';\nimport { _ as _defineProperty } from '../../../../dist/defineProperty-c8ecdc07.browser.esm.js';\nimport { _ as _classPrivateFieldInitSpec, a as _classPrivateFieldSet, b as _classPrivateFieldGet } from '../../../../dist/classPrivateFieldSet-a5db7c83.browser.esm.js';\nimport { w as walletIds } from '../../../../dist/walletIds-e41b240b.browser.esm.js';\nimport { a as AbstractClientWallet, c as createAsyncLocalStorage } from '../../../../dist/base-eec23f27.browser.esm.js';\nimport { updateChainRPCs, defaultChains, Ethereum } from '@thirdweb-dev/chains';\nimport { utils, Wallet } from 'ethers';\nimport '../../abstract/dist/thirdweb-dev-wallets-evm-wallets-abstract.browser.esm.js';\nimport 'eventemitter3';\nimport '@thirdweb-dev/sdk';\n\n// eslint-disable-next-line @typescript-eslint/ban-types\n\nconst STORAGE_KEY_WALLET_DATA = \"localWalletData\";\nvar _storage2 = /*#__PURE__*/new WeakMap();\nvar _saveData = /*#__PURE__*/new WeakSet();\nclass LocalWallet extends AbstractClientWallet {\n  get walletName() {\n    return \"Local Wallet\";\n  }\n  constructor(options) {\n    super(LocalWallet.id, options);\n    /**\n     * store the wallet data to storage\n     */\n    _classPrivateMethodInitSpec(this, _saveData);\n    _classPrivateFieldInitSpec(this, _storage2, {\n      writable: true,\n      value: void 0\n    });\n    if (options?.chain && options.clientId) {\n      options.chain = updateChainRPCs(options.chain, options.clientId);\n    }\n    this.options = options || {};\n    _classPrivateFieldSet(this, _storage2, options?.storage || createAsyncLocalStorage(walletIds.localWallet));\n  }\n  async getConnector() {\n    if (!this.connector) {\n      const {\n        LocalWalletConnector: LocalWalletConnector\n      } = await import('../../../connectors/local-wallet/dist/thirdweb-dev-wallets-evm-connectors-local-wallet.browser.esm.js');\n      if (!this.ethersWallet) {\n        throw new Error(\"wallet is not initialized\");\n      }\n      const defaults = (this.options.chain ? [...defaultChains, this.options.chain] : defaultChains).map(c => updateChainRPCs(c, this.options.clientId));\n      this.connector = new LocalWalletConnector({\n        chain: this.options.chain || updateChainRPCs(Ethereum, this.options.clientId),\n        ethersWallet: this.ethersWallet,\n        chains: this.chains || defaults,\n        clientId: this.options.clientId,\n        secretKey: this.options.secretKey\n      });\n    }\n    return this.connector;\n  }\n\n  /**\n   * load saved wallet data from storage or generate a new one and save it.\n   */\n  async loadOrCreate(options) {\n    if (await this.getSavedData(options.storage)) {\n      await this.load(options);\n    } else {\n      await this.generate();\n      await this.save(options);\n    }\n  }\n\n  /**\n   * creates a new random wallet\n   * @returns the address of the newly created wallet\n   */\n  async generate() {\n    if (this.ethersWallet) {\n      throw new Error(\"wallet is already initialized\");\n    }\n    const random = utils.randomBytes(32);\n    this.ethersWallet = new Wallet(random);\n    return this.ethersWallet.address;\n  }\n\n  /**\n   * create local wallet from an \"encryptedJson\", \"privateKey\" or \"mnemonic\"\n   * @returns\n   */\n  async import(options) {\n    if (this.ethersWallet) {\n      throw new Error(\"wallet is already initialized\");\n    }\n    if (\"encryptedJson\" in options) {\n      this.ethersWallet = await Wallet.fromEncryptedJson(options.encryptedJson, options.password);\n      return this.ethersWallet.address;\n    }\n    if (\"privateKey\" in options) {\n      if (!options.encryption && !isValidPrivateKey(options.privateKey)) {\n        throw new Error(\"invalid private key\");\n      }\n      const privateKey = await getDecryptor(options.encryption)(options.privateKey);\n      if (options.encryption && (privateKey === \"\" || !isValidPrivateKey(privateKey))) {\n        throw new Error(\"invalid password\");\n      }\n      this.ethersWallet = new Wallet(privateKey);\n      return this.ethersWallet.address;\n    }\n    if (\"mnemonic\" in options) {\n      if (!options.encryption && !utils.isValidMnemonic(options.mnemonic)) {\n        throw new Error(\"invalid mnemonic\");\n      }\n      const mnemonic = await getDecryptor(options.encryption)(options.mnemonic);\n      if (options.encryption && (mnemonic === \"\" || !utils.isValidMnemonic(mnemonic))) {\n        throw new Error(\"invalid password\");\n      }\n      this.ethersWallet = Wallet.fromMnemonic(mnemonic);\n      return this.ethersWallet.address;\n    }\n    throw new Error(\"invalid import strategy\");\n  }\n\n  /**\n   * initialize the wallet from saved data on storage\n   * @param password - password used for encrypting the wallet\n   */\n  async load(options) {\n    if (this.ethersWallet) {\n      throw new Error(\"wallet is already initialized\");\n    }\n    const walletData = await this.getSavedData(options.storage);\n    if (!walletData) {\n      throw new Error(\"No Saved wallet found in storage\");\n    }\n\n    // strategy mismatch\n    if (walletData.strategy !== options.strategy) {\n      throw new Error(`Saved wallet data is not ${options.strategy}, it is ${walletData.strategy}`);\n    }\n    if (options.strategy === \"encryptedJson\") {\n      return this.import({\n        encryptedJson: walletData.data,\n        password: options.password\n      });\n    }\n\n    // encryption mismatch\n    if (walletData.isEncrypted && !options.encryption) {\n      throw new Error(\"Saved wallet data is encrypted, but no password is provided\");\n    }\n    if (!walletData.isEncrypted && options.encryption) {\n      throw new Error(\"Saved wallet data is not encrypted, but encryption config is provided\");\n    }\n    if (options.strategy === \"privateKey\") {\n      return this.import({\n        privateKey: walletData.data,\n        encryption: options.encryption\n      });\n    }\n    if (options.strategy === \"mnemonic\") {\n      return this.import({\n        mnemonic: walletData.data,\n        encryption: options.encryption\n      });\n    }\n    throw new Error(\"invalid load strategy\");\n  }\n\n  /**\n   * Save the wallet data to storage\n   */\n  async save(options) {\n    const wallet = this.ethersWallet;\n    if (!wallet) {\n      throw new Error(\"Wallet is not initialized\");\n    }\n    if (options.strategy === \"encryptedJson\") {\n      const encryptedData = await wallet.encrypt(options.password, {\n        scrypt: {\n          N: 1 << 32\n        }\n      });\n      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {\n        address: wallet.address,\n        data: encryptedData,\n        strategy: \"encryptedJson\",\n        isEncrypted: true\n      }, options.storage);\n    }\n    if (options.strategy === \"privateKey\") {\n      const privateKey = await getEncryptor(options.encryption)(wallet.privateKey);\n      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {\n        address: wallet.address,\n        data: privateKey,\n        strategy: \"privateKey\",\n        isEncrypted: !!options.encryption\n      }, options.storage);\n    }\n    if (options.strategy === \"mnemonic\") {\n      if (!wallet.mnemonic) {\n        throw new Error(\"mnemonic can not be computed if wallet is created from a private key or generated using generate()\");\n      }\n      const mnemonic = await getEncryptor(options.encryption)(wallet.mnemonic.phrase);\n      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {\n        address: wallet.address,\n        data: mnemonic,\n        strategy: \"mnemonic\",\n        isEncrypted: !!options.encryption\n      }, options.storage);\n    }\n  }\n\n  /**\n   * @returns true if initialized wallet's data is saved in storage\n   */\n  async isSaved() {\n    try {\n      const data = await this.getSavedData();\n      const address = await this.getAddress();\n      if (data?.address === address) {\n        return true;\n      }\n      return false;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * deletes the saved wallet data from storage\n   */\n  async deleteSaved() {\n    await _classPrivateFieldGet(this, _storage2).removeItem(STORAGE_KEY_WALLET_DATA);\n  }\n\n  /**\n   * encrypts the wallet with given password and returns the encrypted wallet\n   * @param password - password for encrypting the wallet data\n   */\n  async export(options) {\n    const wallet = this.ethersWallet;\n    if (!wallet) {\n      throw new Error(\"Wallet is not initialized\");\n    }\n    if (options.strategy === \"encryptedJson\") {\n      return wallet.encrypt(options.password, {\n        scrypt: {\n          N: 1 << 32\n        }\n      });\n    }\n    if (options.strategy === \"privateKey\") {\n      return getEncryptor(options.encryption)(wallet.privateKey);\n    }\n    if (options.strategy === \"mnemonic\") {\n      if (!wallet.mnemonic) {\n        throw new Error(\"mnemonic can not be computed if wallet is created from a private key or generated using generate()\");\n      }\n      return getEncryptor(options.encryption)(wallet.mnemonic.phrase);\n    }\n    throw new Error(\"Invalid export strategy\");\n  }\n\n  /**\n   * Get the saved wallet data from storage\n   */\n  async getSavedData(storage) {\n    const _storage = storage || _classPrivateFieldGet(this, _storage2);\n    try {\n      const savedDataStr = await _storage.getItem(STORAGE_KEY_WALLET_DATA);\n      if (!savedDataStr) {\n        return null;\n      }\n      const savedData = JSON.parse(savedDataStr);\n      if (!savedData) {\n        return null;\n      }\n      return savedData;\n    } catch (e) {\n      return null;\n    }\n  }\n  async disconnect() {\n    await super.disconnect();\n    this.ethersWallet = undefined;\n  }\n}\nasync function _saveData2(data, storage) {\n  const _storage = storage || _classPrivateFieldGet(this, _storage2);\n  await _storage.setItem(STORAGE_KEY_WALLET_DATA, JSON.stringify(data));\n}\n_defineProperty(LocalWallet, \"id\", walletIds.localWallet);\n_defineProperty(LocalWallet, \"meta\", {\n  name: \"Local Wallet\",\n  iconURL: \"ipfs://QmbQzSNGvmNYZzem9jZRuYeLe9K2W4pqbdnVUp7Y6edQ8Y/local-wallet.svg\"\n}); // omit the mnemonic strategy option from LoadOptions\nasync function defaultEncrypt(message, password) {\n  const cryptoJS = (await import('crypto-js')).default;\n  return cryptoJS.AES.encrypt(message, password).toString();\n}\nasync function defaultDecrypt(message, password) {\n  const cryptoJS = (await import('crypto-js')).default;\n  return cryptoJS.AES.decrypt(message, password).toString(cryptoJS.enc.Utf8);\n}\n\n/**\n * if encryption object is provided\n *  - return the encryption.decrypt function if given, else return the default decrypt function\n * if encryption object is not provided\n * - return a noop function\n * @returns\n */\nfunction getDecryptor(encryption) {\n  const noop = async msg => msg;\n  return encryption ? msg => (encryption.decrypt || defaultDecrypt)(msg, encryption.password) : noop;\n}\n\n/**\n * if encryption object is provided\n *  - return the encryption.encrypt function if given, else return the default encrypt function\n * if encryption object is not provided\n * - return a noop function\n * @returns\n */\nfunction getEncryptor(encryption) {\n  const noop = async msg => msg;\n  return encryption ? msg => (encryption.encrypt || defaultEncrypt)(msg, encryption.password) : noop;\n}\nfunction isValidPrivateKey(value) {\n  return !!value.match(/^(0x)?[0-9a-f]{64}$/i);\n}\n\nexport { LocalWallet, isValidPrivateKey };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}