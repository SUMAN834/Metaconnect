{"ast":null,"code":"import { _ as _defineProperty } from '../../../../dist/defineProperty-c8ecdc07.browser.esm.js';\nimport { _ as _classPrivateFieldInitSpec, a as _classPrivateFieldSet, b as _classPrivateFieldGet } from '../../../../dist/classPrivateFieldSet-a5db7c83.browser.esm.js';\nimport { a as assertWindowEthereum } from '../../../../dist/assertWindowEthereum-b48c1686.browser.esm.js';\nimport { g as getValidPublicRPCUrl } from '../../../../dist/url-bc88b2b6.browser.esm.js';\nimport { utils, providers } from 'ethers';\nimport { W as WagmiConnector } from '../../../../dist/WagmiConnector-2f14002d.browser.esm.js';\nimport { n as normalizeChainId } from '../../../../dist/normalizeChainId-e4cc0175.browser.esm.js';\nimport { a as ConnectorNotFoundError, U as UserRejectedRequestError, R as ResourceUnavailableError, C as ChainNotConfiguredError, A as AddChainError, S as SwitchChainError } from '../../../../dist/errors-d961f852.browser.esm.js';\nimport '@thirdweb-dev/chains';\nimport 'eventemitter3';\nfunction getInjectedName(ethereum) {\n  if (!ethereum) {\n    return \"Injected\";\n  }\n  const getName = provider => {\n    if (provider.isAvalanche) {\n      return \"Core Wallet\";\n    }\n    if (provider.isBitKeep) {\n      return \"BitKeep\";\n    }\n    if (provider.isBraveWallet) {\n      return \"Brave Wallet\";\n    }\n    if (provider.isCoinbaseWallet) {\n      return \"Coinbase Wallet\";\n    }\n    if (provider.isExodus) {\n      return \"Exodus\";\n    }\n    if (provider.isFrame) {\n      return \"Frame\";\n    }\n    if (provider.isKuCoinWallet) {\n      return \"KuCoin Wallet\";\n    }\n    if (provider.isMathWallet) {\n      return \"MathWallet\";\n    }\n    if (provider.isOneInchIOSWallet || provider.isOneInchAndroidWallet) {\n      return \"1inch Wallet\";\n    }\n    if (provider.isOpera) {\n      return \"Opera\";\n    }\n    if (provider.isPortal) {\n      return \"Ripio Portal\";\n    }\n    if (provider.isTally) {\n      return \"Tally\";\n    }\n    if (provider.isTokenPocket) {\n      return \"TokenPocket\";\n    }\n    if (provider.isTokenary) {\n      return \"Tokenary\";\n    }\n    if (provider.isTrust || provider.isTrustWallet) {\n      return \"Trust Wallet\";\n    }\n    if (provider.isMetaMask) {\n      return \"MetaMask\";\n    }\n  };\n\n  // Some injected providers detect multiple other providers and create a list at `ethers.providers`\n  if (ethereum.providers?.length) {\n    // Deduplicate names using Set\n    // Coinbase Wallet puts multiple providers in `ethereum.providers`\n    const nameSet = new Set();\n    let unknownCount = 1;\n    for (const provider of ethereum.providers) {\n      let name = getName(provider);\n      if (!name) {\n        name = `Unknown Wallet #${unknownCount}`;\n        unknownCount += 1;\n      }\n      nameSet.add(name);\n    }\n    const names = [...nameSet];\n    if (names.length) {\n      return names;\n    }\n    return names[0] ?? \"Injected\";\n  }\n  return getName(ethereum) ?? \"Injected\";\n}\nvar _provider = /*#__PURE__*/new WeakMap();\nclass InjectedConnector extends WagmiConnector {\n  constructor(arg) {\n    const defaultOptions = {\n      shimDisconnect: true,\n      getProvider: () => {\n        if (assertWindowEthereum(globalThis.window)) {\n          return globalThis.window.ethereum;\n        }\n      }\n    };\n    const options = {\n      ...defaultOptions,\n      ...arg.options\n    };\n    super({\n      chains: arg.chains,\n      options\n    });\n    /**\n     * Name of the injected connector\n     */\n    /**\n     * Whether the connector is ready to be used\n     *\n     * `true` if the injected provider is found\n     */\n    _classPrivateFieldInitSpec(this, _provider, {\n      writable: true,\n      value: void 0\n    });\n    _defineProperty(this, \"shimDisconnectKey\", \"injected.shimDisconnect\");\n    /**\n     * handles the `accountsChanged` event from the provider\n     * * emits `change` event if connected to a different account\n     * * emits `disconnect` event if no accounts available\n     */\n    _defineProperty(this, \"onAccountsChanged\", async accounts => {\n      if (accounts.length === 0) {\n        this.emit(\"disconnect\");\n      } else {\n        this.emit(\"change\", {\n          account: utils.getAddress(accounts[0])\n        });\n      }\n    });\n    /**\n     * handles the `chainChanged` event from the provider\n     * * emits `change` event if connected to a different chain\n     */\n    _defineProperty(this, \"onChainChanged\", chainId => {\n      const id = normalizeChainId(chainId);\n      const unsupported = this.isChainUnsupported(id);\n      this.emit(\"change\", {\n        chain: {\n          id,\n          unsupported\n        }\n      });\n    });\n    /**\n     * handles the `disconnect` event from the provider\n     * * emits `disconnect` event\n     */\n    _defineProperty(this, \"onDisconnect\", async error => {\n      // We need this as MetaMask can emit the \"disconnect\" event upon switching chains.\n      // If MetaMask emits a `code: 1013` error, wait for reconnection before disconnecting\n      // https://github.com/MetaMask/providers/pull/120\n      if (error.code === 1013) {\n        const provider = await this.getProvider();\n        if (provider) {\n          try {\n            const isAuthorized = await this.getAccount();\n            if (isAuthorized) {\n              return;\n            }\n          } catch {\n            // If we can't get the account anymore, continue with disconnect\n          }\n        }\n      }\n      this.emit(\"disconnect\");\n\n      // Remove `shimDisconnect` => it signals that wallet is disconnected\n      if (this.options.shimDisconnect) {\n        await this.connectorStorage.removeItem(this.shimDisconnectKey);\n      }\n    });\n    const _provider2 = options.getProvider();\n\n    // set the name of the connector\n    if (typeof options.name === \"string\") {\n      // if name is given, use that\n      this.name = options.name;\n    } else if (_provider2) {\n      // if injected provider is detected, get name from it\n      const detectedName = getInjectedName(_provider2);\n      if (options.name) {\n        this.name = options.name(detectedName);\n      } else {\n        if (typeof detectedName === \"string\") {\n          this.name = detectedName;\n        } else {\n          this.name = detectedName[0];\n        }\n      }\n    } else {\n      // else default to \"Injected\"\n      this.name = \"Injected\";\n    }\n    this.id = \"injected\";\n    this.ready = !!_provider2;\n    this.connectorStorage = arg.connectorStorage;\n  }\n\n  /**\n   * * Connect to the injected provider\n   * * switch to the given chain if `chainId` is specified as an argument\n   */\n  async connect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    try {\n      const provider = await this.getProvider();\n      if (!provider) {\n        throw new ConnectorNotFoundError();\n      }\n      this.setupListeners();\n\n      // emit \"connecting\" event\n      this.emit(\"message\", {\n        type: \"connecting\"\n      });\n\n      // request account addresses from injected provider\n      const accountAddresses = await provider.request({\n        method: \"eth_requestAccounts\"\n      });\n\n      // get the first account address\n      const firstAccountAddress = utils.getAddress(accountAddresses[0]);\n\n      // Switch to given chain if a chainId is specified\n      let connectedChainId = await this.getChainId();\n      // Check if currently connected chain is unsupported\n      // chainId is considered unsupported if chainId is not in the list of this.chains array\n      let isUnsupported = this.isChainUnsupported(connectedChainId);\n\n      // if chainId is specified and it is not the same as the currently connected chain\n      if (options.chainId && connectedChainId !== options.chainId) {\n        // switch to the given chain\n        try {\n          await this.switchChain(options.chainId);\n          // recalculate connectedChainId and isUnsupported\n          connectedChainId = options.chainId;\n          isUnsupported = this.isChainUnsupported(options.chainId);\n        } catch (e) {\n          console.error(`Could not switch to chain id: ${options.chainId}`, e);\n        }\n      }\n\n      // if shimDisconnect is enabled\n      if (this.options.shimDisconnect) {\n        // add the shim shimDisconnectKey => it signals that wallet is connected\n        await this.connectorStorage.setItem(this.shimDisconnectKey, \"true\");\n      }\n      const connectionInfo = {\n        account: firstAccountAddress,\n        chain: {\n          id: connectedChainId,\n          unsupported: isUnsupported\n        },\n        provider\n      };\n      this.emit(\"connect\", connectionInfo);\n      return connectionInfo;\n    } catch (error) {\n      if (this.isUserRejectedRequestError(error)) {\n        throw new UserRejectedRequestError(error);\n      }\n      if (error.code === -32002) {\n        throw new ResourceUnavailableError(error);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * disconnect from the injected provider\n   */\n  async disconnect() {\n    // perform cleanup\n    const provider = await this.getProvider();\n    if (!provider?.removeListener) {\n      return;\n    }\n    provider.removeListener(\"accountsChanged\", this.onAccountsChanged);\n    provider.removeListener(\"chainChanged\", this.onChainChanged);\n    provider.removeListener(\"disconnect\", this.onDisconnect);\n\n    // if shimDisconnect is enabled\n    if (this.options.shimDisconnect) {\n      // Remove the shimDisconnectKey => it signals that wallet is disconnected\n      await this.connectorStorage.removeItem(this.shimDisconnectKey);\n    }\n  }\n\n  /**\n   * @returns The first account address from the injected provider\n   */\n  async getAccount() {\n    const provider = await this.getProvider();\n    if (!provider) {\n      throw new ConnectorNotFoundError();\n    }\n    const accounts = await provider.request({\n      method: \"eth_accounts\"\n    });\n\n    // return checksum address\n    // https://docs.ethers.org/v5/api/utils/address/#utils-getAddress\n    return utils.getAddress(accounts[0]);\n  }\n\n  /**\n   * @returns The `chainId` of the currently connected chain from injected provider normalized to a `number`\n   */\n  async getChainId() {\n    const provider = await this.getProvider();\n    if (!provider) {\n      throw new ConnectorNotFoundError();\n    }\n    return provider.request({\n      method: \"eth_chainId\"\n    }).then(normalizeChainId);\n  }\n\n  /**\n   * get the injected provider\n   */\n  async getProvider() {\n    const provider = this.options.getProvider();\n    if (provider) {\n      _classPrivateFieldSet(this, _provider, provider);\n      // setting listeners\n    }\n\n    return _classPrivateFieldGet(this, _provider);\n  }\n\n  /**\n   * get a `signer` for given `chainId`\n   */\n  async getSigner() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const [provider, account] = await Promise.all([this.getProvider(), this.getAccount()]);\n\n    // ethers.providers.Web3Provider\n    return new providers.Web3Provider(provider, chainId).getSigner(account);\n  }\n\n  /**\n   *\n   * @returns `true` if the connector is connected and address is available, else `false`\n   */\n  async isAuthorized() {\n    try {\n      // `false` if connector is disconnected\n      if (this.options.shimDisconnect &&\n      // If shim does not exist in storage, wallet is disconnected\n      !Boolean(await this.connectorStorage.getItem(this.shimDisconnectKey))) {\n        return false;\n      }\n      const provider = await this.getProvider();\n      if (!provider) {\n        throw new ConnectorNotFoundError();\n      }\n      // `false` if no account address available, else `true`\n      const account = await this.getAccount();\n      return !!account;\n    } catch {\n      // `false` if any error thrown\n      return false;\n    }\n  }\n\n  /**\n   * switch to given chain\n   */\n  async switchChain(chainId) {\n    const provider = await this.getProvider();\n    if (!provider) {\n      throw new ConnectorNotFoundError();\n    }\n    const chainIdHex = utils.hexValue(chainId);\n    try {\n      // request provider to switch to given chainIdHex\n      await provider.request({\n        method: \"wallet_switchEthereumChain\",\n        params: [{\n          chainId: chainIdHex\n        }]\n      });\n      const chain = this.chains.find(_chain => _chain.chainId === chainId);\n      if (chain) {\n        return chain;\n      }\n      return {\n        chainId: chainId,\n        name: `Chain ${chainIdHex}`,\n        slug: `${chainIdHex}`,\n        nativeCurrency: {\n          name: \"Ether\",\n          decimals: 18,\n          symbol: \"ETH\"\n        },\n        rpc: [\"\"],\n        chain: \"\",\n        shortName: \"\",\n        testnet: true\n      };\n    } catch (error) {\n      // if could not switch to given chainIdHex\n\n      // if tried to connect to a chain that is not configured\n      const chain = this.chains.find(_chain => _chain.chainId === chainId);\n      if (!chain) {\n        throw new ChainNotConfiguredError({\n          chainId,\n          connectorId: this.id\n        });\n      }\n\n      // if chain is not added to provider\n      if (error.code === 4902 ||\n      // Unwrapping for MetaMask Mobile\n      // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719\n      error?.data?.originalError?.code === 4902) {\n        try {\n          // request provider to add chain\n          await provider.request({\n            method: \"wallet_addEthereumChain\",\n            params: [{\n              chainId: chainIdHex,\n              chainName: chain.name,\n              nativeCurrency: chain.nativeCurrency,\n              rpcUrls: getValidPublicRPCUrl(chain),\n              // no client id on purpose here\n              blockExplorerUrls: this.getBlockExplorerUrls(chain)\n            }]\n          });\n          return chain;\n        } catch (addError) {\n          // if user rejects request to add chain\n          if (this.isUserRejectedRequestError(addError)) {\n            throw new UserRejectedRequestError(error);\n          }\n\n          // else other error\n          throw new AddChainError();\n        }\n      }\n      if (this.isUserRejectedRequestError(error)) {\n        throw new UserRejectedRequestError(error);\n      }\n      throw new SwitchChainError(error);\n    }\n  }\n  async setupListeners() {\n    const provider = await this.getProvider();\n    if (provider.on) {\n      provider.on(\"accountsChanged\", this.onAccountsChanged);\n      provider.on(\"chainChanged\", this.onChainChanged);\n      provider.on(\"disconnect\", this.onDisconnect);\n    }\n  }\n  isUserRejectedRequestError(error) {\n    return error.code === 4001;\n  }\n}\nexport { InjectedConnector };","map":{"version":3,"names":["_","_defineProperty","_classPrivateFieldInitSpec","a","_classPrivateFieldSet","b","_classPrivateFieldGet","assertWindowEthereum","g","getValidPublicRPCUrl","utils","providers","W","WagmiConnector","n","normalizeChainId","ConnectorNotFoundError","U","UserRejectedRequestError","R","ResourceUnavailableError","C","ChainNotConfiguredError","A","AddChainError","S","SwitchChainError","getInjectedName","ethereum","getName","provider","isAvalanche","isBitKeep","isBraveWallet","isCoinbaseWallet","isExodus","isFrame","isKuCoinWallet","isMathWallet","isOneInchIOSWallet","isOneInchAndroidWallet","isOpera","isPortal","isTally","isTokenPocket","isTokenary","isTrust","isTrustWallet","isMetaMask","length","nameSet","Set","unknownCount","name","add","names","_provider","WeakMap","InjectedConnector","constructor","arg","defaultOptions","shimDisconnect","getProvider","globalThis","window","options","chains","writable","value","accounts","emit","account","getAddress","chainId","id","unsupported","isChainUnsupported","chain","error","code","isAuthorized","getAccount","connectorStorage","removeItem","shimDisconnectKey","_provider2","detectedName","ready","connect","arguments","undefined","setupListeners","type","accountAddresses","request","method","firstAccountAddress","connectedChainId","getChainId","isUnsupported","switchChain","e","console","setItem","connectionInfo","isUserRejectedRequestError","disconnect","removeListener","onAccountsChanged","onChainChanged","onDisconnect","then","getSigner","Promise","all","Web3Provider","Boolean","getItem","chainIdHex","hexValue","params","find","_chain","slug","nativeCurrency","decimals","symbol","rpc","shortName","testnet","connectorId","data","originalError","chainName","rpcUrls","blockExplorerUrls","getBlockExplorerUrls","addError","on"],"sources":["C:/Users/SUMAN K/meta_transfer/node_modules/@thirdweb-dev/wallets/evm/connectors/injected/dist/thirdweb-dev-wallets-evm-connectors-injected.browser.esm.js"],"sourcesContent":["import { _ as _defineProperty } from '../../../../dist/defineProperty-c8ecdc07.browser.esm.js';\nimport { _ as _classPrivateFieldInitSpec, a as _classPrivateFieldSet, b as _classPrivateFieldGet } from '../../../../dist/classPrivateFieldSet-a5db7c83.browser.esm.js';\nimport { a as assertWindowEthereum } from '../../../../dist/assertWindowEthereum-b48c1686.browser.esm.js';\nimport { g as getValidPublicRPCUrl } from '../../../../dist/url-bc88b2b6.browser.esm.js';\nimport { utils, providers } from 'ethers';\nimport { W as WagmiConnector } from '../../../../dist/WagmiConnector-2f14002d.browser.esm.js';\nimport { n as normalizeChainId } from '../../../../dist/normalizeChainId-e4cc0175.browser.esm.js';\nimport { a as ConnectorNotFoundError, U as UserRejectedRequestError, R as ResourceUnavailableError, C as ChainNotConfiguredError, A as AddChainError, S as SwitchChainError } from '../../../../dist/errors-d961f852.browser.esm.js';\nimport '@thirdweb-dev/chains';\nimport 'eventemitter3';\n\nfunction getInjectedName(ethereum) {\n  if (!ethereum) {\n    return \"Injected\";\n  }\n  const getName = provider => {\n    if (provider.isAvalanche) {\n      return \"Core Wallet\";\n    }\n    if (provider.isBitKeep) {\n      return \"BitKeep\";\n    }\n    if (provider.isBraveWallet) {\n      return \"Brave Wallet\";\n    }\n    if (provider.isCoinbaseWallet) {\n      return \"Coinbase Wallet\";\n    }\n    if (provider.isExodus) {\n      return \"Exodus\";\n    }\n    if (provider.isFrame) {\n      return \"Frame\";\n    }\n    if (provider.isKuCoinWallet) {\n      return \"KuCoin Wallet\";\n    }\n    if (provider.isMathWallet) {\n      return \"MathWallet\";\n    }\n    if (provider.isOneInchIOSWallet || provider.isOneInchAndroidWallet) {\n      return \"1inch Wallet\";\n    }\n    if (provider.isOpera) {\n      return \"Opera\";\n    }\n    if (provider.isPortal) {\n      return \"Ripio Portal\";\n    }\n    if (provider.isTally) {\n      return \"Tally\";\n    }\n    if (provider.isTokenPocket) {\n      return \"TokenPocket\";\n    }\n    if (provider.isTokenary) {\n      return \"Tokenary\";\n    }\n    if (provider.isTrust || provider.isTrustWallet) {\n      return \"Trust Wallet\";\n    }\n    if (provider.isMetaMask) {\n      return \"MetaMask\";\n    }\n  };\n\n  // Some injected providers detect multiple other providers and create a list at `ethers.providers`\n  if (ethereum.providers?.length) {\n    // Deduplicate names using Set\n    // Coinbase Wallet puts multiple providers in `ethereum.providers`\n    const nameSet = new Set();\n    let unknownCount = 1;\n    for (const provider of ethereum.providers) {\n      let name = getName(provider);\n      if (!name) {\n        name = `Unknown Wallet #${unknownCount}`;\n        unknownCount += 1;\n      }\n      nameSet.add(name);\n    }\n    const names = [...nameSet];\n    if (names.length) {\n      return names;\n    }\n    return names[0] ?? \"Injected\";\n  }\n  return getName(ethereum) ?? \"Injected\";\n}\n\nvar _provider = /*#__PURE__*/new WeakMap();\nclass InjectedConnector extends WagmiConnector {\n  constructor(arg) {\n    const defaultOptions = {\n      shimDisconnect: true,\n      getProvider: () => {\n        if (assertWindowEthereum(globalThis.window)) {\n          return globalThis.window.ethereum;\n        }\n      }\n    };\n    const options = {\n      ...defaultOptions,\n      ...arg.options\n    };\n    super({\n      chains: arg.chains,\n      options\n    });\n    /**\n     * Name of the injected connector\n     */\n    /**\n     * Whether the connector is ready to be used\n     *\n     * `true` if the injected provider is found\n     */\n    _classPrivateFieldInitSpec(this, _provider, {\n      writable: true,\n      value: void 0\n    });\n    _defineProperty(this, \"shimDisconnectKey\", \"injected.shimDisconnect\");\n    /**\n     * handles the `accountsChanged` event from the provider\n     * * emits `change` event if connected to a different account\n     * * emits `disconnect` event if no accounts available\n     */\n    _defineProperty(this, \"onAccountsChanged\", async accounts => {\n      if (accounts.length === 0) {\n        this.emit(\"disconnect\");\n      } else {\n        this.emit(\"change\", {\n          account: utils.getAddress(accounts[0])\n        });\n      }\n    });\n    /**\n     * handles the `chainChanged` event from the provider\n     * * emits `change` event if connected to a different chain\n     */\n    _defineProperty(this, \"onChainChanged\", chainId => {\n      const id = normalizeChainId(chainId);\n      const unsupported = this.isChainUnsupported(id);\n      this.emit(\"change\", {\n        chain: {\n          id,\n          unsupported\n        }\n      });\n    });\n    /**\n     * handles the `disconnect` event from the provider\n     * * emits `disconnect` event\n     */\n    _defineProperty(this, \"onDisconnect\", async error => {\n      // We need this as MetaMask can emit the \"disconnect\" event upon switching chains.\n      // If MetaMask emits a `code: 1013` error, wait for reconnection before disconnecting\n      // https://github.com/MetaMask/providers/pull/120\n      if (error.code === 1013) {\n        const provider = await this.getProvider();\n        if (provider) {\n          try {\n            const isAuthorized = await this.getAccount();\n            if (isAuthorized) {\n              return;\n            }\n          } catch {\n            // If we can't get the account anymore, continue with disconnect\n          }\n        }\n      }\n      this.emit(\"disconnect\");\n\n      // Remove `shimDisconnect` => it signals that wallet is disconnected\n      if (this.options.shimDisconnect) {\n        await this.connectorStorage.removeItem(this.shimDisconnectKey);\n      }\n    });\n    const _provider2 = options.getProvider();\n\n    // set the name of the connector\n    if (typeof options.name === \"string\") {\n      // if name is given, use that\n      this.name = options.name;\n    } else if (_provider2) {\n      // if injected provider is detected, get name from it\n      const detectedName = getInjectedName(_provider2);\n      if (options.name) {\n        this.name = options.name(detectedName);\n      } else {\n        if (typeof detectedName === \"string\") {\n          this.name = detectedName;\n        } else {\n          this.name = detectedName[0];\n        }\n      }\n    } else {\n      // else default to \"Injected\"\n      this.name = \"Injected\";\n    }\n    this.id = \"injected\";\n    this.ready = !!_provider2;\n    this.connectorStorage = arg.connectorStorage;\n  }\n\n  /**\n   * * Connect to the injected provider\n   * * switch to the given chain if `chainId` is specified as an argument\n   */\n  async connect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    try {\n      const provider = await this.getProvider();\n      if (!provider) {\n        throw new ConnectorNotFoundError();\n      }\n      this.setupListeners();\n\n      // emit \"connecting\" event\n      this.emit(\"message\", {\n        type: \"connecting\"\n      });\n\n      // request account addresses from injected provider\n      const accountAddresses = await provider.request({\n        method: \"eth_requestAccounts\"\n      });\n\n      // get the first account address\n      const firstAccountAddress = utils.getAddress(accountAddresses[0]);\n\n      // Switch to given chain if a chainId is specified\n      let connectedChainId = await this.getChainId();\n      // Check if currently connected chain is unsupported\n      // chainId is considered unsupported if chainId is not in the list of this.chains array\n      let isUnsupported = this.isChainUnsupported(connectedChainId);\n\n      // if chainId is specified and it is not the same as the currently connected chain\n      if (options.chainId && connectedChainId !== options.chainId) {\n        // switch to the given chain\n        try {\n          await this.switchChain(options.chainId);\n          // recalculate connectedChainId and isUnsupported\n          connectedChainId = options.chainId;\n          isUnsupported = this.isChainUnsupported(options.chainId);\n        } catch (e) {\n          console.error(`Could not switch to chain id: ${options.chainId}`, e);\n        }\n      }\n\n      // if shimDisconnect is enabled\n      if (this.options.shimDisconnect) {\n        // add the shim shimDisconnectKey => it signals that wallet is connected\n        await this.connectorStorage.setItem(this.shimDisconnectKey, \"true\");\n      }\n      const connectionInfo = {\n        account: firstAccountAddress,\n        chain: {\n          id: connectedChainId,\n          unsupported: isUnsupported\n        },\n        provider\n      };\n      this.emit(\"connect\", connectionInfo);\n      return connectionInfo;\n    } catch (error) {\n      if (this.isUserRejectedRequestError(error)) {\n        throw new UserRejectedRequestError(error);\n      }\n      if (error.code === -32002) {\n        throw new ResourceUnavailableError(error);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * disconnect from the injected provider\n   */\n  async disconnect() {\n    // perform cleanup\n    const provider = await this.getProvider();\n    if (!provider?.removeListener) {\n      return;\n    }\n    provider.removeListener(\"accountsChanged\", this.onAccountsChanged);\n    provider.removeListener(\"chainChanged\", this.onChainChanged);\n    provider.removeListener(\"disconnect\", this.onDisconnect);\n\n    // if shimDisconnect is enabled\n    if (this.options.shimDisconnect) {\n      // Remove the shimDisconnectKey => it signals that wallet is disconnected\n      await this.connectorStorage.removeItem(this.shimDisconnectKey);\n    }\n  }\n\n  /**\n   * @returns The first account address from the injected provider\n   */\n  async getAccount() {\n    const provider = await this.getProvider();\n    if (!provider) {\n      throw new ConnectorNotFoundError();\n    }\n    const accounts = await provider.request({\n      method: \"eth_accounts\"\n    });\n\n    // return checksum address\n    // https://docs.ethers.org/v5/api/utils/address/#utils-getAddress\n    return utils.getAddress(accounts[0]);\n  }\n\n  /**\n   * @returns The `chainId` of the currently connected chain from injected provider normalized to a `number`\n   */\n  async getChainId() {\n    const provider = await this.getProvider();\n    if (!provider) {\n      throw new ConnectorNotFoundError();\n    }\n    return provider.request({\n      method: \"eth_chainId\"\n    }).then(normalizeChainId);\n  }\n\n  /**\n   * get the injected provider\n   */\n  async getProvider() {\n    const provider = this.options.getProvider();\n    if (provider) {\n      _classPrivateFieldSet(this, _provider, provider);\n      // setting listeners\n    }\n\n    return _classPrivateFieldGet(this, _provider);\n  }\n\n  /**\n   * get a `signer` for given `chainId`\n   */\n  async getSigner() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const [provider, account] = await Promise.all([this.getProvider(), this.getAccount()]);\n\n    // ethers.providers.Web3Provider\n    return new providers.Web3Provider(provider, chainId).getSigner(account);\n  }\n\n  /**\n   *\n   * @returns `true` if the connector is connected and address is available, else `false`\n   */\n  async isAuthorized() {\n    try {\n      // `false` if connector is disconnected\n      if (this.options.shimDisconnect &&\n      // If shim does not exist in storage, wallet is disconnected\n      !Boolean(await this.connectorStorage.getItem(this.shimDisconnectKey))) {\n        return false;\n      }\n      const provider = await this.getProvider();\n      if (!provider) {\n        throw new ConnectorNotFoundError();\n      }\n      // `false` if no account address available, else `true`\n      const account = await this.getAccount();\n      return !!account;\n    } catch {\n      // `false` if any error thrown\n      return false;\n    }\n  }\n\n  /**\n   * switch to given chain\n   */\n  async switchChain(chainId) {\n    const provider = await this.getProvider();\n    if (!provider) {\n      throw new ConnectorNotFoundError();\n    }\n    const chainIdHex = utils.hexValue(chainId);\n    try {\n      // request provider to switch to given chainIdHex\n      await provider.request({\n        method: \"wallet_switchEthereumChain\",\n        params: [{\n          chainId: chainIdHex\n        }]\n      });\n      const chain = this.chains.find(_chain => _chain.chainId === chainId);\n      if (chain) {\n        return chain;\n      }\n      return {\n        chainId: chainId,\n        name: `Chain ${chainIdHex}`,\n        slug: `${chainIdHex}`,\n        nativeCurrency: {\n          name: \"Ether\",\n          decimals: 18,\n          symbol: \"ETH\"\n        },\n        rpc: [\"\"],\n        chain: \"\",\n        shortName: \"\",\n        testnet: true\n      };\n    } catch (error) {\n      // if could not switch to given chainIdHex\n\n      // if tried to connect to a chain that is not configured\n      const chain = this.chains.find(_chain => _chain.chainId === chainId);\n      if (!chain) {\n        throw new ChainNotConfiguredError({\n          chainId,\n          connectorId: this.id\n        });\n      }\n\n      // if chain is not added to provider\n      if (error.code === 4902 ||\n      // Unwrapping for MetaMask Mobile\n      // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719\n      error?.data?.originalError?.code === 4902) {\n        try {\n          // request provider to add chain\n          await provider.request({\n            method: \"wallet_addEthereumChain\",\n            params: [{\n              chainId: chainIdHex,\n              chainName: chain.name,\n              nativeCurrency: chain.nativeCurrency,\n              rpcUrls: getValidPublicRPCUrl(chain),\n              // no client id on purpose here\n              blockExplorerUrls: this.getBlockExplorerUrls(chain)\n            }]\n          });\n          return chain;\n        } catch (addError) {\n          // if user rejects request to add chain\n          if (this.isUserRejectedRequestError(addError)) {\n            throw new UserRejectedRequestError(error);\n          }\n\n          // else other error\n          throw new AddChainError();\n        }\n      }\n      if (this.isUserRejectedRequestError(error)) {\n        throw new UserRejectedRequestError(error);\n      }\n      throw new SwitchChainError(error);\n    }\n  }\n  async setupListeners() {\n    const provider = await this.getProvider();\n    if (provider.on) {\n      provider.on(\"accountsChanged\", this.onAccountsChanged);\n      provider.on(\"chainChanged\", this.onChainChanged);\n      provider.on(\"disconnect\", this.onDisconnect);\n    }\n  }\n  isUserRejectedRequestError(error) {\n    return error.code === 4001;\n  }\n}\n\nexport { InjectedConnector };\n"],"mappings":"AAAA,SAASA,CAAC,IAAIC,eAAe,QAAQ,yDAAyD;AAC9F,SAASD,CAAC,IAAIE,0BAA0B,EAAEC,CAAC,IAAIC,qBAAqB,EAAEC,CAAC,IAAIC,qBAAqB,QAAQ,+DAA+D;AACvK,SAASH,CAAC,IAAII,oBAAoB,QAAQ,+DAA+D;AACzG,SAASC,CAAC,IAAIC,oBAAoB,QAAQ,8CAA8C;AACxF,SAASC,KAAK,EAAEC,SAAS,QAAQ,QAAQ;AACzC,SAASC,CAAC,IAAIC,cAAc,QAAQ,yDAAyD;AAC7F,SAASC,CAAC,IAAIC,gBAAgB,QAAQ,2DAA2D;AACjG,SAASZ,CAAC,IAAIa,sBAAsB,EAAEC,CAAC,IAAIC,wBAAwB,EAAEC,CAAC,IAAIC,wBAAwB,EAAEC,CAAC,IAAIC,uBAAuB,EAAEC,CAAC,IAAIC,aAAa,EAAEC,CAAC,IAAIC,gBAAgB,QAAQ,iDAAiD;AACpO,OAAO,sBAAsB;AAC7B,OAAO,eAAe;AAEtB,SAASC,eAAeA,CAACC,QAAQ,EAAE;EACjC,IAAI,CAACA,QAAQ,EAAE;IACb,OAAO,UAAU;EACnB;EACA,MAAMC,OAAO,GAAGC,QAAQ,IAAI;IAC1B,IAAIA,QAAQ,CAACC,WAAW,EAAE;MACxB,OAAO,aAAa;IACtB;IACA,IAAID,QAAQ,CAACE,SAAS,EAAE;MACtB,OAAO,SAAS;IAClB;IACA,IAAIF,QAAQ,CAACG,aAAa,EAAE;MAC1B,OAAO,cAAc;IACvB;IACA,IAAIH,QAAQ,CAACI,gBAAgB,EAAE;MAC7B,OAAO,iBAAiB;IAC1B;IACA,IAAIJ,QAAQ,CAACK,QAAQ,EAAE;MACrB,OAAO,QAAQ;IACjB;IACA,IAAIL,QAAQ,CAACM,OAAO,EAAE;MACpB,OAAO,OAAO;IAChB;IACA,IAAIN,QAAQ,CAACO,cAAc,EAAE;MAC3B,OAAO,eAAe;IACxB;IACA,IAAIP,QAAQ,CAACQ,YAAY,EAAE;MACzB,OAAO,YAAY;IACrB;IACA,IAAIR,QAAQ,CAACS,kBAAkB,IAAIT,QAAQ,CAACU,sBAAsB,EAAE;MAClE,OAAO,cAAc;IACvB;IACA,IAAIV,QAAQ,CAACW,OAAO,EAAE;MACpB,OAAO,OAAO;IAChB;IACA,IAAIX,QAAQ,CAACY,QAAQ,EAAE;MACrB,OAAO,cAAc;IACvB;IACA,IAAIZ,QAAQ,CAACa,OAAO,EAAE;MACpB,OAAO,OAAO;IAChB;IACA,IAAIb,QAAQ,CAACc,aAAa,EAAE;MAC1B,OAAO,aAAa;IACtB;IACA,IAAId,QAAQ,CAACe,UAAU,EAAE;MACvB,OAAO,UAAU;IACnB;IACA,IAAIf,QAAQ,CAACgB,OAAO,IAAIhB,QAAQ,CAACiB,aAAa,EAAE;MAC9C,OAAO,cAAc;IACvB;IACA,IAAIjB,QAAQ,CAACkB,UAAU,EAAE;MACvB,OAAO,UAAU;IACnB;EACF,CAAC;;EAED;EACA,IAAIpB,QAAQ,CAACjB,SAAS,EAAEsC,MAAM,EAAE;IAC9B;IACA;IACA,MAAMC,OAAO,GAAG,IAAIC,GAAG,CAAC,CAAC;IACzB,IAAIC,YAAY,GAAG,CAAC;IACpB,KAAK,MAAMtB,QAAQ,IAAIF,QAAQ,CAACjB,SAAS,EAAE;MACzC,IAAI0C,IAAI,GAAGxB,OAAO,CAACC,QAAQ,CAAC;MAC5B,IAAI,CAACuB,IAAI,EAAE;QACTA,IAAI,GAAI,mBAAkBD,YAAa,EAAC;QACxCA,YAAY,IAAI,CAAC;MACnB;MACAF,OAAO,CAACI,GAAG,CAACD,IAAI,CAAC;IACnB;IACA,MAAME,KAAK,GAAG,CAAC,GAAGL,OAAO,CAAC;IAC1B,IAAIK,KAAK,CAACN,MAAM,EAAE;MAChB,OAAOM,KAAK;IACd;IACA,OAAOA,KAAK,CAAC,CAAC,CAAC,IAAI,UAAU;EAC/B;EACA,OAAO1B,OAAO,CAACD,QAAQ,CAAC,IAAI,UAAU;AACxC;AAEA,IAAI4B,SAAS,GAAG,aAAa,IAAIC,OAAO,CAAC,CAAC;AAC1C,MAAMC,iBAAiB,SAAS7C,cAAc,CAAC;EAC7C8C,WAAWA,CAACC,GAAG,EAAE;IACf,MAAMC,cAAc,GAAG;MACrBC,cAAc,EAAE,IAAI;MACpBC,WAAW,EAAEA,CAAA,KAAM;QACjB,IAAIxD,oBAAoB,CAACyD,UAAU,CAACC,MAAM,CAAC,EAAE;UAC3C,OAAOD,UAAU,CAACC,MAAM,CAACrC,QAAQ;QACnC;MACF;IACF,CAAC;IACD,MAAMsC,OAAO,GAAG;MACd,GAAGL,cAAc;MACjB,GAAGD,GAAG,CAACM;IACT,CAAC;IACD,KAAK,CAAC;MACJC,MAAM,EAAEP,GAAG,CAACO,MAAM;MAClBD;IACF,CAAC,CAAC;IACF;AACJ;AACA;IACI;AACJ;AACA;AACA;AACA;IACIhE,0BAA0B,CAAC,IAAI,EAAEsD,SAAS,EAAE;MAC1CY,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,KAAK;IACd,CAAC,CAAC;IACFpE,eAAe,CAAC,IAAI,EAAE,mBAAmB,EAAE,yBAAyB,CAAC;IACrE;AACJ;AACA;AACA;AACA;IACIA,eAAe,CAAC,IAAI,EAAE,mBAAmB,EAAE,MAAMqE,QAAQ,IAAI;MAC3D,IAAIA,QAAQ,CAACrB,MAAM,KAAK,CAAC,EAAE;QACzB,IAAI,CAACsB,IAAI,CAAC,YAAY,CAAC;MACzB,CAAC,MAAM;QACL,IAAI,CAACA,IAAI,CAAC,QAAQ,EAAE;UAClBC,OAAO,EAAE9D,KAAK,CAAC+D,UAAU,CAACH,QAAQ,CAAC,CAAC,CAAC;QACvC,CAAC,CAAC;MACJ;IACF,CAAC,CAAC;IACF;AACJ;AACA;AACA;IACIrE,eAAe,CAAC,IAAI,EAAE,gBAAgB,EAAEyE,OAAO,IAAI;MACjD,MAAMC,EAAE,GAAG5D,gBAAgB,CAAC2D,OAAO,CAAC;MACpC,MAAME,WAAW,GAAG,IAAI,CAACC,kBAAkB,CAACF,EAAE,CAAC;MAC/C,IAAI,CAACJ,IAAI,CAAC,QAAQ,EAAE;QAClBO,KAAK,EAAE;UACLH,EAAE;UACFC;QACF;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;IACF;AACJ;AACA;AACA;IACI3E,eAAe,CAAC,IAAI,EAAE,cAAc,EAAE,MAAM8E,KAAK,IAAI;MACnD;MACA;MACA;MACA,IAAIA,KAAK,CAACC,IAAI,KAAK,IAAI,EAAE;QACvB,MAAMlD,QAAQ,GAAG,MAAM,IAAI,CAACiC,WAAW,CAAC,CAAC;QACzC,IAAIjC,QAAQ,EAAE;UACZ,IAAI;YACF,MAAMmD,YAAY,GAAG,MAAM,IAAI,CAACC,UAAU,CAAC,CAAC;YAC5C,IAAID,YAAY,EAAE;cAChB;YACF;UACF,CAAC,CAAC,MAAM;YACN;UAAA;QAEJ;MACF;MACA,IAAI,CAACV,IAAI,CAAC,YAAY,CAAC;;MAEvB;MACA,IAAI,IAAI,CAACL,OAAO,CAACJ,cAAc,EAAE;QAC/B,MAAM,IAAI,CAACqB,gBAAgB,CAACC,UAAU,CAAC,IAAI,CAACC,iBAAiB,CAAC;MAChE;IACF,CAAC,CAAC;IACF,MAAMC,UAAU,GAAGpB,OAAO,CAACH,WAAW,CAAC,CAAC;;IAExC;IACA,IAAI,OAAOG,OAAO,CAACb,IAAI,KAAK,QAAQ,EAAE;MACpC;MACA,IAAI,CAACA,IAAI,GAAGa,OAAO,CAACb,IAAI;IAC1B,CAAC,MAAM,IAAIiC,UAAU,EAAE;MACrB;MACA,MAAMC,YAAY,GAAG5D,eAAe,CAAC2D,UAAU,CAAC;MAChD,IAAIpB,OAAO,CAACb,IAAI,EAAE;QAChB,IAAI,CAACA,IAAI,GAAGa,OAAO,CAACb,IAAI,CAACkC,YAAY,CAAC;MACxC,CAAC,MAAM;QACL,IAAI,OAAOA,YAAY,KAAK,QAAQ,EAAE;UACpC,IAAI,CAAClC,IAAI,GAAGkC,YAAY;QAC1B,CAAC,MAAM;UACL,IAAI,CAAClC,IAAI,GAAGkC,YAAY,CAAC,CAAC,CAAC;QAC7B;MACF;IACF,CAAC,MAAM;MACL;MACA,IAAI,CAAClC,IAAI,GAAG,UAAU;IACxB;IACA,IAAI,CAACsB,EAAE,GAAG,UAAU;IACpB,IAAI,CAACa,KAAK,GAAG,CAAC,CAACF,UAAU;IACzB,IAAI,CAACH,gBAAgB,GAAGvB,GAAG,CAACuB,gBAAgB;EAC9C;;EAEA;AACF;AACA;AACA;EACE,MAAMM,OAAOA,CAAA,EAAG;IACd,IAAIvB,OAAO,GAAGwB,SAAS,CAACzC,MAAM,GAAG,CAAC,IAAIyC,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IACpF,IAAI;MACF,MAAM5D,QAAQ,GAAG,MAAM,IAAI,CAACiC,WAAW,CAAC,CAAC;MACzC,IAAI,CAACjC,QAAQ,EAAE;QACb,MAAM,IAAId,sBAAsB,CAAC,CAAC;MACpC;MACA,IAAI,CAAC4E,cAAc,CAAC,CAAC;;MAErB;MACA,IAAI,CAACrB,IAAI,CAAC,SAAS,EAAE;QACnBsB,IAAI,EAAE;MACR,CAAC,CAAC;;MAEF;MACA,MAAMC,gBAAgB,GAAG,MAAMhE,QAAQ,CAACiE,OAAO,CAAC;QAC9CC,MAAM,EAAE;MACV,CAAC,CAAC;;MAEF;MACA,MAAMC,mBAAmB,GAAGvF,KAAK,CAAC+D,UAAU,CAACqB,gBAAgB,CAAC,CAAC,CAAC,CAAC;;MAEjE;MACA,IAAII,gBAAgB,GAAG,MAAM,IAAI,CAACC,UAAU,CAAC,CAAC;MAC9C;MACA;MACA,IAAIC,aAAa,GAAG,IAAI,CAACvB,kBAAkB,CAACqB,gBAAgB,CAAC;;MAE7D;MACA,IAAIhC,OAAO,CAACQ,OAAO,IAAIwB,gBAAgB,KAAKhC,OAAO,CAACQ,OAAO,EAAE;QAC3D;QACA,IAAI;UACF,MAAM,IAAI,CAAC2B,WAAW,CAACnC,OAAO,CAACQ,OAAO,CAAC;UACvC;UACAwB,gBAAgB,GAAGhC,OAAO,CAACQ,OAAO;UAClC0B,aAAa,GAAG,IAAI,CAACvB,kBAAkB,CAACX,OAAO,CAACQ,OAAO,CAAC;QAC1D,CAAC,CAAC,OAAO4B,CAAC,EAAE;UACVC,OAAO,CAACxB,KAAK,CAAE,iCAAgCb,OAAO,CAACQ,OAAQ,EAAC,EAAE4B,CAAC,CAAC;QACtE;MACF;;MAEA;MACA,IAAI,IAAI,CAACpC,OAAO,CAACJ,cAAc,EAAE;QAC/B;QACA,MAAM,IAAI,CAACqB,gBAAgB,CAACqB,OAAO,CAAC,IAAI,CAACnB,iBAAiB,EAAE,MAAM,CAAC;MACrE;MACA,MAAMoB,cAAc,GAAG;QACrBjC,OAAO,EAAEyB,mBAAmB;QAC5BnB,KAAK,EAAE;UACLH,EAAE,EAAEuB,gBAAgB;UACpBtB,WAAW,EAAEwB;QACf,CAAC;QACDtE;MACF,CAAC;MACD,IAAI,CAACyC,IAAI,CAAC,SAAS,EAAEkC,cAAc,CAAC;MACpC,OAAOA,cAAc;IACvB,CAAC,CAAC,OAAO1B,KAAK,EAAE;MACd,IAAI,IAAI,CAAC2B,0BAA0B,CAAC3B,KAAK,CAAC,EAAE;QAC1C,MAAM,IAAI7D,wBAAwB,CAAC6D,KAAK,CAAC;MAC3C;MACA,IAAIA,KAAK,CAACC,IAAI,KAAK,CAAC,KAAK,EAAE;QACzB,MAAM,IAAI5D,wBAAwB,CAAC2D,KAAK,CAAC;MAC3C;MACA,MAAMA,KAAK;IACb;EACF;;EAEA;AACF;AACA;EACE,MAAM4B,UAAUA,CAAA,EAAG;IACjB;IACA,MAAM7E,QAAQ,GAAG,MAAM,IAAI,CAACiC,WAAW,CAAC,CAAC;IACzC,IAAI,CAACjC,QAAQ,EAAE8E,cAAc,EAAE;MAC7B;IACF;IACA9E,QAAQ,CAAC8E,cAAc,CAAC,iBAAiB,EAAE,IAAI,CAACC,iBAAiB,CAAC;IAClE/E,QAAQ,CAAC8E,cAAc,CAAC,cAAc,EAAE,IAAI,CAACE,cAAc,CAAC;IAC5DhF,QAAQ,CAAC8E,cAAc,CAAC,YAAY,EAAE,IAAI,CAACG,YAAY,CAAC;;IAExD;IACA,IAAI,IAAI,CAAC7C,OAAO,CAACJ,cAAc,EAAE;MAC/B;MACA,MAAM,IAAI,CAACqB,gBAAgB,CAACC,UAAU,CAAC,IAAI,CAACC,iBAAiB,CAAC;IAChE;EACF;;EAEA;AACF;AACA;EACE,MAAMH,UAAUA,CAAA,EAAG;IACjB,MAAMpD,QAAQ,GAAG,MAAM,IAAI,CAACiC,WAAW,CAAC,CAAC;IACzC,IAAI,CAACjC,QAAQ,EAAE;MACb,MAAM,IAAId,sBAAsB,CAAC,CAAC;IACpC;IACA,MAAMsD,QAAQ,GAAG,MAAMxC,QAAQ,CAACiE,OAAO,CAAC;MACtCC,MAAM,EAAE;IACV,CAAC,CAAC;;IAEF;IACA;IACA,OAAOtF,KAAK,CAAC+D,UAAU,CAACH,QAAQ,CAAC,CAAC,CAAC,CAAC;EACtC;;EAEA;AACF;AACA;EACE,MAAM6B,UAAUA,CAAA,EAAG;IACjB,MAAMrE,QAAQ,GAAG,MAAM,IAAI,CAACiC,WAAW,CAAC,CAAC;IACzC,IAAI,CAACjC,QAAQ,EAAE;MACb,MAAM,IAAId,sBAAsB,CAAC,CAAC;IACpC;IACA,OAAOc,QAAQ,CAACiE,OAAO,CAAC;MACtBC,MAAM,EAAE;IACV,CAAC,CAAC,CAACgB,IAAI,CAACjG,gBAAgB,CAAC;EAC3B;;EAEA;AACF;AACA;EACE,MAAMgD,WAAWA,CAAA,EAAG;IAClB,MAAMjC,QAAQ,GAAG,IAAI,CAACoC,OAAO,CAACH,WAAW,CAAC,CAAC;IAC3C,IAAIjC,QAAQ,EAAE;MACZ1B,qBAAqB,CAAC,IAAI,EAAEoD,SAAS,EAAE1B,QAAQ,CAAC;MAChD;IACF;;IAEA,OAAOxB,qBAAqB,CAAC,IAAI,EAAEkD,SAAS,CAAC;EAC/C;;EAEA;AACF;AACA;EACE,MAAMyD,SAASA,CAAA,EAAG;IAChB,IAAI;MACFvC;IACF,CAAC,GAAGgB,SAAS,CAACzC,MAAM,GAAG,CAAC,IAAIyC,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IAC1E,MAAM,CAAC5D,QAAQ,EAAE0C,OAAO,CAAC,GAAG,MAAM0C,OAAO,CAACC,GAAG,CAAC,CAAC,IAAI,CAACpD,WAAW,CAAC,CAAC,EAAE,IAAI,CAACmB,UAAU,CAAC,CAAC,CAAC,CAAC;;IAEtF;IACA,OAAO,IAAIvE,SAAS,CAACyG,YAAY,CAACtF,QAAQ,EAAE4C,OAAO,CAAC,CAACuC,SAAS,CAACzC,OAAO,CAAC;EACzE;;EAEA;AACF;AACA;AACA;EACE,MAAMS,YAAYA,CAAA,EAAG;IACnB,IAAI;MACF;MACA,IAAI,IAAI,CAACf,OAAO,CAACJ,cAAc;MAC/B;MACA,CAACuD,OAAO,CAAC,MAAM,IAAI,CAAClC,gBAAgB,CAACmC,OAAO,CAAC,IAAI,CAACjC,iBAAiB,CAAC,CAAC,EAAE;QACrE,OAAO,KAAK;MACd;MACA,MAAMvD,QAAQ,GAAG,MAAM,IAAI,CAACiC,WAAW,CAAC,CAAC;MACzC,IAAI,CAACjC,QAAQ,EAAE;QACb,MAAM,IAAId,sBAAsB,CAAC,CAAC;MACpC;MACA;MACA,MAAMwD,OAAO,GAAG,MAAM,IAAI,CAACU,UAAU,CAAC,CAAC;MACvC,OAAO,CAAC,CAACV,OAAO;IAClB,CAAC,CAAC,MAAM;MACN;MACA,OAAO,KAAK;IACd;EACF;;EAEA;AACF;AACA;EACE,MAAM6B,WAAWA,CAAC3B,OAAO,EAAE;IACzB,MAAM5C,QAAQ,GAAG,MAAM,IAAI,CAACiC,WAAW,CAAC,CAAC;IACzC,IAAI,CAACjC,QAAQ,EAAE;MACb,MAAM,IAAId,sBAAsB,CAAC,CAAC;IACpC;IACA,MAAMuG,UAAU,GAAG7G,KAAK,CAAC8G,QAAQ,CAAC9C,OAAO,CAAC;IAC1C,IAAI;MACF;MACA,MAAM5C,QAAQ,CAACiE,OAAO,CAAC;QACrBC,MAAM,EAAE,4BAA4B;QACpCyB,MAAM,EAAE,CAAC;UACP/C,OAAO,EAAE6C;QACX,CAAC;MACH,CAAC,CAAC;MACF,MAAMzC,KAAK,GAAG,IAAI,CAACX,MAAM,CAACuD,IAAI,CAACC,MAAM,IAAIA,MAAM,CAACjD,OAAO,KAAKA,OAAO,CAAC;MACpE,IAAII,KAAK,EAAE;QACT,OAAOA,KAAK;MACd;MACA,OAAO;QACLJ,OAAO,EAAEA,OAAO;QAChBrB,IAAI,EAAG,SAAQkE,UAAW,EAAC;QAC3BK,IAAI,EAAG,GAAEL,UAAW,EAAC;QACrBM,cAAc,EAAE;UACdxE,IAAI,EAAE,OAAO;UACbyE,QAAQ,EAAE,EAAE;UACZC,MAAM,EAAE;QACV,CAAC;QACDC,GAAG,EAAE,CAAC,EAAE,CAAC;QACTlD,KAAK,EAAE,EAAE;QACTmD,SAAS,EAAE,EAAE;QACbC,OAAO,EAAE;MACX,CAAC;IACH,CAAC,CAAC,OAAOnD,KAAK,EAAE;MACd;;MAEA;MACA,MAAMD,KAAK,GAAG,IAAI,CAACX,MAAM,CAACuD,IAAI,CAACC,MAAM,IAAIA,MAAM,CAACjD,OAAO,KAAKA,OAAO,CAAC;MACpE,IAAI,CAACI,KAAK,EAAE;QACV,MAAM,IAAIxD,uBAAuB,CAAC;UAChCoD,OAAO;UACPyD,WAAW,EAAE,IAAI,CAACxD;QACpB,CAAC,CAAC;MACJ;;MAEA;MACA,IAAII,KAAK,CAACC,IAAI,KAAK,IAAI;MACvB;MACA;MACAD,KAAK,EAAEqD,IAAI,EAAEC,aAAa,EAAErD,IAAI,KAAK,IAAI,EAAE;QACzC,IAAI;UACF;UACA,MAAMlD,QAAQ,CAACiE,OAAO,CAAC;YACrBC,MAAM,EAAE,yBAAyB;YACjCyB,MAAM,EAAE,CAAC;cACP/C,OAAO,EAAE6C,UAAU;cACnBe,SAAS,EAAExD,KAAK,CAACzB,IAAI;cACrBwE,cAAc,EAAE/C,KAAK,CAAC+C,cAAc;cACpCU,OAAO,EAAE9H,oBAAoB,CAACqE,KAAK,CAAC;cACpC;cACA0D,iBAAiB,EAAE,IAAI,CAACC,oBAAoB,CAAC3D,KAAK;YACpD,CAAC;UACH,CAAC,CAAC;UACF,OAAOA,KAAK;QACd,CAAC,CAAC,OAAO4D,QAAQ,EAAE;UACjB;UACA,IAAI,IAAI,CAAChC,0BAA0B,CAACgC,QAAQ,CAAC,EAAE;YAC7C,MAAM,IAAIxH,wBAAwB,CAAC6D,KAAK,CAAC;UAC3C;;UAEA;UACA,MAAM,IAAIvD,aAAa,CAAC,CAAC;QAC3B;MACF;MACA,IAAI,IAAI,CAACkF,0BAA0B,CAAC3B,KAAK,CAAC,EAAE;QAC1C,MAAM,IAAI7D,wBAAwB,CAAC6D,KAAK,CAAC;MAC3C;MACA,MAAM,IAAIrD,gBAAgB,CAACqD,KAAK,CAAC;IACnC;EACF;EACA,MAAMa,cAAcA,CAAA,EAAG;IACrB,MAAM9D,QAAQ,GAAG,MAAM,IAAI,CAACiC,WAAW,CAAC,CAAC;IACzC,IAAIjC,QAAQ,CAAC6G,EAAE,EAAE;MACf7G,QAAQ,CAAC6G,EAAE,CAAC,iBAAiB,EAAE,IAAI,CAAC9B,iBAAiB,CAAC;MACtD/E,QAAQ,CAAC6G,EAAE,CAAC,cAAc,EAAE,IAAI,CAAC7B,cAAc,CAAC;MAChDhF,QAAQ,CAAC6G,EAAE,CAAC,YAAY,EAAE,IAAI,CAAC5B,YAAY,CAAC;IAC9C;EACF;EACAL,0BAA0BA,CAAC3B,KAAK,EAAE;IAChC,OAAOA,KAAK,CAACC,IAAI,KAAK,IAAI;EAC5B;AACF;AAEA,SAAStB,iBAAiB"},"metadata":{},"sourceType":"module","externalDependencies":[]}