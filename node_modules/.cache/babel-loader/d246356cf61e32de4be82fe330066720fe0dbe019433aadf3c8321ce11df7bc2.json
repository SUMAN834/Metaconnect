{"ast":null,"code":"import { AnimationClip, AnimationMixer, Euler, Matrix4, Quaternion, QuaternionKeyframeTrack, SkeletonHelper, Vector2, Vector3, VectorKeyframeTrack } from 'three';\nfunction retarget(target, source, options = {}) {\n  const pos = new Vector3(),\n    quat = new Quaternion(),\n    scale = new Vector3(),\n    bindBoneMatrix = new Matrix4(),\n    relativeMatrix = new Matrix4(),\n    globalMatrix = new Matrix4();\n  options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n  options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n  options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n  options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n  options.hip = options.hip !== undefined ? options.hip : 'hip';\n  options.names = options.names || {};\n  const sourceBones = source.isObject3D ? source.skeleton.bones : getBones(source),\n    bones = target.isObject3D ? target.skeleton.bones : getBones(target);\n  let bindBones, bone, name, boneTo, bonesPosition;\n\n  // reset bones\n\n  if (target.isObject3D) {\n    target.skeleton.pose();\n  } else {\n    options.useTargetMatrix = true;\n    options.preserveMatrix = false;\n  }\n  if (options.preservePosition) {\n    bonesPosition = [];\n    for (let i = 0; i < bones.length; i++) {\n      bonesPosition.push(bones[i].position.clone());\n    }\n  }\n  if (options.preserveMatrix) {\n    // reset matrix\n\n    target.updateMatrixWorld();\n    target.matrixWorld.identity();\n\n    // reset children matrix\n\n    for (let i = 0; i < target.children.length; ++i) {\n      target.children[i].updateMatrixWorld(true);\n    }\n  }\n  if (options.offsets) {\n    bindBones = [];\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i];\n      name = options.names[bone.name] || bone.name;\n      if (options.offsets[name]) {\n        bone.matrix.multiply(options.offsets[name]);\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n      }\n      bindBones.push(bone.matrixWorld.clone());\n    }\n  }\n  for (let i = 0; i < bones.length; ++i) {\n    bone = bones[i];\n    name = options.names[bone.name] || bone.name;\n    boneTo = getBoneByName(name, sourceBones);\n    globalMatrix.copy(bone.matrixWorld);\n    if (boneTo) {\n      boneTo.updateMatrixWorld();\n      if (options.useTargetMatrix) {\n        relativeMatrix.copy(boneTo.matrixWorld);\n      } else {\n        relativeMatrix.copy(target.matrixWorld).invert();\n        relativeMatrix.multiply(boneTo.matrixWorld);\n      }\n\n      // ignore scale to extract rotation\n\n      scale.setFromMatrixScale(relativeMatrix);\n      relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z));\n\n      // apply to global matrix\n\n      globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n      if (target.isObject3D) {\n        const boneIndex = bones.indexOf(bone),\n          wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n        globalMatrix.multiply(wBindMatrix);\n      }\n      globalMatrix.copyPosition(relativeMatrix);\n    }\n    if (bone.parent && bone.parent.isBone) {\n      bone.matrix.copy(bone.parent.matrixWorld).invert();\n      bone.matrix.multiply(globalMatrix);\n    } else {\n      bone.matrix.copy(globalMatrix);\n    }\n    if (options.preserveHipPosition && name === options.hip) {\n      bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n    }\n    bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n    bone.updateMatrixWorld();\n  }\n  if (options.preservePosition) {\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i];\n      name = options.names[bone.name] || bone.name;\n      if (name !== options.hip) {\n        bone.position.copy(bonesPosition[i]);\n      }\n    }\n  }\n  if (options.preserveMatrix) {\n    // restore matrix\n\n    target.updateMatrixWorld(true);\n  }\n}\nfunction retargetClip(target, source, clip, options = {}) {\n  options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n  options.fps = options.fps !== undefined ? options.fps : 30;\n  options.names = options.names || [];\n  if (!source.isObject3D) {\n    source = getHelperFromSkeleton(source);\n  }\n  const numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),\n    delta = 1 / options.fps,\n    convertedTracks = [],\n    mixer = new AnimationMixer(source),\n    bones = getBones(target.skeleton),\n    boneDatas = [];\n  let positionOffset, bone, boneTo, boneData, name;\n  mixer.clipAction(clip).play();\n  mixer.update(0);\n  source.updateMatrixWorld();\n  for (let i = 0; i < numFrames; ++i) {\n    const time = i * delta;\n    retarget(target, source, options);\n    for (let j = 0; j < bones.length; ++j) {\n      name = options.names[bones[j].name] || bones[j].name;\n      boneTo = getBoneByName(name, source.skeleton);\n      if (boneTo) {\n        bone = bones[j];\n        boneData = boneDatas[j] = boneDatas[j] || {\n          bone: bone\n        };\n        if (options.hip === name) {\n          if (!boneData.pos) {\n            boneData.pos = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 3)\n            };\n          }\n          if (options.useFirstFramePosition) {\n            if (i === 0) {\n              positionOffset = bone.position.clone();\n            }\n            bone.position.sub(positionOffset);\n          }\n          boneData.pos.times[i] = time;\n          bone.position.toArray(boneData.pos.values, i * 3);\n        }\n        if (!boneData.quat) {\n          boneData.quat = {\n            times: new Float32Array(numFrames),\n            values: new Float32Array(numFrames * 4)\n          };\n        }\n        boneData.quat.times[i] = time;\n        bone.quaternion.toArray(boneData.quat.values, i * 4);\n      }\n    }\n    mixer.update(delta);\n    source.updateMatrixWorld();\n  }\n  for (let i = 0; i < boneDatas.length; ++i) {\n    boneData = boneDatas[i];\n    if (boneData) {\n      if (boneData.pos) {\n        convertedTracks.push(new VectorKeyframeTrack('.bones[' + boneData.bone.name + '].position', boneData.pos.times, boneData.pos.values));\n      }\n      convertedTracks.push(new QuaternionKeyframeTrack('.bones[' + boneData.bone.name + '].quaternion', boneData.quat.times, boneData.quat.values));\n    }\n  }\n  mixer.uncacheAction(clip);\n  return new AnimationClip(clip.name, -1, convertedTracks);\n}\nfunction getHelperFromSkeleton(skeleton) {\n  const source = new SkeletonHelper(skeleton.bones[0]);\n  source.skeleton = skeleton;\n  return source;\n}\nfunction getSkeletonOffsets(target, source, options = {}) {\n  const targetParentPos = new Vector3(),\n    targetPos = new Vector3(),\n    sourceParentPos = new Vector3(),\n    sourcePos = new Vector3(),\n    targetDir = new Vector2(),\n    sourceDir = new Vector2();\n  options.hip = options.hip !== undefined ? options.hip : 'hip';\n  options.names = options.names || {};\n  if (!source.isObject3D) {\n    source = getHelperFromSkeleton(source);\n  }\n  const nameKeys = Object.keys(options.names),\n    nameValues = Object.values(options.names),\n    sourceBones = source.isObject3D ? source.skeleton.bones : getBones(source),\n    bones = target.isObject3D ? target.skeleton.bones : getBones(target),\n    offsets = [];\n  let bone, boneTo, name, i;\n  target.skeleton.pose();\n  for (i = 0; i < bones.length; ++i) {\n    bone = bones[i];\n    name = options.names[bone.name] || bone.name;\n    boneTo = getBoneByName(name, sourceBones);\n    if (boneTo && name !== options.hip) {\n      const boneParent = getNearestBone(bone.parent, nameKeys),\n        boneToParent = getNearestBone(boneTo.parent, nameValues);\n      boneParent.updateMatrixWorld();\n      boneToParent.updateMatrixWorld();\n      targetParentPos.setFromMatrixPosition(boneParent.matrixWorld);\n      targetPos.setFromMatrixPosition(bone.matrixWorld);\n      sourceParentPos.setFromMatrixPosition(boneToParent.matrixWorld);\n      sourcePos.setFromMatrixPosition(boneTo.matrixWorld);\n      targetDir.subVectors(new Vector2(targetPos.x, targetPos.y), new Vector2(targetParentPos.x, targetParentPos.y)).normalize();\n      sourceDir.subVectors(new Vector2(sourcePos.x, sourcePos.y), new Vector2(sourceParentPos.x, sourceParentPos.y)).normalize();\n      const laterialAngle = targetDir.angle() - sourceDir.angle();\n      const offset = new Matrix4().makeRotationFromEuler(new Euler(0, 0, laterialAngle));\n      bone.matrix.multiply(offset);\n      bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n      bone.updateMatrixWorld();\n      offsets[name] = offset;\n    }\n  }\n  return offsets;\n}\nfunction renameBones(skeleton, names) {\n  const bones = getBones(skeleton);\n  for (let i = 0; i < bones.length; ++i) {\n    const bone = bones[i];\n    if (names[bone.name]) {\n      bone.name = names[bone.name];\n    }\n  }\n  return this;\n}\nfunction getBones(skeleton) {\n  return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n}\nfunction getBoneByName(name, skeleton) {\n  for (let i = 0, bones = getBones(skeleton); i < bones.length; i++) {\n    if (name === bones[i].name) return bones[i];\n  }\n}\nfunction getNearestBone(bone, names) {\n  while (bone.isBone) {\n    if (names.indexOf(bone.name) !== -1) {\n      return bone;\n    }\n    bone = bone.parent;\n  }\n}\nfunction findBoneTrackData(name, tracks) {\n  const regexp = /\\[(.*)\\]\\.(.*)/,\n    result = {\n      name: name\n    };\n  for (let i = 0; i < tracks.length; ++i) {\n    // 1 is track name\n    // 2 is track type\n    const trackData = regexp.exec(tracks[i].name);\n    if (trackData && name === trackData[1]) {\n      result[trackData[2]] = i;\n    }\n  }\n  return result;\n}\nfunction getEqualsBonesNames(skeleton, targetSkeleton) {\n  const sourceBones = getBones(skeleton),\n    targetBones = getBones(targetSkeleton),\n    bones = [];\n  search: for (let i = 0; i < sourceBones.length; i++) {\n    const boneName = sourceBones[i].name;\n    for (let j = 0; j < targetBones.length; j++) {\n      if (boneName === targetBones[j].name) {\n        bones.push(boneName);\n        continue search;\n      }\n    }\n  }\n  return bones;\n}\nfunction clone(source) {\n  const sourceLookup = new Map();\n  const cloneLookup = new Map();\n  const clone = source.clone();\n  parallelTraverse(source, clone, function (sourceNode, clonedNode) {\n    sourceLookup.set(clonedNode, sourceNode);\n    cloneLookup.set(sourceNode, clonedNode);\n  });\n  clone.traverse(function (node) {\n    if (!node.isSkinnedMesh) return;\n    const clonedMesh = node;\n    const sourceMesh = sourceLookup.get(node);\n    const sourceBones = sourceMesh.skeleton.bones;\n    clonedMesh.skeleton = sourceMesh.skeleton.clone();\n    clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n    clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n      return cloneLookup.get(bone);\n    });\n    clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n  });\n  return clone;\n}\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n  for (let i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\nexport { retarget, retargetClip, getHelperFromSkeleton, getSkeletonOffsets, renameBones, getBones, getBoneByName, getNearestBone, findBoneTrackData, getEqualsBonesNames, clone };","map":{"version":3,"names":["AnimationClip","AnimationMixer","Euler","Matrix4","Quaternion","QuaternionKeyframeTrack","SkeletonHelper","Vector2","Vector3","VectorKeyframeTrack","retarget","target","source","options","pos","quat","scale","bindBoneMatrix","relativeMatrix","globalMatrix","preserveMatrix","undefined","preservePosition","preserveHipPosition","useTargetMatrix","hip","names","sourceBones","isObject3D","skeleton","bones","getBones","bindBones","bone","name","boneTo","bonesPosition","pose","i","length","push","position","clone","updateMatrixWorld","matrixWorld","identity","children","offsets","matrix","multiply","decompose","quaternion","getBoneByName","copy","invert","setFromMatrixScale","set","x","y","z","makeRotationFromQuaternion","setFromRotationMatrix","boneIndex","indexOf","wBindMatrix","boneInverses","copyPosition","parent","isBone","setPosition","retargetClip","clip","useFirstFramePosition","fps","getHelperFromSkeleton","numFrames","Math","round","duration","delta","convertedTracks","mixer","boneDatas","positionOffset","boneData","clipAction","play","update","time","j","times","Float32Array","values","sub","toArray","uncacheAction","getSkeletonOffsets","targetParentPos","targetPos","sourceParentPos","sourcePos","targetDir","sourceDir","nameKeys","Object","keys","nameValues","boneParent","getNearestBone","boneToParent","setFromMatrixPosition","subVectors","normalize","laterialAngle","angle","offset","makeRotationFromEuler","renameBones","Array","isArray","findBoneTrackData","tracks","regexp","result","trackData","exec","getEqualsBonesNames","targetSkeleton","targetBones","search","boneName","sourceLookup","Map","cloneLookup","parallelTraverse","sourceNode","clonedNode","traverse","node","isSkinnedMesh","clonedMesh","sourceMesh","get","bindMatrix","map","bind","a","b","callback"],"sources":["C:/Users/SUMAN K/meta_transfer/node_modules/three/examples/jsm/utils/SkeletonUtils.js"],"sourcesContent":["import {\n\tAnimationClip,\n\tAnimationMixer,\n\tEuler,\n\tMatrix4,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tSkeletonHelper,\n\tVector2,\n\tVector3,\n\tVectorKeyframeTrack\n} from 'three';\n\n\nfunction retarget( target, source, options = {} ) {\n\n\tconst pos = new Vector3(),\n\t\tquat = new Quaternion(),\n\t\tscale = new Vector3(),\n\t\tbindBoneMatrix = new Matrix4(),\n\t\trelativeMatrix = new Matrix4(),\n\t\tglobalMatrix = new Matrix4();\n\n\toptions.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n\toptions.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n\toptions.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n\toptions.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n\toptions.hip = options.hip !== undefined ? options.hip : 'hip';\n\toptions.names = options.names || {};\n\n\tconst sourceBones = source.isObject3D ? source.skeleton.bones : getBones( source ),\n\t\tbones = target.isObject3D ? target.skeleton.bones : getBones( target );\n\n\tlet bindBones,\n\t\tbone, name, boneTo,\n\t\tbonesPosition;\n\n\t// reset bones\n\n\tif ( target.isObject3D ) {\n\n\t\ttarget.skeleton.pose();\n\n\t} else {\n\n\t\toptions.useTargetMatrix = true;\n\t\toptions.preserveMatrix = false;\n\n\t}\n\n\tif ( options.preservePosition ) {\n\n\t\tbonesPosition = [];\n\n\t\tfor ( let i = 0; i < bones.length; i ++ ) {\n\n\t\t\tbonesPosition.push( bones[ i ].position.clone() );\n\n\t\t}\n\n\t}\n\n\tif ( options.preserveMatrix ) {\n\n\t\t// reset matrix\n\n\t\ttarget.updateMatrixWorld();\n\n\t\ttarget.matrixWorld.identity();\n\n\t\t// reset children matrix\n\n\t\tfor ( let i = 0; i < target.children.length; ++ i ) {\n\n\t\t\ttarget.children[ i ].updateMatrixWorld( true );\n\n\t\t}\n\n\t}\n\n\tif ( options.offsets ) {\n\n\t\tbindBones = [];\n\n\t\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\t\tbone = bones[ i ];\n\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\tif ( options.offsets[ name ] ) {\n\n\t\t\t\tbone.matrix.multiply( options.offsets[ name ] );\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t\tbone.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t\tbindBones.push( bone.matrixWorld.clone() );\n\n\t\t}\n\n\t}\n\n\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\tbone = bones[ i ];\n\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\tboneTo = getBoneByName( name, sourceBones );\n\n\t\tglobalMatrix.copy( bone.matrixWorld );\n\n\t\tif ( boneTo ) {\n\n\t\t\tboneTo.updateMatrixWorld();\n\n\t\t\tif ( options.useTargetMatrix ) {\n\n\t\t\t\trelativeMatrix.copy( boneTo.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\trelativeMatrix.copy( target.matrixWorld ).invert();\n\t\t\t\trelativeMatrix.multiply( boneTo.matrixWorld );\n\n\t\t\t}\n\n\t\t\t// ignore scale to extract rotation\n\n\t\t\tscale.setFromMatrixScale( relativeMatrix );\n\t\t\trelativeMatrix.scale( scale.set( 1 / scale.x, 1 / scale.y, 1 / scale.z ) );\n\n\t\t\t// apply to global matrix\n\n\t\t\tglobalMatrix.makeRotationFromQuaternion( quat.setFromRotationMatrix( relativeMatrix ) );\n\n\t\t\tif ( target.isObject3D ) {\n\n\t\t\t\tconst boneIndex = bones.indexOf( bone ),\n\t\t\t\t\twBindMatrix = bindBones ? bindBones[ boneIndex ] : bindBoneMatrix.copy( target.skeleton.boneInverses[ boneIndex ] ).invert();\n\n\t\t\t\tglobalMatrix.multiply( wBindMatrix );\n\n\t\t\t}\n\n\t\t\tglobalMatrix.copyPosition( relativeMatrix );\n\n\t\t}\n\n\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\tbone.matrix.copy( bone.parent.matrixWorld ).invert();\n\t\t\tbone.matrix.multiply( globalMatrix );\n\n\t\t} else {\n\n\t\t\tbone.matrix.copy( globalMatrix );\n\n\t\t}\n\n\t\tif ( options.preserveHipPosition && name === options.hip ) {\n\n\t\t\tbone.matrix.setPosition( pos.set( 0, bone.position.y, 0 ) );\n\n\t\t}\n\n\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\tbone.updateMatrixWorld();\n\n\t}\n\n\tif ( options.preservePosition ) {\n\n\t\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\t\tbone = bones[ i ];\n\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\tif ( name !== options.hip ) {\n\n\t\t\t\tbone.position.copy( bonesPosition[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tif ( options.preserveMatrix ) {\n\n\t\t// restore matrix\n\n\t\ttarget.updateMatrixWorld( true );\n\n\t}\n\n}\n\nfunction retargetClip( target, source, clip, options = {} ) {\n\n\toptions.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n\toptions.fps = options.fps !== undefined ? options.fps : 30;\n\toptions.names = options.names || [];\n\n\tif ( ! source.isObject3D ) {\n\n\t\tsource = getHelperFromSkeleton( source );\n\n\t}\n\n\tconst numFrames = Math.round( clip.duration * ( options.fps / 1000 ) * 1000 ),\n\t\tdelta = 1 / options.fps,\n\t\tconvertedTracks = [],\n\t\tmixer = new AnimationMixer( source ),\n\t\tbones = getBones( target.skeleton ),\n\t\tboneDatas = [];\n\tlet positionOffset,\n\t\tbone, boneTo, boneData,\n\t\tname;\n\n\tmixer.clipAction( clip ).play();\n\tmixer.update( 0 );\n\n\tsource.updateMatrixWorld();\n\n\tfor ( let i = 0; i < numFrames; ++ i ) {\n\n\t\tconst time = i * delta;\n\n\t\tretarget( target, source, options );\n\n\t\tfor ( let j = 0; j < bones.length; ++ j ) {\n\n\t\t\tname = options.names[ bones[ j ].name ] || bones[ j ].name;\n\n\t\t\tboneTo = getBoneByName( name, source.skeleton );\n\n\t\t\tif ( boneTo ) {\n\n\t\t\t\tbone = bones[ j ];\n\t\t\t\tboneData = boneDatas[ j ] = boneDatas[ j ] || { bone: bone };\n\n\t\t\t\tif ( options.hip === name ) {\n\n\t\t\t\t\tif ( ! boneData.pos ) {\n\n\t\t\t\t\t\tboneData.pos = {\n\t\t\t\t\t\t\ttimes: new Float32Array( numFrames ),\n\t\t\t\t\t\t\tvalues: new Float32Array( numFrames * 3 )\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( options.useFirstFramePosition ) {\n\n\t\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\t\tpositionOffset = bone.position.clone();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbone.position.sub( positionOffset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneData.pos.times[ i ] = time;\n\n\t\t\t\t\tbone.position.toArray( boneData.pos.values, i * 3 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! boneData.quat ) {\n\n\t\t\t\t\tboneData.quat = {\n\t\t\t\t\t\ttimes: new Float32Array( numFrames ),\n\t\t\t\t\t\tvalues: new Float32Array( numFrames * 4 )\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tboneData.quat.times[ i ] = time;\n\n\t\t\t\tbone.quaternion.toArray( boneData.quat.values, i * 4 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tmixer.update( delta );\n\n\t\tsource.updateMatrixWorld();\n\n\t}\n\n\tfor ( let i = 0; i < boneDatas.length; ++ i ) {\n\n\t\tboneData = boneDatas[ i ];\n\n\t\tif ( boneData ) {\n\n\t\t\tif ( boneData.pos ) {\n\n\t\t\t\tconvertedTracks.push( new VectorKeyframeTrack(\n\t\t\t\t\t'.bones[' + boneData.bone.name + '].position',\n\t\t\t\t\tboneData.pos.times,\n\t\t\t\t\tboneData.pos.values\n\t\t\t\t) );\n\n\t\t\t}\n\n\t\t\tconvertedTracks.push( new QuaternionKeyframeTrack(\n\t\t\t\t'.bones[' + boneData.bone.name + '].quaternion',\n\t\t\t\tboneData.quat.times,\n\t\t\t\tboneData.quat.values\n\t\t\t) );\n\n\t\t}\n\n\t}\n\n\tmixer.uncacheAction( clip );\n\n\treturn new AnimationClip( clip.name, - 1, convertedTracks );\n\n}\n\nfunction getHelperFromSkeleton( skeleton ) {\n\n\tconst source = new SkeletonHelper( skeleton.bones[ 0 ] );\n\tsource.skeleton = skeleton;\n\n\treturn source;\n\n}\n\nfunction getSkeletonOffsets( target, source, options = {} ) {\n\n\tconst targetParentPos = new Vector3(),\n\t\ttargetPos = new Vector3(),\n\t\tsourceParentPos = new Vector3(),\n\t\tsourcePos = new Vector3(),\n\t\ttargetDir = new Vector2(),\n\t\tsourceDir = new Vector2();\n\n\toptions.hip = options.hip !== undefined ? options.hip : 'hip';\n\toptions.names = options.names || {};\n\n\tif ( ! source.isObject3D ) {\n\n\t\tsource = getHelperFromSkeleton( source );\n\n\t}\n\n\tconst nameKeys = Object.keys( options.names ),\n\t\tnameValues = Object.values( options.names ),\n\t\tsourceBones = source.isObject3D ? source.skeleton.bones : getBones( source ),\n\t\tbones = target.isObject3D ? target.skeleton.bones : getBones( target ),\n\t\toffsets = [];\n\n\tlet bone, boneTo,\n\t\tname, i;\n\n\ttarget.skeleton.pose();\n\n\tfor ( i = 0; i < bones.length; ++ i ) {\n\n\t\tbone = bones[ i ];\n\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\tboneTo = getBoneByName( name, sourceBones );\n\n\t\tif ( boneTo && name !== options.hip ) {\n\n\t\t\tconst boneParent = getNearestBone( bone.parent, nameKeys ),\n\t\t\t\tboneToParent = getNearestBone( boneTo.parent, nameValues );\n\n\t\t\tboneParent.updateMatrixWorld();\n\t\t\tboneToParent.updateMatrixWorld();\n\n\t\t\ttargetParentPos.setFromMatrixPosition( boneParent.matrixWorld );\n\t\t\ttargetPos.setFromMatrixPosition( bone.matrixWorld );\n\n\t\t\tsourceParentPos.setFromMatrixPosition( boneToParent.matrixWorld );\n\t\t\tsourcePos.setFromMatrixPosition( boneTo.matrixWorld );\n\n\t\t\ttargetDir.subVectors(\n\t\t\t\tnew Vector2( targetPos.x, targetPos.y ),\n\t\t\t\tnew Vector2( targetParentPos.x, targetParentPos.y )\n\t\t\t).normalize();\n\n\t\t\tsourceDir.subVectors(\n\t\t\t\tnew Vector2( sourcePos.x, sourcePos.y ),\n\t\t\t\tnew Vector2( sourceParentPos.x, sourceParentPos.y )\n\t\t\t).normalize();\n\n\t\t\tconst laterialAngle = targetDir.angle() - sourceDir.angle();\n\n\t\t\tconst offset = new Matrix4().makeRotationFromEuler(\n\t\t\t\tnew Euler(\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\tlaterialAngle\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tbone.matrix.multiply( offset );\n\n\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\tbone.updateMatrixWorld();\n\n\t\t\toffsets[ name ] = offset;\n\n\t\t}\n\n\t}\n\n\treturn offsets;\n\n}\n\nfunction renameBones( skeleton, names ) {\n\n\tconst bones = getBones( skeleton );\n\n\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\tconst bone = bones[ i ];\n\n\t\tif ( names[ bone.name ] ) {\n\n\t\t\tbone.name = names[ bone.name ];\n\n\t\t}\n\n\t}\n\n\treturn this;\n\n}\n\nfunction getBones( skeleton ) {\n\n\treturn Array.isArray( skeleton ) ? skeleton : skeleton.bones;\n\n}\n\nfunction getBoneByName( name, skeleton ) {\n\n\tfor ( let i = 0, bones = getBones( skeleton ); i < bones.length; i ++ ) {\n\n\t\tif ( name === bones[ i ].name )\n\n\t\t\treturn bones[ i ];\n\n\t}\n\n}\n\nfunction getNearestBone( bone, names ) {\n\n\twhile ( bone.isBone ) {\n\n\t\tif ( names.indexOf( bone.name ) !== - 1 ) {\n\n\t\t\treturn bone;\n\n\t\t}\n\n\t\tbone = bone.parent;\n\n\t}\n\n}\n\nfunction findBoneTrackData( name, tracks ) {\n\n\tconst regexp = /\\[(.*)\\]\\.(.*)/,\n\t\tresult = { name: name };\n\n\tfor ( let i = 0; i < tracks.length; ++ i ) {\n\n\t\t// 1 is track name\n\t\t// 2 is track type\n\t\tconst trackData = regexp.exec( tracks[ i ].name );\n\n\t\tif ( trackData && name === trackData[ 1 ] ) {\n\n\t\t\tresult[ trackData[ 2 ] ] = i;\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\nfunction getEqualsBonesNames( skeleton, targetSkeleton ) {\n\n\tconst sourceBones = getBones( skeleton ),\n\t\ttargetBones = getBones( targetSkeleton ),\n\t\tbones = [];\n\n\tsearch : for ( let i = 0; i < sourceBones.length; i ++ ) {\n\n\t\tconst boneName = sourceBones[ i ].name;\n\n\t\tfor ( let j = 0; j < targetBones.length; j ++ ) {\n\n\t\t\tif ( boneName === targetBones[ j ].name ) {\n\n\t\t\t\tbones.push( boneName );\n\n\t\t\t\tcontinue search;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn bones;\n\n}\n\nfunction clone( source ) {\n\n\tconst sourceLookup = new Map();\n\tconst cloneLookup = new Map();\n\n\tconst clone = source.clone();\n\n\tparallelTraverse( source, clone, function ( sourceNode, clonedNode ) {\n\n\t\tsourceLookup.set( clonedNode, sourceNode );\n\t\tcloneLookup.set( sourceNode, clonedNode );\n\n\t} );\n\n\tclone.traverse( function ( node ) {\n\n\t\tif ( ! node.isSkinnedMesh ) return;\n\n\t\tconst clonedMesh = node;\n\t\tconst sourceMesh = sourceLookup.get( node );\n\t\tconst sourceBones = sourceMesh.skeleton.bones;\n\n\t\tclonedMesh.skeleton = sourceMesh.skeleton.clone();\n\t\tclonedMesh.bindMatrix.copy( sourceMesh.bindMatrix );\n\n\t\tclonedMesh.skeleton.bones = sourceBones.map( function ( bone ) {\n\n\t\t\treturn cloneLookup.get( bone );\n\n\t\t} );\n\n\t\tclonedMesh.bind( clonedMesh.skeleton, clonedMesh.bindMatrix );\n\n\t} );\n\n\treturn clone;\n\n}\n\n\n\n\nfunction parallelTraverse( a, b, callback ) {\n\n\tcallback( a, b );\n\n\tfor ( let i = 0; i < a.children.length; i ++ ) {\n\n\t\tparallelTraverse( a.children[ i ], b.children[ i ], callback );\n\n\t}\n\n}\n\nexport {\n\tretarget,\n\tretargetClip,\n\tgetHelperFromSkeleton,\n\tgetSkeletonOffsets,\n\trenameBones,\n\tgetBones,\n\tgetBoneByName,\n\tgetNearestBone,\n\tfindBoneTrackData,\n\tgetEqualsBonesNames,\n\tclone,\n};\n"],"mappings":"AAAA,SACCA,aAAa,EACbC,cAAc,EACdC,KAAK,EACLC,OAAO,EACPC,UAAU,EACVC,uBAAuB,EACvBC,cAAc,EACdC,OAAO,EACPC,OAAO,EACPC,mBAAmB,QACb,OAAO;AAGd,SAASC,QAAQA,CAAEC,MAAM,EAAEC,MAAM,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAG;EAEjD,MAAMC,GAAG,GAAG,IAAIN,OAAO,CAAC,CAAC;IACxBO,IAAI,GAAG,IAAIX,UAAU,CAAC,CAAC;IACvBY,KAAK,GAAG,IAAIR,OAAO,CAAC,CAAC;IACrBS,cAAc,GAAG,IAAId,OAAO,CAAC,CAAC;IAC9Be,cAAc,GAAG,IAAIf,OAAO,CAAC,CAAC;IAC9BgB,YAAY,GAAG,IAAIhB,OAAO,CAAC,CAAC;EAE7BU,OAAO,CAACO,cAAc,GAAGP,OAAO,CAACO,cAAc,KAAKC,SAAS,GAAGR,OAAO,CAACO,cAAc,GAAG,IAAI;EAC7FP,OAAO,CAACS,gBAAgB,GAAGT,OAAO,CAACS,gBAAgB,KAAKD,SAAS,GAAGR,OAAO,CAACS,gBAAgB,GAAG,IAAI;EACnGT,OAAO,CAACU,mBAAmB,GAAGV,OAAO,CAACU,mBAAmB,KAAKF,SAAS,GAAGR,OAAO,CAACU,mBAAmB,GAAG,KAAK;EAC7GV,OAAO,CAACW,eAAe,GAAGX,OAAO,CAACW,eAAe,KAAKH,SAAS,GAAGR,OAAO,CAACW,eAAe,GAAG,KAAK;EACjGX,OAAO,CAACY,GAAG,GAAGZ,OAAO,CAACY,GAAG,KAAKJ,SAAS,GAAGR,OAAO,CAACY,GAAG,GAAG,KAAK;EAC7DZ,OAAO,CAACa,KAAK,GAAGb,OAAO,CAACa,KAAK,IAAI,CAAC,CAAC;EAEnC,MAAMC,WAAW,GAAGf,MAAM,CAACgB,UAAU,GAAGhB,MAAM,CAACiB,QAAQ,CAACC,KAAK,GAAGC,QAAQ,CAAEnB,MAAO,CAAC;IACjFkB,KAAK,GAAGnB,MAAM,CAACiB,UAAU,GAAGjB,MAAM,CAACkB,QAAQ,CAACC,KAAK,GAAGC,QAAQ,CAAEpB,MAAO,CAAC;EAEvE,IAAIqB,SAAS,EACZC,IAAI,EAAEC,IAAI,EAAEC,MAAM,EAClBC,aAAa;;EAEd;;EAEA,IAAKzB,MAAM,CAACiB,UAAU,EAAG;IAExBjB,MAAM,CAACkB,QAAQ,CAACQ,IAAI,CAAC,CAAC;EAEvB,CAAC,MAAM;IAENxB,OAAO,CAACW,eAAe,GAAG,IAAI;IAC9BX,OAAO,CAACO,cAAc,GAAG,KAAK;EAE/B;EAEA,IAAKP,OAAO,CAACS,gBAAgB,EAAG;IAE/Bc,aAAa,GAAG,EAAE;IAElB,KAAM,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,KAAK,CAACS,MAAM,EAAED,CAAC,EAAG,EAAG;MAEzCF,aAAa,CAACI,IAAI,CAAEV,KAAK,CAAEQ,CAAC,CAAE,CAACG,QAAQ,CAACC,KAAK,CAAC,CAAE,CAAC;IAElD;EAED;EAEA,IAAK7B,OAAO,CAACO,cAAc,EAAG;IAE7B;;IAEAT,MAAM,CAACgC,iBAAiB,CAAC,CAAC;IAE1BhC,MAAM,CAACiC,WAAW,CAACC,QAAQ,CAAC,CAAC;;IAE7B;;IAEA,KAAM,IAAIP,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG3B,MAAM,CAACmC,QAAQ,CAACP,MAAM,EAAE,EAAGD,CAAC,EAAG;MAEnD3B,MAAM,CAACmC,QAAQ,CAAER,CAAC,CAAE,CAACK,iBAAiB,CAAE,IAAK,CAAC;IAE/C;EAED;EAEA,IAAK9B,OAAO,CAACkC,OAAO,EAAG;IAEtBf,SAAS,GAAG,EAAE;IAEd,KAAM,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,KAAK,CAACS,MAAM,EAAE,EAAGD,CAAC,EAAG;MAEzCL,IAAI,GAAGH,KAAK,CAAEQ,CAAC,CAAE;MACjBJ,IAAI,GAAGrB,OAAO,CAACa,KAAK,CAAEO,IAAI,CAACC,IAAI,CAAE,IAAID,IAAI,CAACC,IAAI;MAE9C,IAAKrB,OAAO,CAACkC,OAAO,CAAEb,IAAI,CAAE,EAAG;QAE9BD,IAAI,CAACe,MAAM,CAACC,QAAQ,CAAEpC,OAAO,CAACkC,OAAO,CAAEb,IAAI,CAAG,CAAC;QAE/CD,IAAI,CAACe,MAAM,CAACE,SAAS,CAAEjB,IAAI,CAACQ,QAAQ,EAAER,IAAI,CAACkB,UAAU,EAAElB,IAAI,CAACjB,KAAM,CAAC;QAEnEiB,IAAI,CAACU,iBAAiB,CAAC,CAAC;MAEzB;MAEAX,SAAS,CAACQ,IAAI,CAAEP,IAAI,CAACW,WAAW,CAACF,KAAK,CAAC,CAAE,CAAC;IAE3C;EAED;EAEA,KAAM,IAAIJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,KAAK,CAACS,MAAM,EAAE,EAAGD,CAAC,EAAG;IAEzCL,IAAI,GAAGH,KAAK,CAAEQ,CAAC,CAAE;IACjBJ,IAAI,GAAGrB,OAAO,CAACa,KAAK,CAAEO,IAAI,CAACC,IAAI,CAAE,IAAID,IAAI,CAACC,IAAI;IAE9CC,MAAM,GAAGiB,aAAa,CAAElB,IAAI,EAAEP,WAAY,CAAC;IAE3CR,YAAY,CAACkC,IAAI,CAAEpB,IAAI,CAACW,WAAY,CAAC;IAErC,IAAKT,MAAM,EAAG;MAEbA,MAAM,CAACQ,iBAAiB,CAAC,CAAC;MAE1B,IAAK9B,OAAO,CAACW,eAAe,EAAG;QAE9BN,cAAc,CAACmC,IAAI,CAAElB,MAAM,CAACS,WAAY,CAAC;MAE1C,CAAC,MAAM;QAEN1B,cAAc,CAACmC,IAAI,CAAE1C,MAAM,CAACiC,WAAY,CAAC,CAACU,MAAM,CAAC,CAAC;QAClDpC,cAAc,CAAC+B,QAAQ,CAAEd,MAAM,CAACS,WAAY,CAAC;MAE9C;;MAEA;;MAEA5B,KAAK,CAACuC,kBAAkB,CAAErC,cAAe,CAAC;MAC1CA,cAAc,CAACF,KAAK,CAAEA,KAAK,CAACwC,GAAG,CAAE,CAAC,GAAGxC,KAAK,CAACyC,CAAC,EAAE,CAAC,GAAGzC,KAAK,CAAC0C,CAAC,EAAE,CAAC,GAAG1C,KAAK,CAAC2C,CAAE,CAAE,CAAC;;MAE1E;;MAEAxC,YAAY,CAACyC,0BAA0B,CAAE7C,IAAI,CAAC8C,qBAAqB,CAAE3C,cAAe,CAAE,CAAC;MAEvF,IAAKP,MAAM,CAACiB,UAAU,EAAG;QAExB,MAAMkC,SAAS,GAAGhC,KAAK,CAACiC,OAAO,CAAE9B,IAAK,CAAC;UACtC+B,WAAW,GAAGhC,SAAS,GAAGA,SAAS,CAAE8B,SAAS,CAAE,GAAG7C,cAAc,CAACoC,IAAI,CAAE1C,MAAM,CAACkB,QAAQ,CAACoC,YAAY,CAAEH,SAAS,CAAG,CAAC,CAACR,MAAM,CAAC,CAAC;QAE7HnC,YAAY,CAAC8B,QAAQ,CAAEe,WAAY,CAAC;MAErC;MAEA7C,YAAY,CAAC+C,YAAY,CAAEhD,cAAe,CAAC;IAE5C;IAEA,IAAKe,IAAI,CAACkC,MAAM,IAAIlC,IAAI,CAACkC,MAAM,CAACC,MAAM,EAAG;MAExCnC,IAAI,CAACe,MAAM,CAACK,IAAI,CAAEpB,IAAI,CAACkC,MAAM,CAACvB,WAAY,CAAC,CAACU,MAAM,CAAC,CAAC;MACpDrB,IAAI,CAACe,MAAM,CAACC,QAAQ,CAAE9B,YAAa,CAAC;IAErC,CAAC,MAAM;MAENc,IAAI,CAACe,MAAM,CAACK,IAAI,CAAElC,YAAa,CAAC;IAEjC;IAEA,IAAKN,OAAO,CAACU,mBAAmB,IAAIW,IAAI,KAAKrB,OAAO,CAACY,GAAG,EAAG;MAE1DQ,IAAI,CAACe,MAAM,CAACqB,WAAW,CAAEvD,GAAG,CAAC0C,GAAG,CAAE,CAAC,EAAEvB,IAAI,CAACQ,QAAQ,CAACiB,CAAC,EAAE,CAAE,CAAE,CAAC;IAE5D;IAEAzB,IAAI,CAACe,MAAM,CAACE,SAAS,CAAEjB,IAAI,CAACQ,QAAQ,EAAER,IAAI,CAACkB,UAAU,EAAElB,IAAI,CAACjB,KAAM,CAAC;IAEnEiB,IAAI,CAACU,iBAAiB,CAAC,CAAC;EAEzB;EAEA,IAAK9B,OAAO,CAACS,gBAAgB,EAAG;IAE/B,KAAM,IAAIgB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,KAAK,CAACS,MAAM,EAAE,EAAGD,CAAC,EAAG;MAEzCL,IAAI,GAAGH,KAAK,CAAEQ,CAAC,CAAE;MACjBJ,IAAI,GAAGrB,OAAO,CAACa,KAAK,CAAEO,IAAI,CAACC,IAAI,CAAE,IAAID,IAAI,CAACC,IAAI;MAE9C,IAAKA,IAAI,KAAKrB,OAAO,CAACY,GAAG,EAAG;QAE3BQ,IAAI,CAACQ,QAAQ,CAACY,IAAI,CAAEjB,aAAa,CAAEE,CAAC,CAAG,CAAC;MAEzC;IAED;EAED;EAEA,IAAKzB,OAAO,CAACO,cAAc,EAAG;IAE7B;;IAEAT,MAAM,CAACgC,iBAAiB,CAAE,IAAK,CAAC;EAEjC;AAED;AAEA,SAAS2B,YAAYA,CAAE3D,MAAM,EAAEC,MAAM,EAAE2D,IAAI,EAAE1D,OAAO,GAAG,CAAC,CAAC,EAAG;EAE3DA,OAAO,CAAC2D,qBAAqB,GAAG3D,OAAO,CAAC2D,qBAAqB,KAAKnD,SAAS,GAAGR,OAAO,CAAC2D,qBAAqB,GAAG,KAAK;EACnH3D,OAAO,CAAC4D,GAAG,GAAG5D,OAAO,CAAC4D,GAAG,KAAKpD,SAAS,GAAGR,OAAO,CAAC4D,GAAG,GAAG,EAAE;EAC1D5D,OAAO,CAACa,KAAK,GAAGb,OAAO,CAACa,KAAK,IAAI,EAAE;EAEnC,IAAK,CAAEd,MAAM,CAACgB,UAAU,EAAG;IAE1BhB,MAAM,GAAG8D,qBAAqB,CAAE9D,MAAO,CAAC;EAEzC;EAEA,MAAM+D,SAAS,GAAGC,IAAI,CAACC,KAAK,CAAEN,IAAI,CAACO,QAAQ,IAAKjE,OAAO,CAAC4D,GAAG,GAAG,IAAI,CAAE,GAAG,IAAK,CAAC;IAC5EM,KAAK,GAAG,CAAC,GAAGlE,OAAO,CAAC4D,GAAG;IACvBO,eAAe,GAAG,EAAE;IACpBC,KAAK,GAAG,IAAIhF,cAAc,CAAEW,MAAO,CAAC;IACpCkB,KAAK,GAAGC,QAAQ,CAAEpB,MAAM,CAACkB,QAAS,CAAC;IACnCqD,SAAS,GAAG,EAAE;EACf,IAAIC,cAAc,EACjBlD,IAAI,EAAEE,MAAM,EAAEiD,QAAQ,EACtBlD,IAAI;EAEL+C,KAAK,CAACI,UAAU,CAAEd,IAAK,CAAC,CAACe,IAAI,CAAC,CAAC;EAC/BL,KAAK,CAACM,MAAM,CAAE,CAAE,CAAC;EAEjB3E,MAAM,CAAC+B,iBAAiB,CAAC,CAAC;EAE1B,KAAM,IAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqC,SAAS,EAAE,EAAGrC,CAAC,EAAG;IAEtC,MAAMkD,IAAI,GAAGlD,CAAC,GAAGyC,KAAK;IAEtBrE,QAAQ,CAAEC,MAAM,EAAEC,MAAM,EAAEC,OAAQ,CAAC;IAEnC,KAAM,IAAI4E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG3D,KAAK,CAACS,MAAM,EAAE,EAAGkD,CAAC,EAAG;MAEzCvD,IAAI,GAAGrB,OAAO,CAACa,KAAK,CAAEI,KAAK,CAAE2D,CAAC,CAAE,CAACvD,IAAI,CAAE,IAAIJ,KAAK,CAAE2D,CAAC,CAAE,CAACvD,IAAI;MAE1DC,MAAM,GAAGiB,aAAa,CAAElB,IAAI,EAAEtB,MAAM,CAACiB,QAAS,CAAC;MAE/C,IAAKM,MAAM,EAAG;QAEbF,IAAI,GAAGH,KAAK,CAAE2D,CAAC,CAAE;QACjBL,QAAQ,GAAGF,SAAS,CAAEO,CAAC,CAAE,GAAGP,SAAS,CAAEO,CAAC,CAAE,IAAI;UAAExD,IAAI,EAAEA;QAAK,CAAC;QAE5D,IAAKpB,OAAO,CAACY,GAAG,KAAKS,IAAI,EAAG;UAE3B,IAAK,CAAEkD,QAAQ,CAACtE,GAAG,EAAG;YAErBsE,QAAQ,CAACtE,GAAG,GAAG;cACd4E,KAAK,EAAE,IAAIC,YAAY,CAAEhB,SAAU,CAAC;cACpCiB,MAAM,EAAE,IAAID,YAAY,CAAEhB,SAAS,GAAG,CAAE;YACzC,CAAC;UAEF;UAEA,IAAK9D,OAAO,CAAC2D,qBAAqB,EAAG;YAEpC,IAAKlC,CAAC,KAAK,CAAC,EAAG;cAEd6C,cAAc,GAAGlD,IAAI,CAACQ,QAAQ,CAACC,KAAK,CAAC,CAAC;YAEvC;YAEAT,IAAI,CAACQ,QAAQ,CAACoD,GAAG,CAAEV,cAAe,CAAC;UAEpC;UAEAC,QAAQ,CAACtE,GAAG,CAAC4E,KAAK,CAAEpD,CAAC,CAAE,GAAGkD,IAAI;UAE9BvD,IAAI,CAACQ,QAAQ,CAACqD,OAAO,CAAEV,QAAQ,CAACtE,GAAG,CAAC8E,MAAM,EAAEtD,CAAC,GAAG,CAAE,CAAC;QAEpD;QAEA,IAAK,CAAE8C,QAAQ,CAACrE,IAAI,EAAG;UAEtBqE,QAAQ,CAACrE,IAAI,GAAG;YACf2E,KAAK,EAAE,IAAIC,YAAY,CAAEhB,SAAU,CAAC;YACpCiB,MAAM,EAAE,IAAID,YAAY,CAAEhB,SAAS,GAAG,CAAE;UACzC,CAAC;QAEF;QAEAS,QAAQ,CAACrE,IAAI,CAAC2E,KAAK,CAAEpD,CAAC,CAAE,GAAGkD,IAAI;QAE/BvD,IAAI,CAACkB,UAAU,CAAC2C,OAAO,CAAEV,QAAQ,CAACrE,IAAI,CAAC6E,MAAM,EAAEtD,CAAC,GAAG,CAAE,CAAC;MAEvD;IAED;IAEA2C,KAAK,CAACM,MAAM,CAAER,KAAM,CAAC;IAErBnE,MAAM,CAAC+B,iBAAiB,CAAC,CAAC;EAE3B;EAEA,KAAM,IAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4C,SAAS,CAAC3C,MAAM,EAAE,EAAGD,CAAC,EAAG;IAE7C8C,QAAQ,GAAGF,SAAS,CAAE5C,CAAC,CAAE;IAEzB,IAAK8C,QAAQ,EAAG;MAEf,IAAKA,QAAQ,CAACtE,GAAG,EAAG;QAEnBkE,eAAe,CAACxC,IAAI,CAAE,IAAI/B,mBAAmB,CAC5C,SAAS,GAAG2E,QAAQ,CAACnD,IAAI,CAACC,IAAI,GAAG,YAAY,EAC7CkD,QAAQ,CAACtE,GAAG,CAAC4E,KAAK,EAClBN,QAAQ,CAACtE,GAAG,CAAC8E,MACd,CAAE,CAAC;MAEJ;MAEAZ,eAAe,CAACxC,IAAI,CAAE,IAAInC,uBAAuB,CAChD,SAAS,GAAG+E,QAAQ,CAACnD,IAAI,CAACC,IAAI,GAAG,cAAc,EAC/CkD,QAAQ,CAACrE,IAAI,CAAC2E,KAAK,EACnBN,QAAQ,CAACrE,IAAI,CAAC6E,MACf,CAAE,CAAC;IAEJ;EAED;EAEAX,KAAK,CAACc,aAAa,CAAExB,IAAK,CAAC;EAE3B,OAAO,IAAIvE,aAAa,CAAEuE,IAAI,CAACrC,IAAI,EAAE,CAAE,CAAC,EAAE8C,eAAgB,CAAC;AAE5D;AAEA,SAASN,qBAAqBA,CAAE7C,QAAQ,EAAG;EAE1C,MAAMjB,MAAM,GAAG,IAAIN,cAAc,CAAEuB,QAAQ,CAACC,KAAK,CAAE,CAAC,CAAG,CAAC;EACxDlB,MAAM,CAACiB,QAAQ,GAAGA,QAAQ;EAE1B,OAAOjB,MAAM;AAEd;AAEA,SAASoF,kBAAkBA,CAAErF,MAAM,EAAEC,MAAM,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAG;EAE3D,MAAMoF,eAAe,GAAG,IAAIzF,OAAO,CAAC,CAAC;IACpC0F,SAAS,GAAG,IAAI1F,OAAO,CAAC,CAAC;IACzB2F,eAAe,GAAG,IAAI3F,OAAO,CAAC,CAAC;IAC/B4F,SAAS,GAAG,IAAI5F,OAAO,CAAC,CAAC;IACzB6F,SAAS,GAAG,IAAI9F,OAAO,CAAC,CAAC;IACzB+F,SAAS,GAAG,IAAI/F,OAAO,CAAC,CAAC;EAE1BM,OAAO,CAACY,GAAG,GAAGZ,OAAO,CAACY,GAAG,KAAKJ,SAAS,GAAGR,OAAO,CAACY,GAAG,GAAG,KAAK;EAC7DZ,OAAO,CAACa,KAAK,GAAGb,OAAO,CAACa,KAAK,IAAI,CAAC,CAAC;EAEnC,IAAK,CAAEd,MAAM,CAACgB,UAAU,EAAG;IAE1BhB,MAAM,GAAG8D,qBAAqB,CAAE9D,MAAO,CAAC;EAEzC;EAEA,MAAM2F,QAAQ,GAAGC,MAAM,CAACC,IAAI,CAAE5F,OAAO,CAACa,KAAM,CAAC;IAC5CgF,UAAU,GAAGF,MAAM,CAACZ,MAAM,CAAE/E,OAAO,CAACa,KAAM,CAAC;IAC3CC,WAAW,GAAGf,MAAM,CAACgB,UAAU,GAAGhB,MAAM,CAACiB,QAAQ,CAACC,KAAK,GAAGC,QAAQ,CAAEnB,MAAO,CAAC;IAC5EkB,KAAK,GAAGnB,MAAM,CAACiB,UAAU,GAAGjB,MAAM,CAACkB,QAAQ,CAACC,KAAK,GAAGC,QAAQ,CAAEpB,MAAO,CAAC;IACtEoC,OAAO,GAAG,EAAE;EAEb,IAAId,IAAI,EAAEE,MAAM,EACfD,IAAI,EAAEI,CAAC;EAER3B,MAAM,CAACkB,QAAQ,CAACQ,IAAI,CAAC,CAAC;EAEtB,KAAMC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,KAAK,CAACS,MAAM,EAAE,EAAGD,CAAC,EAAG;IAErCL,IAAI,GAAGH,KAAK,CAAEQ,CAAC,CAAE;IACjBJ,IAAI,GAAGrB,OAAO,CAACa,KAAK,CAAEO,IAAI,CAACC,IAAI,CAAE,IAAID,IAAI,CAACC,IAAI;IAE9CC,MAAM,GAAGiB,aAAa,CAAElB,IAAI,EAAEP,WAAY,CAAC;IAE3C,IAAKQ,MAAM,IAAID,IAAI,KAAKrB,OAAO,CAACY,GAAG,EAAG;MAErC,MAAMkF,UAAU,GAAGC,cAAc,CAAE3E,IAAI,CAACkC,MAAM,EAAEoC,QAAS,CAAC;QACzDM,YAAY,GAAGD,cAAc,CAAEzE,MAAM,CAACgC,MAAM,EAAEuC,UAAW,CAAC;MAE3DC,UAAU,CAAChE,iBAAiB,CAAC,CAAC;MAC9BkE,YAAY,CAAClE,iBAAiB,CAAC,CAAC;MAEhCsD,eAAe,CAACa,qBAAqB,CAAEH,UAAU,CAAC/D,WAAY,CAAC;MAC/DsD,SAAS,CAACY,qBAAqB,CAAE7E,IAAI,CAACW,WAAY,CAAC;MAEnDuD,eAAe,CAACW,qBAAqB,CAAED,YAAY,CAACjE,WAAY,CAAC;MACjEwD,SAAS,CAACU,qBAAqB,CAAE3E,MAAM,CAACS,WAAY,CAAC;MAErDyD,SAAS,CAACU,UAAU,CACnB,IAAIxG,OAAO,CAAE2F,SAAS,CAACzC,CAAC,EAAEyC,SAAS,CAACxC,CAAE,CAAC,EACvC,IAAInD,OAAO,CAAE0F,eAAe,CAACxC,CAAC,EAAEwC,eAAe,CAACvC,CAAE,CACnD,CAAC,CAACsD,SAAS,CAAC,CAAC;MAEbV,SAAS,CAACS,UAAU,CACnB,IAAIxG,OAAO,CAAE6F,SAAS,CAAC3C,CAAC,EAAE2C,SAAS,CAAC1C,CAAE,CAAC,EACvC,IAAInD,OAAO,CAAE4F,eAAe,CAAC1C,CAAC,EAAE0C,eAAe,CAACzC,CAAE,CACnD,CAAC,CAACsD,SAAS,CAAC,CAAC;MAEb,MAAMC,aAAa,GAAGZ,SAAS,CAACa,KAAK,CAAC,CAAC,GAAGZ,SAAS,CAACY,KAAK,CAAC,CAAC;MAE3D,MAAMC,MAAM,GAAG,IAAIhH,OAAO,CAAC,CAAC,CAACiH,qBAAqB,CACjD,IAAIlH,KAAK,CACR,CAAC,EACD,CAAC,EACD+G,aACD,CACD,CAAC;MAEDhF,IAAI,CAACe,MAAM,CAACC,QAAQ,CAAEkE,MAAO,CAAC;MAE9BlF,IAAI,CAACe,MAAM,CAACE,SAAS,CAAEjB,IAAI,CAACQ,QAAQ,EAAER,IAAI,CAACkB,UAAU,EAAElB,IAAI,CAACjB,KAAM,CAAC;MAEnEiB,IAAI,CAACU,iBAAiB,CAAC,CAAC;MAExBI,OAAO,CAAEb,IAAI,CAAE,GAAGiF,MAAM;IAEzB;EAED;EAEA,OAAOpE,OAAO;AAEf;AAEA,SAASsE,WAAWA,CAAExF,QAAQ,EAAEH,KAAK,EAAG;EAEvC,MAAMI,KAAK,GAAGC,QAAQ,CAAEF,QAAS,CAAC;EAElC,KAAM,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,KAAK,CAACS,MAAM,EAAE,EAAGD,CAAC,EAAG;IAEzC,MAAML,IAAI,GAAGH,KAAK,CAAEQ,CAAC,CAAE;IAEvB,IAAKZ,KAAK,CAAEO,IAAI,CAACC,IAAI,CAAE,EAAG;MAEzBD,IAAI,CAACC,IAAI,GAAGR,KAAK,CAAEO,IAAI,CAACC,IAAI,CAAE;IAE/B;EAED;EAEA,OAAO,IAAI;AAEZ;AAEA,SAASH,QAAQA,CAAEF,QAAQ,EAAG;EAE7B,OAAOyF,KAAK,CAACC,OAAO,CAAE1F,QAAS,CAAC,GAAGA,QAAQ,GAAGA,QAAQ,CAACC,KAAK;AAE7D;AAEA,SAASsB,aAAaA,CAAElB,IAAI,EAAEL,QAAQ,EAAG;EAExC,KAAM,IAAIS,CAAC,GAAG,CAAC,EAAER,KAAK,GAAGC,QAAQ,CAAEF,QAAS,CAAC,EAAES,CAAC,GAAGR,KAAK,CAACS,MAAM,EAAED,CAAC,EAAG,EAAG;IAEvE,IAAKJ,IAAI,KAAKJ,KAAK,CAAEQ,CAAC,CAAE,CAACJ,IAAI,EAE5B,OAAOJ,KAAK,CAAEQ,CAAC,CAAE;EAEnB;AAED;AAEA,SAASsE,cAAcA,CAAE3E,IAAI,EAAEP,KAAK,EAAG;EAEtC,OAAQO,IAAI,CAACmC,MAAM,EAAG;IAErB,IAAK1C,KAAK,CAACqC,OAAO,CAAE9B,IAAI,CAACC,IAAK,CAAC,KAAK,CAAE,CAAC,EAAG;MAEzC,OAAOD,IAAI;IAEZ;IAEAA,IAAI,GAAGA,IAAI,CAACkC,MAAM;EAEnB;AAED;AAEA,SAASqD,iBAAiBA,CAAEtF,IAAI,EAAEuF,MAAM,EAAG;EAE1C,MAAMC,MAAM,GAAG,gBAAgB;IAC9BC,MAAM,GAAG;MAAEzF,IAAI,EAAEA;IAAK,CAAC;EAExB,KAAM,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmF,MAAM,CAAClF,MAAM,EAAE,EAAGD,CAAC,EAAG;IAE1C;IACA;IACA,MAAMsF,SAAS,GAAGF,MAAM,CAACG,IAAI,CAAEJ,MAAM,CAAEnF,CAAC,CAAE,CAACJ,IAAK,CAAC;IAEjD,IAAK0F,SAAS,IAAI1F,IAAI,KAAK0F,SAAS,CAAE,CAAC,CAAE,EAAG;MAE3CD,MAAM,CAAEC,SAAS,CAAE,CAAC,CAAE,CAAE,GAAGtF,CAAC;IAE7B;EAED;EAEA,OAAOqF,MAAM;AAEd;AAEA,SAASG,mBAAmBA,CAAEjG,QAAQ,EAAEkG,cAAc,EAAG;EAExD,MAAMpG,WAAW,GAAGI,QAAQ,CAAEF,QAAS,CAAC;IACvCmG,WAAW,GAAGjG,QAAQ,CAAEgG,cAAe,CAAC;IACxCjG,KAAK,GAAG,EAAE;EAEXmG,MAAM,EAAG,KAAM,IAAI3F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,WAAW,CAACY,MAAM,EAAED,CAAC,EAAG,EAAG;IAExD,MAAM4F,QAAQ,GAAGvG,WAAW,CAAEW,CAAC,CAAE,CAACJ,IAAI;IAEtC,KAAM,IAAIuD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuC,WAAW,CAACzF,MAAM,EAAEkD,CAAC,EAAG,EAAG;MAE/C,IAAKyC,QAAQ,KAAKF,WAAW,CAAEvC,CAAC,CAAE,CAACvD,IAAI,EAAG;QAEzCJ,KAAK,CAACU,IAAI,CAAE0F,QAAS,CAAC;QAEtB,SAASD,MAAM;MAEhB;IAED;EAED;EAEA,OAAOnG,KAAK;AAEb;AAEA,SAASY,KAAKA,CAAE9B,MAAM,EAAG;EAExB,MAAMuH,YAAY,GAAG,IAAIC,GAAG,CAAC,CAAC;EAC9B,MAAMC,WAAW,GAAG,IAAID,GAAG,CAAC,CAAC;EAE7B,MAAM1F,KAAK,GAAG9B,MAAM,CAAC8B,KAAK,CAAC,CAAC;EAE5B4F,gBAAgB,CAAE1H,MAAM,EAAE8B,KAAK,EAAE,UAAW6F,UAAU,EAAEC,UAAU,EAAG;IAEpEL,YAAY,CAAC3E,GAAG,CAAEgF,UAAU,EAAED,UAAW,CAAC;IAC1CF,WAAW,CAAC7E,GAAG,CAAE+E,UAAU,EAAEC,UAAW,CAAC;EAE1C,CAAE,CAAC;EAEH9F,KAAK,CAAC+F,QAAQ,CAAE,UAAWC,IAAI,EAAG;IAEjC,IAAK,CAAEA,IAAI,CAACC,aAAa,EAAG;IAE5B,MAAMC,UAAU,GAAGF,IAAI;IACvB,MAAMG,UAAU,GAAGV,YAAY,CAACW,GAAG,CAAEJ,IAAK,CAAC;IAC3C,MAAM/G,WAAW,GAAGkH,UAAU,CAAChH,QAAQ,CAACC,KAAK;IAE7C8G,UAAU,CAAC/G,QAAQ,GAAGgH,UAAU,CAAChH,QAAQ,CAACa,KAAK,CAAC,CAAC;IACjDkG,UAAU,CAACG,UAAU,CAAC1F,IAAI,CAAEwF,UAAU,CAACE,UAAW,CAAC;IAEnDH,UAAU,CAAC/G,QAAQ,CAACC,KAAK,GAAGH,WAAW,CAACqH,GAAG,CAAE,UAAW/G,IAAI,EAAG;MAE9D,OAAOoG,WAAW,CAACS,GAAG,CAAE7G,IAAK,CAAC;IAE/B,CAAE,CAAC;IAEH2G,UAAU,CAACK,IAAI,CAAEL,UAAU,CAAC/G,QAAQ,EAAE+G,UAAU,CAACG,UAAW,CAAC;EAE9D,CAAE,CAAC;EAEH,OAAOrG,KAAK;AAEb;AAKA,SAAS4F,gBAAgBA,CAAEY,CAAC,EAAEC,CAAC,EAAEC,QAAQ,EAAG;EAE3CA,QAAQ,CAAEF,CAAC,EAAEC,CAAE,CAAC;EAEhB,KAAM,IAAI7G,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4G,CAAC,CAACpG,QAAQ,CAACP,MAAM,EAAED,CAAC,EAAG,EAAG;IAE9CgG,gBAAgB,CAAEY,CAAC,CAACpG,QAAQ,CAAER,CAAC,CAAE,EAAE6G,CAAC,CAACrG,QAAQ,CAAER,CAAC,CAAE,EAAE8G,QAAS,CAAC;EAE/D;AAED;AAEA,SACC1I,QAAQ,EACR4D,YAAY,EACZI,qBAAqB,EACrBsB,kBAAkB,EAClBqB,WAAW,EACXtF,QAAQ,EACRqB,aAAa,EACbwD,cAAc,EACdY,iBAAiB,EACjBM,mBAAmB,EACnBpF,KAAK"},"metadata":{},"sourceType":"module","externalDependencies":[]}