{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { property } from 'lit/decorators.js';\nimport { Spherical, Vector3 } from 'three';\nimport { style } from '../decorators.js';\nimport { $ariaLabel, $container, $getModelIsVisible, $loadedTime, $needsRender, $onModelLoad, $onResize, $renderer, $scene, $tick, $updateStatus, $userInputElement, toVector3D } from '../model-viewer-base.js';\nimport { degreesToRadians, normalizeUnit } from '../styles/conversions.js';\nimport { StyleEvaluator } from '../styles/evaluators.js';\nimport { numberNode, parseExpressions } from '../styles/parsers.js';\nimport { DECAY_MILLISECONDS } from '../three-components/Damper.js';\nimport { ChangeSource, SmoothControls } from '../three-components/SmoothControls.js';\nimport { timeline } from '../utilities/animation.js';\n// NOTE(cdata): The following \"animation\" timing functions are deliberately\n// being used in favor of CSS animations. In Safari 12.1 and 13, CSS animations\n// would cause the interaction prompt to glitch unexpectedly\n// @see https://github.com/google/model-viewer/issues/839\nconst PROMPT_ANIMATION_TIME = 5000;\n// For timing purposes, a \"frame\" is a timing agnostic relative unit of time\n// and a \"value\" is a target value for the Frame.\nconst wiggle = timeline({\n  initialValue: 0,\n  keyframes: [{\n    frames: 5,\n    value: -1\n  }, {\n    frames: 1,\n    value: -1\n  }, {\n    frames: 8,\n    value: 1\n  }, {\n    frames: 1,\n    value: 1\n  }, {\n    frames: 5,\n    value: 0\n  }, {\n    frames: 18,\n    value: 0\n  }]\n});\nconst fade = timeline({\n  initialValue: 0,\n  keyframes: [{\n    frames: 1,\n    value: 1\n  }, {\n    frames: 5,\n    value: 1\n  }, {\n    frames: 1,\n    value: 0\n  }, {\n    frames: 6,\n    value: 0\n  }]\n});\nexport const DEFAULT_FOV_DEG = 30;\nexport const DEFAULT_MIN_FOV_DEG = 12;\nexport const DEFAULT_CAMERA_ORBIT = '0deg 75deg 105%';\nconst DEFAULT_CAMERA_TARGET = 'auto auto auto';\nconst DEFAULT_FIELD_OF_VIEW = 'auto';\nconst MINIMUM_RADIUS_RATIO = 2.2;\nconst AZIMUTHAL_QUADRANT_LABELS = ['front', 'right', 'back', 'left'];\nconst POLAR_TRIENT_LABELS = ['upper-', '', 'lower-'];\nexport const DEFAULT_INTERACTION_PROMPT_THRESHOLD = 3000;\nexport const INTERACTION_PROMPT = '. Use mouse, touch or arrow keys to move.';\nexport const InteractionPromptStrategy = {\n  AUTO: 'auto',\n  NONE: 'none'\n};\nexport const InteractionPromptStyle = {\n  BASIC: 'basic',\n  WIGGLE: 'wiggle'\n};\nexport const TouchAction = {\n  PAN_Y: 'pan-y',\n  PAN_X: 'pan-x',\n  NONE: 'none'\n};\nexport const fieldOfViewIntrinsics = () => {\n  return {\n    basis: [degreesToRadians(numberNode(DEFAULT_FOV_DEG, 'deg'))],\n    keywords: {\n      auto: [null]\n    }\n  };\n};\nconst minFieldOfViewIntrinsics = () => {\n  return {\n    basis: [degreesToRadians(numberNode(DEFAULT_MIN_FOV_DEG, 'deg'))],\n    keywords: {\n      auto: [null]\n    }\n  };\n};\nexport const cameraOrbitIntrinsics = (() => {\n  const defaultTerms = parseExpressions(DEFAULT_CAMERA_ORBIT)[0].terms;\n  const theta = normalizeUnit(defaultTerms[0]);\n  const phi = normalizeUnit(defaultTerms[1]);\n  return element => {\n    const radius = element[$scene].idealCameraDistance();\n    return {\n      basis: [theta, phi, numberNode(radius, 'm')],\n      keywords: {\n        auto: [null, null, numberNode(105, '%')]\n      }\n    };\n  };\n})();\nconst minCameraOrbitIntrinsics = element => {\n  const radius = MINIMUM_RADIUS_RATIO * element[$scene].boundingSphere.radius;\n  return {\n    basis: [numberNode(-Infinity, 'rad'), numberNode(Math.PI / 8, 'rad'), numberNode(radius, 'm')],\n    keywords: {\n      auto: [null, null, null]\n    }\n  };\n};\nconst maxCameraOrbitIntrinsics = element => {\n  const orbitIntrinsics = cameraOrbitIntrinsics(element);\n  const evaluator = new StyleEvaluator([], orbitIntrinsics);\n  const defaultRadius = evaluator.evaluate()[2];\n  return {\n    basis: [numberNode(Infinity, 'rad'), numberNode(Math.PI - Math.PI / 8, 'rad'), numberNode(defaultRadius, 'm')],\n    keywords: {\n      auto: [null, null, null]\n    }\n  };\n};\nexport const cameraTargetIntrinsics = element => {\n  const center = element[$scene].boundingBox.getCenter(new Vector3());\n  return {\n    basis: [numberNode(center.x, 'm'), numberNode(center.y, 'm'), numberNode(center.z, 'm')],\n    keywords: {\n      auto: [null, null, null]\n    }\n  };\n};\nconst HALF_PI = Math.PI / 2.0;\nconst THIRD_PI = Math.PI / 3.0;\nconst QUARTER_PI = HALF_PI / 2.0;\nconst TAU = 2.0 * Math.PI;\nexport const $controls = Symbol('controls');\nexport const $panElement = Symbol('panElement');\nexport const $promptElement = Symbol('promptElement');\nexport const $promptAnimatedContainer = Symbol('promptAnimatedContainer');\nexport const $fingerAnimatedContainers = Symbol('fingerAnimatedContainers');\nconst $deferInteractionPrompt = Symbol('deferInteractionPrompt');\nconst $updateAria = Symbol('updateAria');\nconst $updateCameraForRadius = Symbol('updateCameraForRadius');\nconst $onChange = Symbol('onChange');\nconst $onPointerChange = Symbol('onPointerChange');\nconst $waitingToPromptUser = Symbol('waitingToPromptUser');\nconst $userHasInteracted = Symbol('userHasInteracted');\nconst $promptElementVisibleTime = Symbol('promptElementVisibleTime');\nconst $lastPromptOffset = Symbol('lastPromptOffset');\nconst $lastSpherical = Symbol('lastSpherical');\nconst $jumpCamera = Symbol('jumpCamera');\nconst $initialized = Symbol('initialized');\nconst $maintainThetaPhi = Symbol('maintainThetaPhi');\nconst $syncCameraOrbit = Symbol('syncCameraOrbit');\nconst $syncFieldOfView = Symbol('syncFieldOfView');\nconst $syncCameraTarget = Symbol('syncCameraTarget');\nconst $syncMinCameraOrbit = Symbol('syncMinCameraOrbit');\nconst $syncMaxCameraOrbit = Symbol('syncMaxCameraOrbit');\nconst $syncMinFieldOfView = Symbol('syncMinFieldOfView');\nconst $syncMaxFieldOfView = Symbol('syncMaxFieldOfView');\nexport const ControlsMixin = ModelViewerElement => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;\n  class ControlsModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this.cameraControls = false;\n      this.cameraOrbit = DEFAULT_CAMERA_ORBIT;\n      this.cameraTarget = DEFAULT_CAMERA_TARGET;\n      this.fieldOfView = DEFAULT_FIELD_OF_VIEW;\n      this.minCameraOrbit = 'auto';\n      this.maxCameraOrbit = 'auto';\n      this.minFieldOfView = 'auto';\n      this.maxFieldOfView = 'auto';\n      this.interactionPromptThreshold = DEFAULT_INTERACTION_PROMPT_THRESHOLD;\n      this.interactionPrompt = InteractionPromptStrategy.AUTO;\n      this.interactionPromptStyle = InteractionPromptStyle.WIGGLE;\n      this.orbitSensitivity = 1;\n      this.touchAction = TouchAction.NONE;\n      this.disableZoom = false;\n      this.disablePan = false;\n      this.disableTap = false;\n      this.interpolationDecay = DECAY_MILLISECONDS;\n      this[_a] = this.shadowRoot.querySelector('.interaction-prompt');\n      this[_b] = this.shadowRoot.querySelector('#prompt');\n      this[_c] = [this.shadowRoot.querySelector('#finger0'), this.shadowRoot.querySelector('#finger1')];\n      this[_d] = this.shadowRoot.querySelector('.pan-target');\n      this[_e] = 0;\n      this[_f] = Infinity;\n      this[_g] = false;\n      this[_h] = false;\n      this[_j] = new SmoothControls(this[$scene].camera, this[$userInputElement], this[$scene]);\n      this[_k] = new Spherical();\n      this[_l] = false;\n      this[_m] = false;\n      this[_o] = false;\n      this[_p] = ({\n        source\n      }) => {\n        this[$updateAria]();\n        this[$needsRender]();\n        if (source === ChangeSource.USER_INTERACTION) {\n          this[$userHasInteracted] = true;\n          this[$deferInteractionPrompt]();\n        }\n        this.dispatchEvent(new CustomEvent('camera-change', {\n          detail: {\n            source\n          }\n        }));\n      };\n      this[_q] = event => {\n        if (event.type === 'pointer-change-start') {\n          this[$container].classList.add('pointer-tumbling');\n        } else {\n          this[$container].classList.remove('pointer-tumbling');\n        }\n      };\n    }\n    get inputSensitivity() {\n      return this[$controls].inputSensitivity;\n    }\n    set inputSensitivity(value) {\n      this[$controls].inputSensitivity = value;\n    }\n    getCameraOrbit() {\n      const {\n        theta,\n        phi,\n        radius\n      } = this[$lastSpherical];\n      return {\n        theta,\n        phi,\n        radius,\n        toString() {\n          return `${this.theta}rad ${this.phi}rad ${this.radius}m`;\n        }\n      };\n    }\n    getCameraTarget() {\n      return toVector3D(this[$renderer].isPresenting ? this[$renderer].arRenderer.target : this[$scene].getTarget());\n    }\n    getFieldOfView() {\n      return this[$controls].getFieldOfView();\n    }\n    // Provided so user code does not have to parse these from attributes.\n    getMinimumFieldOfView() {\n      return this[$controls].options.minimumFieldOfView;\n    }\n    getMaximumFieldOfView() {\n      return this[$controls].options.maximumFieldOfView;\n    }\n    getIdealAspect() {\n      return this[$scene].idealAspect;\n    }\n    jumpCameraToGoal() {\n      this[$jumpCamera] = true;\n      this.requestUpdate($jumpCamera, false);\n    }\n    resetInteractionPrompt() {\n      this[$lastPromptOffset] = 0;\n      this[$promptElementVisibleTime] = Infinity;\n      this[$userHasInteracted] = false;\n      this[$waitingToPromptUser] = this.interactionPrompt === InteractionPromptStrategy.AUTO && this.cameraControls;\n    }\n    zoom(keyPresses) {\n      const event = new WheelEvent('wheel', {\n        deltaY: -30 * keyPresses\n      });\n      this[$userInputElement].dispatchEvent(event);\n    }\n    connectedCallback() {\n      super.connectedCallback();\n      this[$controls].addEventListener('change', this[$onChange]);\n      this[$controls].addEventListener('pointer-change-start', this[$onPointerChange]);\n      this[$controls].addEventListener('pointer-change-end', this[$onPointerChange]);\n    }\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      this[$controls].removeEventListener('change', this[$onChange]);\n      this[$controls].removeEventListener('pointer-change-start', this[$onPointerChange]);\n      this[$controls].removeEventListener('pointer-change-end', this[$onPointerChange]);\n    }\n    updated(changedProperties) {\n      super.updated(changedProperties);\n      const controls = this[$controls];\n      const scene = this[$scene];\n      if (changedProperties.has('cameraControls')) {\n        if (this.cameraControls) {\n          controls.enableInteraction();\n          if (this.interactionPrompt === InteractionPromptStrategy.AUTO) {\n            this[$waitingToPromptUser] = true;\n          }\n        } else {\n          controls.disableInteraction();\n          this[$deferInteractionPrompt]();\n        }\n        this[$userInputElement].setAttribute('aria-label', this[$ariaLabel]);\n      }\n      if (changedProperties.has('disableZoom')) {\n        controls.disableZoom = this.disableZoom;\n      }\n      if (changedProperties.has('disablePan')) {\n        controls.enablePan = !this.disablePan;\n      }\n      if (changedProperties.has('disableTap')) {\n        controls.enableTap = !this.disableTap;\n      }\n      if (changedProperties.has('interactionPrompt') || changedProperties.has('cameraControls') || changedProperties.has('src')) {\n        if (this.interactionPrompt === InteractionPromptStrategy.AUTO && this.cameraControls && !this[$userHasInteracted]) {\n          this[$waitingToPromptUser] = true;\n        } else {\n          this[$deferInteractionPrompt]();\n        }\n      }\n      if (changedProperties.has('interactionPromptStyle')) {\n        this[$promptAnimatedContainer].style.opacity = this.interactionPromptStyle == InteractionPromptStyle.BASIC ? '1' : '0';\n      }\n      if (changedProperties.has('touchAction')) {\n        const touchAction = this.touchAction;\n        controls.applyOptions({\n          touchAction\n        });\n        controls.updateTouchActionStyle();\n      }\n      if (changedProperties.has('orbitSensitivity')) {\n        controls.orbitSensitivity = this.orbitSensitivity;\n      }\n      if (changedProperties.has('interpolationDecay')) {\n        controls.setDamperDecayTime(this.interpolationDecay);\n        scene.setTargetDamperDecayTime(this.interpolationDecay);\n      }\n      if (this[$jumpCamera] === true) {\n        Promise.resolve().then(() => {\n          controls.jumpToGoal();\n          scene.jumpToGoal();\n          this[$jumpCamera] = false;\n        });\n      }\n    }\n    async updateFraming() {\n      const scene = this[$scene];\n      const oldFramedFoV = scene.adjustedFoV(scene.framedFoVDeg);\n      await scene.updateFraming();\n      const newFramedFoV = scene.adjustedFoV(scene.framedFoVDeg);\n      const zoom = this[$controls].getFieldOfView() / oldFramedFoV;\n      this[$controls].setFieldOfView(newFramedFoV * zoom);\n      this[$maintainThetaPhi] = true;\n      this.requestUpdate('maxFieldOfView');\n      this.requestUpdate('fieldOfView');\n      this.requestUpdate('minCameraOrbit');\n      this.requestUpdate('maxCameraOrbit');\n      this.requestUpdate('cameraOrbit');\n      await this.updateComplete;\n    }\n    interact(duration, finger0, finger1) {\n      const inputElement = this[$userInputElement];\n      const fingerElements = this[$fingerAnimatedContainers];\n      if (fingerElements[0].style.opacity === '1') {\n        console.warn('interact() failed because an existing interaction is running.');\n        return;\n      }\n      const xy = new Array();\n      xy.push({\n        x: timeline(finger0.x),\n        y: timeline(finger0.y)\n      });\n      const positions = [{\n        x: xy[0].x(0),\n        y: xy[0].y(0)\n      }];\n      if (finger1 != null) {\n        xy.push({\n          x: timeline(finger1.x),\n          y: timeline(finger1.y)\n        });\n        positions.push({\n          x: xy[1].x(0),\n          y: xy[1].y(0)\n        });\n      }\n      let startTime = performance.now();\n      const {\n        width,\n        height\n      } = this[$scene];\n      const dispatchTouches = type => {\n        for (const [i, position] of positions.entries()) {\n          const {\n            style\n          } = fingerElements[i];\n          style.transform = `translateX(${width * position.x}px) translateY(${height * position.y}px)`;\n          if (type === 'pointerdown') {\n            style.opacity = '1';\n          } else if (type === 'pointerup') {\n            style.opacity = '0';\n          }\n          const init = {\n            pointerId: i - 5678,\n            pointerType: 'touch',\n            target: inputElement,\n            clientX: width * position.x,\n            clientY: height * position.y,\n            altKey: true // flag that this is not a user interaction\n          };\n\n          inputElement.dispatchEvent(new PointerEvent(type, init));\n        }\n      };\n      const moveTouches = () => {\n        // Cancel interaction if something else moves the camera or input is\n        // removed from the DOM.\n        const {\n          changeSource\n        } = this[$controls];\n        if (changeSource !== ChangeSource.AUTOMATIC || !inputElement.isConnected) {\n          for (const fingerElement of this[$fingerAnimatedContainers]) {\n            fingerElement.style.opacity = '0';\n          }\n          dispatchTouches('pointercancel');\n          this.dispatchEvent(new CustomEvent('interact-stopped', {\n            detail: {\n              source: changeSource\n            }\n          }));\n          document.removeEventListener('visibilitychange', onVisibilityChange);\n          return;\n        }\n        const time = Math.min(1, (performance.now() - startTime) / duration);\n        for (const [i, position] of positions.entries()) {\n          position.x = xy[i].x(time);\n          position.y = xy[i].y(time);\n        }\n        dispatchTouches('pointermove');\n        if (time < 1) {\n          requestAnimationFrame(moveTouches);\n        } else {\n          dispatchTouches('pointerup');\n          this.dispatchEvent(new CustomEvent('interact-stopped', {\n            detail: {\n              source: changeSource\n            }\n          }));\n          document.removeEventListener('visibilitychange', onVisibilityChange);\n        }\n      };\n      const onVisibilityChange = () => {\n        let elapsed = 0;\n        if (document.visibilityState === 'hidden') {\n          elapsed = performance.now() - startTime;\n        } else {\n          startTime = performance.now() - elapsed;\n        }\n      };\n      document.addEventListener('visibilitychange', onVisibilityChange);\n      dispatchTouches('pointerdown');\n      requestAnimationFrame(moveTouches);\n    }\n    [(_a = $promptElement, _b = $promptAnimatedContainer, _c = $fingerAnimatedContainers, _d = $panElement, _e = $lastPromptOffset, _f = $promptElementVisibleTime, _g = $userHasInteracted, _h = $waitingToPromptUser, _j = $controls, _k = $lastSpherical, _l = $jumpCamera, _m = $initialized, _o = $maintainThetaPhi, $syncFieldOfView)](style) {\n      const scene = this[$scene];\n      scene.framedFoVDeg = style[0] * 180 / Math.PI;\n      this[$controls].setFieldOfView(scene.adjustedFoV(scene.framedFoVDeg));\n    }\n    [$syncCameraOrbit](style) {\n      const controls = this[$controls];\n      if (this[$maintainThetaPhi]) {\n        const {\n          theta,\n          phi\n        } = this.getCameraOrbit();\n        style[0] = theta;\n        style[1] = phi;\n        this[$maintainThetaPhi] = false;\n      }\n      controls.changeSource = ChangeSource.NONE;\n      controls.setOrbit(style[0], style[1], style[2]);\n    }\n    [$syncMinCameraOrbit](style) {\n      this[$controls].applyOptions({\n        minimumAzimuthalAngle: style[0],\n        minimumPolarAngle: style[1],\n        minimumRadius: style[2]\n      });\n      this.jumpCameraToGoal();\n    }\n    [$syncMaxCameraOrbit](style) {\n      this[$controls].applyOptions({\n        maximumAzimuthalAngle: style[0],\n        maximumPolarAngle: style[1],\n        maximumRadius: style[2]\n      });\n      this[$updateCameraForRadius](style[2]);\n      this.jumpCameraToGoal();\n    }\n    [$syncMinFieldOfView](style) {\n      this[$controls].applyOptions({\n        minimumFieldOfView: style[0] * 180 / Math.PI\n      });\n      this.jumpCameraToGoal();\n    }\n    [$syncMaxFieldOfView](style) {\n      const fov = this[$scene].adjustedFoV(style[0] * 180 / Math.PI);\n      this[$controls].applyOptions({\n        maximumFieldOfView: fov\n      });\n      this.jumpCameraToGoal();\n    }\n    [$syncCameraTarget](style) {\n      const [x, y, z] = style;\n      if (!this[$renderer].arRenderer.isPresenting) {\n        this[$scene].setTarget(x, y, z);\n      }\n      this[$controls].changeSource = ChangeSource.NONE;\n      this[$renderer].arRenderer.updateTarget();\n    }\n    [$tick](time, delta) {\n      super[$tick](time, delta);\n      if (this[$renderer].isPresenting || !this[$getModelIsVisible]()) {\n        return;\n      }\n      const controls = this[$controls];\n      const scene = this[$scene];\n      const now = performance.now();\n      if (this[$waitingToPromptUser]) {\n        if (this.loaded && now > this[$loadedTime] + this.interactionPromptThreshold) {\n          this[$waitingToPromptUser] = false;\n          this[$promptElementVisibleTime] = now;\n          this[$promptElement].classList.add('visible');\n        }\n      }\n      if (isFinite(this[$promptElementVisibleTime]) && this.interactionPromptStyle === InteractionPromptStyle.WIGGLE) {\n        const animationTime = (now - this[$promptElementVisibleTime]) / PROMPT_ANIMATION_TIME % 1;\n        const offset = wiggle(animationTime);\n        const opacity = fade(animationTime);\n        this[$promptAnimatedContainer].style.opacity = `${opacity}`;\n        if (offset !== this[$lastPromptOffset]) {\n          const xOffset = offset * scene.width * 0.05;\n          const deltaTheta = (offset - this[$lastPromptOffset]) * Math.PI / 16;\n          this[$promptAnimatedContainer].style.transform = `translateX(${xOffset}px)`;\n          controls.changeSource = ChangeSource.AUTOMATIC;\n          controls.adjustOrbit(deltaTheta, 0, 0);\n          this[$lastPromptOffset] = offset;\n        }\n      }\n      controls.update(time, delta);\n      if (scene.updateTarget(delta)) {\n        this[$onChange]({\n          type: 'change',\n          source: controls.changeSource\n        });\n      }\n    }\n    [$deferInteractionPrompt]() {\n      // Effectively cancel the timer waiting for user interaction:\n      this[$waitingToPromptUser] = false;\n      this[$promptElement].classList.remove('visible');\n      this[$promptElementVisibleTime] = Infinity;\n    }\n    /**\n     * Updates the camera's near and far planes to enclose the scene when\n     * orbiting at the supplied radius.\n     */\n    [$updateCameraForRadius](radius) {\n      const maximumRadius = Math.max(this[$scene].boundingSphere.radius, radius);\n      const near = 0;\n      const far = 2 * maximumRadius;\n      this[$controls].updateNearFar(near, far);\n    }\n    [$updateAria]() {\n      const {\n        theta,\n        phi\n      } = this[$controls].getCameraSpherical(this[$lastSpherical]);\n      const azimuthalQuadrant = (4 + Math.floor((theta % TAU + QUARTER_PI) / HALF_PI)) % 4;\n      const polarTrient = Math.floor(phi / THIRD_PI);\n      const azimuthalQuadrantLabel = AZIMUTHAL_QUADRANT_LABELS[azimuthalQuadrant];\n      const polarTrientLabel = POLAR_TRIENT_LABELS[polarTrient];\n      this[$updateStatus](`View from stage ${polarTrientLabel}${azimuthalQuadrantLabel}`);\n    }\n    get [$ariaLabel]() {\n      return super[$ariaLabel] + (this.cameraControls ? INTERACTION_PROMPT : '');\n    }\n    async [$onResize](event) {\n      const controls = this[$controls];\n      const scene = this[$scene];\n      const oldFramedFoV = scene.adjustedFoV(scene.framedFoVDeg);\n      // The super of $onResize may update the scene's adjustedFoV, so we\n      // compare the before and after to calculate the proper zoom.\n      super[$onResize](event);\n      const fovRatio = scene.adjustedFoV(scene.framedFoVDeg) / oldFramedFoV;\n      const fov = controls.getFieldOfView() * (isFinite(fovRatio) ? fovRatio : 1);\n      controls.updateAspect(this[$scene].aspect);\n      this.requestUpdate('maxFieldOfView', this.maxFieldOfView);\n      await this.updateComplete;\n      this[$controls].setFieldOfView(fov);\n      this.jumpCameraToGoal();\n    }\n    [$onModelLoad]() {\n      super[$onModelLoad]();\n      if (this[$initialized]) {\n        this[$maintainThetaPhi] = true;\n      } else {\n        this[$initialized] = true;\n      }\n      this.requestUpdate('maxFieldOfView', this.maxFieldOfView);\n      this.requestUpdate('fieldOfView', this.fieldOfView);\n      this.requestUpdate('minCameraOrbit', this.minCameraOrbit);\n      this.requestUpdate('maxCameraOrbit', this.maxCameraOrbit);\n      this.requestUpdate('cameraOrbit', this.cameraOrbit);\n      this.requestUpdate('cameraTarget', this.cameraTarget);\n      this.jumpCameraToGoal();\n    }\n  }\n  _p = $onChange, _q = $onPointerChange;\n  __decorate([property({\n    type: Boolean,\n    attribute: 'camera-controls'\n  })], ControlsModelViewerElement.prototype, \"cameraControls\", void 0);\n  __decorate([style({\n    intrinsics: cameraOrbitIntrinsics,\n    observeEffects: true,\n    updateHandler: $syncCameraOrbit\n  }), property({\n    type: String,\n    attribute: 'camera-orbit',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"cameraOrbit\", void 0);\n  __decorate([style({\n    intrinsics: cameraTargetIntrinsics,\n    observeEffects: true,\n    updateHandler: $syncCameraTarget\n  }), property({\n    type: String,\n    attribute: 'camera-target',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"cameraTarget\", void 0);\n  __decorate([style({\n    intrinsics: fieldOfViewIntrinsics,\n    observeEffects: true,\n    updateHandler: $syncFieldOfView\n  }), property({\n    type: String,\n    attribute: 'field-of-view',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"fieldOfView\", void 0);\n  __decorate([style({\n    intrinsics: minCameraOrbitIntrinsics,\n    updateHandler: $syncMinCameraOrbit\n  }), property({\n    type: String,\n    attribute: 'min-camera-orbit',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"minCameraOrbit\", void 0);\n  __decorate([style({\n    intrinsics: maxCameraOrbitIntrinsics,\n    updateHandler: $syncMaxCameraOrbit\n  }), property({\n    type: String,\n    attribute: 'max-camera-orbit',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"maxCameraOrbit\", void 0);\n  __decorate([style({\n    intrinsics: minFieldOfViewIntrinsics,\n    updateHandler: $syncMinFieldOfView\n  }), property({\n    type: String,\n    attribute: 'min-field-of-view',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"minFieldOfView\", void 0);\n  __decorate([style({\n    intrinsics: fieldOfViewIntrinsics,\n    updateHandler: $syncMaxFieldOfView\n  }), property({\n    type: String,\n    attribute: 'max-field-of-view',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"maxFieldOfView\", void 0);\n  __decorate([property({\n    type: Number,\n    attribute: 'interaction-prompt-threshold'\n  })], ControlsModelViewerElement.prototype, \"interactionPromptThreshold\", void 0);\n  __decorate([property({\n    type: String,\n    attribute: 'interaction-prompt'\n  })], ControlsModelViewerElement.prototype, \"interactionPrompt\", void 0);\n  __decorate([property({\n    type: String,\n    attribute: 'interaction-prompt-style'\n  })], ControlsModelViewerElement.prototype, \"interactionPromptStyle\", void 0);\n  __decorate([property({\n    type: Number,\n    attribute: 'orbit-sensitivity'\n  })], ControlsModelViewerElement.prototype, \"orbitSensitivity\", void 0);\n  __decorate([property({\n    type: String,\n    attribute: 'touch-action'\n  })], ControlsModelViewerElement.prototype, \"touchAction\", void 0);\n  __decorate([property({\n    type: Boolean,\n    attribute: 'disable-zoom'\n  })], ControlsModelViewerElement.prototype, \"disableZoom\", void 0);\n  __decorate([property({\n    type: Boolean,\n    attribute: 'disable-pan'\n  })], ControlsModelViewerElement.prototype, \"disablePan\", void 0);\n  __decorate([property({\n    type: Boolean,\n    attribute: 'disable-tap'\n  })], ControlsModelViewerElement.prototype, \"disableTap\", void 0);\n  __decorate([property({\n    type: Number,\n    attribute: 'interpolation-decay'\n  })], ControlsModelViewerElement.prototype, \"interpolationDecay\", void 0);\n  return ControlsModelViewerElement;\n};","map":{"version":3,"names":["property","Spherical","Vector3","style","$ariaLabel","$container","$getModelIsVisible","$loadedTime","$needsRender","$onModelLoad","$onResize","$renderer","$scene","$tick","$updateStatus","$userInputElement","toVector3D","degreesToRadians","normalizeUnit","StyleEvaluator","numberNode","parseExpressions","DECAY_MILLISECONDS","ChangeSource","SmoothControls","timeline","PROMPT_ANIMATION_TIME","wiggle","initialValue","keyframes","frames","value","fade","DEFAULT_FOV_DEG","DEFAULT_MIN_FOV_DEG","DEFAULT_CAMERA_ORBIT","DEFAULT_CAMERA_TARGET","DEFAULT_FIELD_OF_VIEW","MINIMUM_RADIUS_RATIO","AZIMUTHAL_QUADRANT_LABELS","POLAR_TRIENT_LABELS","DEFAULT_INTERACTION_PROMPT_THRESHOLD","INTERACTION_PROMPT","InteractionPromptStrategy","AUTO","NONE","InteractionPromptStyle","BASIC","WIGGLE","TouchAction","PAN_Y","PAN_X","fieldOfViewIntrinsics","basis","keywords","auto","minFieldOfViewIntrinsics","cameraOrbitIntrinsics","defaultTerms","terms","theta","phi","element","radius","idealCameraDistance","minCameraOrbitIntrinsics","boundingSphere","Infinity","Math","PI","maxCameraOrbitIntrinsics","orbitIntrinsics","evaluator","defaultRadius","evaluate","cameraTargetIntrinsics","center","boundingBox","getCenter","x","y","z","HALF_PI","THIRD_PI","QUARTER_PI","TAU","$controls","Symbol","$panElement","$promptElement","$promptAnimatedContainer","$fingerAnimatedContainers","$deferInteractionPrompt","$updateAria","$updateCameraForRadius","$onChange","$onPointerChange","$waitingToPromptUser","$userHasInteracted","$promptElementVisibleTime","$lastPromptOffset","$lastSpherical","$jumpCamera","$initialized","$maintainThetaPhi","$syncCameraOrbit","$syncFieldOfView","$syncCameraTarget","$syncMinCameraOrbit","$syncMaxCameraOrbit","$syncMinFieldOfView","$syncMaxFieldOfView","ControlsMixin","ModelViewerElement","ControlsModelViewerElement","constructor","cameraControls","cameraOrbit","cameraTarget","fieldOfView","minCameraOrbit","maxCameraOrbit","minFieldOfView","maxFieldOfView","interactionPromptThreshold","interactionPrompt","interactionPromptStyle","orbitSensitivity","touchAction","disableZoom","disablePan","disableTap","interpolationDecay","_a","shadowRoot","querySelector","_b","_c","_d","_e","_f","_g","_h","_j","camera","_k","_l","_m","_o","_p","source","USER_INTERACTION","dispatchEvent","CustomEvent","detail","_q","event","type","classList","add","remove","inputSensitivity","getCameraOrbit","toString","getCameraTarget","isPresenting","arRenderer","target","getTarget","getFieldOfView","getMinimumFieldOfView","options","minimumFieldOfView","getMaximumFieldOfView","maximumFieldOfView","getIdealAspect","idealAspect","jumpCameraToGoal","requestUpdate","resetInteractionPrompt","zoom","keyPresses","WheelEvent","deltaY","connectedCallback","addEventListener","disconnectedCallback","removeEventListener","updated","changedProperties","controls","scene","has","enableInteraction","disableInteraction","setAttribute","enablePan","enableTap","opacity","applyOptions","updateTouchActionStyle","setDamperDecayTime","setTargetDamperDecayTime","Promise","resolve","then","jumpToGoal","updateFraming","oldFramedFoV","adjustedFoV","framedFoVDeg","newFramedFoV","setFieldOfView","updateComplete","interact","duration","finger0","finger1","inputElement","fingerElements","console","warn","xy","Array","push","positions","startTime","performance","now","width","height","dispatchTouches","i","position","entries","transform","init","pointerId","pointerType","clientX","clientY","altKey","PointerEvent","moveTouches","changeSource","AUTOMATIC","isConnected","fingerElement","document","onVisibilityChange","time","min","requestAnimationFrame","elapsed","visibilityState","setOrbit","minimumAzimuthalAngle","minimumPolarAngle","minimumRadius","maximumAzimuthalAngle","maximumPolarAngle","maximumRadius","fov","setTarget","updateTarget","delta","loaded","isFinite","animationTime","offset","xOffset","deltaTheta","adjustOrbit","update","max","near","far","updateNearFar","getCameraSpherical","azimuthalQuadrant","floor","polarTrient","azimuthalQuadrantLabel","polarTrientLabel","fovRatio","updateAspect","aspect","__decorate","Boolean","attribute","intrinsics","observeEffects","updateHandler","String","hasChanged","Number"],"sources":["C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\@google\\model-viewer\\src\\features\\controls.ts"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {property} from 'lit/decorators.js';\nimport {Event, PerspectiveCamera, Spherical, Vector3} from 'three';\n\nimport {style} from '../decorators.js';\nimport ModelViewerElementBase, {$ariaLabel, $container, $getModelIsVisible, $loadedTime, $needsRender, $onModelLoad, $onResize, $renderer, $scene, $tick, $updateStatus, $userInputElement, toVector3D, Vector3D} from '../model-viewer-base.js';\nimport {degreesToRadians, normalizeUnit} from '../styles/conversions.js';\nimport {EvaluatedStyle, Intrinsics, SphericalIntrinsics, StyleEvaluator, Vector3Intrinsics} from '../styles/evaluators.js';\nimport {IdentNode, NumberNode, numberNode, parseExpressions} from '../styles/parsers.js';\nimport {DECAY_MILLISECONDS} from '../three-components/Damper.js';\nimport {ChangeEvent, ChangeSource, PointerChangeEvent, SmoothControls} from '../three-components/SmoothControls.js';\nimport {Constructor} from '../utilities.js';\nimport {Path, timeline, TimingFunction} from '../utilities/animation.js';\n\n\n\n// NOTE(cdata): The following \"animation\" timing functions are deliberately\n// being used in favor of CSS animations. In Safari 12.1 and 13, CSS animations\n// would cause the interaction prompt to glitch unexpectedly\n// @see https://github.com/google/model-viewer/issues/839\nconst PROMPT_ANIMATION_TIME = 5000;\n\n// For timing purposes, a \"frame\" is a timing agnostic relative unit of time\n// and a \"value\" is a target value for the Frame.\nconst wiggle = timeline({\n  initialValue: 0,\n  keyframes: [\n    {frames: 5, value: -1},\n    {frames: 1, value: -1},\n    {frames: 8, value: 1},\n    {frames: 1, value: 1},\n    {frames: 5, value: 0},\n    {frames: 18, value: 0}\n  ]\n});\n\nconst fade = timeline({\n  initialValue: 0,\n  keyframes: [\n    {frames: 1, value: 1},\n    {frames: 5, value: 1},\n    {frames: 1, value: 0},\n    {frames: 6, value: 0}\n  ]\n});\n\nexport const DEFAULT_FOV_DEG = 30;\nexport const DEFAULT_MIN_FOV_DEG = 12;\n\nexport const DEFAULT_CAMERA_ORBIT = '0deg 75deg 105%';\nconst DEFAULT_CAMERA_TARGET = 'auto auto auto';\nconst DEFAULT_FIELD_OF_VIEW = 'auto';\n\nconst MINIMUM_RADIUS_RATIO = 2.2;\n\nconst AZIMUTHAL_QUADRANT_LABELS = ['front', 'right', 'back', 'left'];\nconst POLAR_TRIENT_LABELS = ['upper-', '', 'lower-'];\n\nexport const DEFAULT_INTERACTION_PROMPT_THRESHOLD = 3000;\nexport const INTERACTION_PROMPT = '. Use mouse, touch or arrow keys to move.';\n\nexport interface CameraChangeDetails {\n  source: ChangeSource;\n}\n\nexport interface SphericalPosition {\n  theta: number;  // equator angle around the y (up) axis.\n  phi: number;    // polar angle from the y (up) axis.\n  radius: number;\n  toString(): string;\n}\n\nexport interface Finger {\n  x: Path;\n  y: Path;\n}\n\nexport type InteractionPromptStrategy = 'auto'|'none';\nexport type InteractionPromptStyle = 'basic'|'wiggle';\nexport type TouchAction = 'pan-y'|'pan-x'|'none';\n\nexport const InteractionPromptStrategy:\n    {[index: string]: InteractionPromptStrategy} = {\n      AUTO: 'auto',\n      NONE: 'none'\n    };\n\nexport const InteractionPromptStyle:\n    {[index: string]: InteractionPromptStyle} = {\n      BASIC: 'basic',\n      WIGGLE: 'wiggle'\n    };\n\nexport const TouchAction: {[index: string]: TouchAction} = {\n  PAN_Y: 'pan-y',\n  PAN_X: 'pan-x',\n  NONE: 'none'\n};\n\nexport const fieldOfViewIntrinsics = () => {\n  return {\n    basis:\n        [degreesToRadians(numberNode(DEFAULT_FOV_DEG, 'deg')) as\n         NumberNode<'rad'>],\n    keywords: {auto: [null]}\n  };\n};\n\nconst minFieldOfViewIntrinsics = () => {\n  return {\n    basis:\n        [degreesToRadians(numberNode(DEFAULT_MIN_FOV_DEG, 'deg')) as\n         NumberNode<'rad'>],\n    keywords: {auto: [null]}\n  };\n};\n\nexport const cameraOrbitIntrinsics = (() => {\n  const defaultTerms =\n      parseExpressions(DEFAULT_CAMERA_ORBIT)[0]\n          .terms as [NumberNode<'rad'>, NumberNode<'rad'>, IdentNode];\n\n  const theta = normalizeUnit(defaultTerms[0]) as NumberNode<'rad'>;\n  const phi = normalizeUnit(defaultTerms[1]) as NumberNode<'rad'>;\n\n  return (element: ModelViewerElementBase) => {\n    const radius = element[$scene].idealCameraDistance();\n\n    return {\n      basis: [theta, phi, numberNode(radius, 'm')],\n      keywords: {auto: [null, null, numberNode(105, '%')]}\n    };\n  };\n})();\n\nconst minCameraOrbitIntrinsics = (element: ModelViewerElementBase&\n                                  ControlsInterface) => {\n  const radius = MINIMUM_RADIUS_RATIO * element[$scene].boundingSphere.radius;\n\n  return {\n    basis: [\n      numberNode(-Infinity, 'rad'),\n      numberNode(Math.PI / 8, 'rad'),\n      numberNode(radius, 'm')\n    ],\n    keywords: {auto: [null, null, null]}\n  };\n};\n\nconst maxCameraOrbitIntrinsics = (element: ModelViewerElementBase) => {\n  const orbitIntrinsics = cameraOrbitIntrinsics(element);\n  const evaluator = new StyleEvaluator([], orbitIntrinsics);\n  const defaultRadius = evaluator.evaluate()[2];\n\n  return {\n    basis: [\n      numberNode(Infinity, 'rad'),\n      numberNode(Math.PI - Math.PI / 8, 'rad'),\n      numberNode(defaultRadius, 'm')\n    ],\n    keywords: {auto: [null, null, null]}\n  };\n};\n\nexport const cameraTargetIntrinsics = (element: ModelViewerElementBase) => {\n  const center = element[$scene].boundingBox.getCenter(new Vector3());\n\n  return {\n    basis: [\n      numberNode(center.x, 'm'),\n      numberNode(center.y, 'm'),\n      numberNode(center.z, 'm')\n    ],\n    keywords: {auto: [null, null, null]}\n  };\n};\n\nconst HALF_PI = Math.PI / 2.0;\nconst THIRD_PI = Math.PI / 3.0;\nconst QUARTER_PI = HALF_PI / 2.0;\nconst TAU = 2.0 * Math.PI;\n\nexport const $controls = Symbol('controls');\nexport const $panElement = Symbol('panElement');\nexport const $promptElement = Symbol('promptElement');\nexport const $promptAnimatedContainer = Symbol('promptAnimatedContainer');\nexport const $fingerAnimatedContainers = Symbol('fingerAnimatedContainers');\n\nconst $deferInteractionPrompt = Symbol('deferInteractionPrompt');\nconst $updateAria = Symbol('updateAria');\nconst $updateCameraForRadius = Symbol('updateCameraForRadius');\n\nconst $onChange = Symbol('onChange');\nconst $onPointerChange = Symbol('onPointerChange');\n\nconst $waitingToPromptUser = Symbol('waitingToPromptUser');\nconst $userHasInteracted = Symbol('userHasInteracted');\nconst $promptElementVisibleTime = Symbol('promptElementVisibleTime');\nconst $lastPromptOffset = Symbol('lastPromptOffset');\n\nconst $lastSpherical = Symbol('lastSpherical');\nconst $jumpCamera = Symbol('jumpCamera');\nconst $initialized = Symbol('initialized');\nconst $maintainThetaPhi = Symbol('maintainThetaPhi');\n\nconst $syncCameraOrbit = Symbol('syncCameraOrbit');\nconst $syncFieldOfView = Symbol('syncFieldOfView');\nconst $syncCameraTarget = Symbol('syncCameraTarget');\n\nconst $syncMinCameraOrbit = Symbol('syncMinCameraOrbit');\nconst $syncMaxCameraOrbit = Symbol('syncMaxCameraOrbit');\nconst $syncMinFieldOfView = Symbol('syncMinFieldOfView');\nconst $syncMaxFieldOfView = Symbol('syncMaxFieldOfView');\n\nexport declare interface ControlsInterface {\n  cameraControls: boolean;\n  cameraOrbit: string;\n  cameraTarget: string;\n  fieldOfView: string;\n  minCameraOrbit: string;\n  maxCameraOrbit: string;\n  minFieldOfView: string;\n  maxFieldOfView: string;\n  interactionPrompt: InteractionPromptStrategy;\n  interactionPromptStyle: InteractionPromptStyle;\n  interactionPromptThreshold: number;\n  orbitSensitivity: number;\n  touchAction: TouchAction;\n  interpolationDecay: number;\n  disableZoom: boolean;\n  disablePan: boolean;\n  disableTap: boolean;\n  getCameraOrbit(): SphericalPosition;\n  getCameraTarget(): Vector3D;\n  getFieldOfView(): number;\n  getMinimumFieldOfView(): number;\n  getMaximumFieldOfView(): number;\n  getIdealAspect(): number;\n  jumpCameraToGoal(): void;\n  updateFraming(): Promise<void>;\n  resetInteractionPrompt(): void;\n  zoom(keyPresses: number): void;\n  interact(duration: number, finger0: Finger, finger1?: Finger): void;\n  inputSensitivity: number;\n}\n\nexport const ControlsMixin = <T extends Constructor<ModelViewerElementBase>>(\n    ModelViewerElement: T): Constructor<ControlsInterface>&T => {\n  class ControlsModelViewerElement extends ModelViewerElement {\n    @property({type: Boolean, attribute: 'camera-controls'})\n    cameraControls: boolean = false;\n\n    @style({\n      intrinsics: cameraOrbitIntrinsics,\n      observeEffects: true,\n      updateHandler: $syncCameraOrbit\n    })\n    @property({type: String, attribute: 'camera-orbit', hasChanged: () => true})\n    cameraOrbit: string = DEFAULT_CAMERA_ORBIT;\n\n    @style({\n      intrinsics: cameraTargetIntrinsics,\n      observeEffects: true,\n      updateHandler: $syncCameraTarget\n    })\n    @property(\n        {type: String, attribute: 'camera-target', hasChanged: () => true})\n    cameraTarget: string = DEFAULT_CAMERA_TARGET;\n\n    @style({\n      intrinsics: fieldOfViewIntrinsics,\n      observeEffects: true,\n      updateHandler: $syncFieldOfView\n    })\n    @property(\n        {type: String, attribute: 'field-of-view', hasChanged: () => true})\n    fieldOfView: string = DEFAULT_FIELD_OF_VIEW;\n\n    @style({\n      intrinsics: minCameraOrbitIntrinsics,\n      updateHandler: $syncMinCameraOrbit\n    })\n    @property(\n        {type: String, attribute: 'min-camera-orbit', hasChanged: () => true})\n    minCameraOrbit: string = 'auto';\n\n    @style({\n      intrinsics: maxCameraOrbitIntrinsics,\n      updateHandler: $syncMaxCameraOrbit\n    })\n    @property(\n        {type: String, attribute: 'max-camera-orbit', hasChanged: () => true})\n    maxCameraOrbit: string = 'auto';\n\n    @style({\n      intrinsics: minFieldOfViewIntrinsics,\n      updateHandler: $syncMinFieldOfView\n    })\n    @property(\n        {type: String, attribute: 'min-field-of-view', hasChanged: () => true})\n    minFieldOfView: string = 'auto';\n\n    @style(\n        {intrinsics: fieldOfViewIntrinsics, updateHandler: $syncMaxFieldOfView})\n    @property(\n        {type: String, attribute: 'max-field-of-view', hasChanged: () => true})\n    maxFieldOfView: string = 'auto';\n\n    @property({type: Number, attribute: 'interaction-prompt-threshold'})\n    interactionPromptThreshold: number = DEFAULT_INTERACTION_PROMPT_THRESHOLD;\n\n    @property({type: String, attribute: 'interaction-prompt'})\n    interactionPrompt: InteractionPromptStrategy =\n        InteractionPromptStrategy.AUTO;\n\n    @property({type: String, attribute: 'interaction-prompt-style'})\n    interactionPromptStyle: InteractionPromptStyle =\n        InteractionPromptStyle.WIGGLE;\n\n    @property({type: Number, attribute: 'orbit-sensitivity'})\n    orbitSensitivity: number = 1;\n\n    @property({type: String, attribute: 'touch-action'})\n    touchAction: TouchAction = TouchAction.NONE;\n\n    @property({type: Boolean, attribute: 'disable-zoom'})\n    disableZoom: boolean = false;\n\n    @property({type: Boolean, attribute: 'disable-pan'})\n    disablePan: boolean = false;\n\n    @property({type: Boolean, attribute: 'disable-tap'})\n    disableTap: boolean = false;\n\n    @property({type: Number, attribute: 'interpolation-decay'})\n    interpolationDecay: number = DECAY_MILLISECONDS;\n\n    protected[$promptElement] =\n        this.shadowRoot!.querySelector('.interaction-prompt') as HTMLElement;\n    protected[$promptAnimatedContainer] =\n        this.shadowRoot!.querySelector('#prompt') as HTMLElement;\n    protected[$fingerAnimatedContainers]: HTMLElement[] = [\n      this.shadowRoot!.querySelector('#finger0')!,\n      this.shadowRoot!.querySelector('#finger1')!\n    ];\n    protected[$panElement] =\n        this.shadowRoot!.querySelector('.pan-target') as HTMLElement;\n\n    protected[$lastPromptOffset] = 0;\n    protected[$promptElementVisibleTime] = Infinity;\n    protected[$userHasInteracted] = false;\n    protected[$waitingToPromptUser] = false;\n\n    protected[$controls] = new SmoothControls(\n        this[$scene].camera as PerspectiveCamera, this[$userInputElement],\n        this[$scene]);\n\n    protected[$lastSpherical] = new Spherical();\n    protected[$jumpCamera] = false;\n    protected[$initialized] = false;\n    protected[$maintainThetaPhi] = false;\n\n    get inputSensitivity(): number {\n      return this[$controls].inputSensitivity;\n    }\n\n    set inputSensitivity(value: number) {\n      this[$controls].inputSensitivity = value;\n    }\n\n    getCameraOrbit(): SphericalPosition {\n      const {theta, phi, radius} = this[$lastSpherical];\n      return {\n        theta,\n        phi,\n        radius,\n        toString() {\n          return `${this.theta}rad ${this.phi}rad ${this.radius}m`;\n        }\n      };\n    }\n\n    getCameraTarget(): Vector3D {\n      return toVector3D(\n          this[$renderer].isPresenting ? this[$renderer].arRenderer.target :\n                                         this[$scene].getTarget());\n    }\n\n    getFieldOfView(): number {\n      return this[$controls].getFieldOfView();\n    }\n\n    // Provided so user code does not have to parse these from attributes.\n    getMinimumFieldOfView(): number {\n      return this[$controls].options.minimumFieldOfView!;\n    }\n\n    getMaximumFieldOfView(): number {\n      return this[$controls].options.maximumFieldOfView!;\n    }\n\n    getIdealAspect(): number {\n      return this[$scene].idealAspect;\n    }\n\n    jumpCameraToGoal() {\n      this[$jumpCamera] = true;\n      this.requestUpdate($jumpCamera, false);\n    }\n\n    resetInteractionPrompt() {\n      this[$lastPromptOffset] = 0;\n      this[$promptElementVisibleTime] = Infinity;\n      this[$userHasInteracted] = false;\n      this[$waitingToPromptUser] =\n          this.interactionPrompt === InteractionPromptStrategy.AUTO &&\n          this.cameraControls;\n    }\n\n    zoom(keyPresses: number) {\n      const event = new WheelEvent('wheel', {deltaY: -30 * keyPresses});\n      this[$userInputElement].dispatchEvent(event);\n    }\n\n    connectedCallback() {\n      super.connectedCallback();\n\n      this[$controls].addEventListener(\n          'change', this[$onChange] as (event: Event) => void);\n      this[$controls].addEventListener(\n          'pointer-change-start',\n          this[$onPointerChange] as (event: Event) => void);\n      this[$controls].addEventListener(\n          'pointer-change-end',\n          this[$onPointerChange] as (event: Event) => void);\n    }\n\n    disconnectedCallback() {\n      super.disconnectedCallback();\n\n      this[$controls].removeEventListener(\n          'change', this[$onChange] as (event: Event) => void);\n      this[$controls].removeEventListener(\n          'pointer-change-start',\n          this[$onPointerChange] as (event: Event) => void);\n      this[$controls].removeEventListener(\n          'pointer-change-end',\n          this[$onPointerChange] as (event: Event) => void);\n    }\n\n    updated(changedProperties: Map<string|number|symbol, unknown>) {\n      super.updated(changedProperties);\n\n      const controls = this[$controls];\n      const scene = this[$scene];\n\n      if (changedProperties.has('cameraControls')) {\n        if (this.cameraControls) {\n          controls.enableInteraction();\n          if (this.interactionPrompt === InteractionPromptStrategy.AUTO) {\n            this[$waitingToPromptUser] = true;\n          }\n        } else {\n          controls.disableInteraction();\n          this[$deferInteractionPrompt]();\n        }\n        this[$userInputElement].setAttribute('aria-label', this[$ariaLabel]);\n      }\n\n      if (changedProperties.has('disableZoom')) {\n        controls.disableZoom = this.disableZoom;\n      }\n\n      if (changedProperties.has('disablePan')) {\n        controls.enablePan = !this.disablePan;\n      }\n\n      if (changedProperties.has('disableTap')) {\n        controls.enableTap = !this.disableTap;\n      }\n\n      if (changedProperties.has('interactionPrompt') ||\n          changedProperties.has('cameraControls') ||\n          changedProperties.has('src')) {\n        if (this.interactionPrompt === InteractionPromptStrategy.AUTO &&\n            this.cameraControls && !this[$userHasInteracted]) {\n          this[$waitingToPromptUser] = true;\n        } else {\n          this[$deferInteractionPrompt]();\n        }\n      }\n\n      if (changedProperties.has('interactionPromptStyle')) {\n        this[$promptAnimatedContainer].style.opacity =\n            this.interactionPromptStyle == InteractionPromptStyle.BASIC ? '1' :\n                                                                          '0';\n      }\n\n      if (changedProperties.has('touchAction')) {\n        const touchAction = this.touchAction;\n        controls.applyOptions({touchAction});\n        controls.updateTouchActionStyle();\n      }\n\n      if (changedProperties.has('orbitSensitivity')) {\n        controls.orbitSensitivity = this.orbitSensitivity;\n      }\n\n      if (changedProperties.has('interpolationDecay')) {\n        controls.setDamperDecayTime(this.interpolationDecay);\n        scene.setTargetDamperDecayTime(this.interpolationDecay);\n      }\n\n      if (this[$jumpCamera] === true) {\n        Promise.resolve().then(() => {\n          controls.jumpToGoal();\n          scene.jumpToGoal();\n          this[$jumpCamera] = false;\n        });\n      }\n    }\n\n    async updateFraming() {\n      const scene = this[$scene];\n      const oldFramedFoV = scene.adjustedFoV(scene.framedFoVDeg);\n\n      await scene.updateFraming();\n\n      const newFramedFoV = scene.adjustedFoV(scene.framedFoVDeg);\n      const zoom = this[$controls].getFieldOfView() / oldFramedFoV;\n      this[$controls].setFieldOfView(newFramedFoV * zoom);\n      this[$maintainThetaPhi] = true;\n\n      this.requestUpdate('maxFieldOfView');\n      this.requestUpdate('fieldOfView');\n      this.requestUpdate('minCameraOrbit');\n      this.requestUpdate('maxCameraOrbit');\n      this.requestUpdate('cameraOrbit');\n      await this.updateComplete;\n    }\n\n    interact(duration: number, finger0: Finger, finger1?: Finger) {\n      const inputElement = this[$userInputElement];\n      const fingerElements = this[$fingerAnimatedContainers];\n\n      if (fingerElements[0].style.opacity === '1') {\n        console.warn(\n            'interact() failed because an existing interaction is running.')\n        return;\n      }\n\n      const xy = new Array<{x: TimingFunction, y: TimingFunction}>();\n      xy.push({x: timeline(finger0.x), y: timeline(finger0.y)});\n      const positions = [{x: xy[0].x(0), y: xy[0].y(0)}];\n\n      if (finger1 != null) {\n        xy.push({x: timeline(finger1.x), y: timeline(finger1.y)});\n        positions.push({x: xy[1].x(0), y: xy[1].y(0)});\n      }\n\n      let startTime = performance.now();\n      const {width, height} = this[$scene];\n\n      const dispatchTouches = (type: string) => {\n        for (const [i, position] of positions.entries()) {\n          const {style} = fingerElements[i];\n          style.transform = `translateX(${width * position.x}px) translateY(${\n              height * position.y}px)`;\n          if (type === 'pointerdown') {\n            style.opacity = '1';\n          } else if (type === 'pointerup') {\n            style.opacity = '0';\n          }\n\n          const init = {\n            pointerId: i - 5678,  // help ensure uniqueness\n            pointerType: 'touch',\n            target: inputElement,\n            clientX: width * position.x,\n            clientY: height * position.y,\n            altKey: true  // flag that this is not a user interaction\n          } as PointerEventInit;\n\n          inputElement.dispatchEvent(new PointerEvent(type, init));\n        }\n      };\n\n      const moveTouches = () => {\n        // Cancel interaction if something else moves the camera or input is\n        // removed from the DOM.\n        const {changeSource} = this[$controls];\n        if (changeSource !== ChangeSource.AUTOMATIC ||\n            !inputElement.isConnected) {\n          for (const fingerElement of this[$fingerAnimatedContainers]) {\n            fingerElement.style.opacity = '0';\n          }\n          dispatchTouches('pointercancel');\n          this.dispatchEvent(new CustomEvent<CameraChangeDetails>(\n              'interact-stopped', {detail: {source: changeSource}}));\n          document.removeEventListener('visibilitychange', onVisibilityChange);\n          return;\n        }\n\n        const time = Math.min(1, (performance.now() - startTime) / duration);\n        for (const [i, position] of positions.entries()) {\n          position.x = xy[i].x(time);\n          position.y = xy[i].y(time);\n        }\n        dispatchTouches('pointermove');\n\n        if (time < 1) {\n          requestAnimationFrame(moveTouches);\n        } else {\n          dispatchTouches('pointerup');\n          this.dispatchEvent(new CustomEvent<CameraChangeDetails>(\n              'interact-stopped', {detail: {source: changeSource}}));\n          document.removeEventListener('visibilitychange', onVisibilityChange);\n        }\n      };\n\n      const onVisibilityChange = () => {\n        let elapsed = 0;\n        if (document.visibilityState === 'hidden') {\n          elapsed = performance.now() - startTime;\n        } else {\n          startTime = performance.now() - elapsed;\n        }\n      };\n\n      document.addEventListener('visibilitychange', onVisibilityChange);\n\n      dispatchTouches('pointerdown');\n\n      requestAnimationFrame(moveTouches);\n    }\n\n    [$syncFieldOfView](style: EvaluatedStyle<Intrinsics<['rad']>>) {\n      const scene = this[$scene];\n      scene.framedFoVDeg = style[0] * 180 / Math.PI;\n      this[$controls].setFieldOfView(scene.adjustedFoV(scene.framedFoVDeg));\n    }\n\n    [$syncCameraOrbit](style: EvaluatedStyle<SphericalIntrinsics>) {\n      const controls = this[$controls];\n      if (this[$maintainThetaPhi]) {\n        const {theta, phi} = this.getCameraOrbit();\n        style[0] = theta;\n        style[1] = phi;\n        this[$maintainThetaPhi] = false;\n      }\n      controls.changeSource = ChangeSource.NONE;\n      controls.setOrbit(style[0], style[1], style[2]);\n    }\n\n    [$syncMinCameraOrbit](style: EvaluatedStyle<SphericalIntrinsics>) {\n      this[$controls].applyOptions({\n        minimumAzimuthalAngle: style[0],\n        minimumPolarAngle: style[1],\n        minimumRadius: style[2]\n      });\n      this.jumpCameraToGoal();\n    }\n\n    [$syncMaxCameraOrbit](style: EvaluatedStyle<SphericalIntrinsics>) {\n      this[$controls].applyOptions({\n        maximumAzimuthalAngle: style[0],\n        maximumPolarAngle: style[1],\n        maximumRadius: style[2]\n      });\n      this[$updateCameraForRadius](style[2]);\n      this.jumpCameraToGoal();\n    }\n\n    [$syncMinFieldOfView](style: EvaluatedStyle<Intrinsics<['rad']>>) {\n      this[$controls].applyOptions(\n          {minimumFieldOfView: style[0] * 180 / Math.PI});\n      this.jumpCameraToGoal();\n    }\n\n    [$syncMaxFieldOfView](style: EvaluatedStyle<Intrinsics<['rad']>>) {\n      const fov = this[$scene].adjustedFoV(style[0] * 180 / Math.PI);\n      this[$controls].applyOptions({maximumFieldOfView: fov});\n      this.jumpCameraToGoal();\n    }\n\n    [$syncCameraTarget](style: EvaluatedStyle<Vector3Intrinsics>) {\n      const [x, y, z] = style;\n      if (!this[$renderer].arRenderer.isPresenting) {\n        this[$scene].setTarget(x, y, z);\n      }\n      this[$controls].changeSource = ChangeSource.NONE;\n      this[$renderer].arRenderer.updateTarget();\n    }\n\n    [$tick](time: number, delta: number) {\n      super[$tick](time, delta);\n\n      if (this[$renderer].isPresenting || !this[$getModelIsVisible]()) {\n        return;\n      }\n\n      const controls = this[$controls];\n      const scene = this[$scene];\n\n      const now = performance.now();\n      if (this[$waitingToPromptUser]) {\n        if (this.loaded &&\n            now > this[$loadedTime] + this.interactionPromptThreshold) {\n          this[$waitingToPromptUser] = false;\n          this[$promptElementVisibleTime] = now;\n\n          this[$promptElement].classList.add('visible');\n        }\n      }\n\n      if (isFinite(this[$promptElementVisibleTime]) &&\n          this.interactionPromptStyle === InteractionPromptStyle.WIGGLE) {\n        const animationTime =\n            ((now - this[$promptElementVisibleTime]) / PROMPT_ANIMATION_TIME) %\n            1;\n        const offset = wiggle(animationTime);\n        const opacity = fade(animationTime);\n\n        this[$promptAnimatedContainer].style.opacity = `${opacity}`;\n\n        if (offset !== this[$lastPromptOffset]) {\n          const xOffset = offset * scene.width * 0.05;\n          const deltaTheta = (offset - this[$lastPromptOffset]) * Math.PI / 16;\n\n          this[$promptAnimatedContainer].style.transform =\n              `translateX(${xOffset}px)`;\n\n          controls.changeSource = ChangeSource.AUTOMATIC;\n          controls.adjustOrbit(deltaTheta, 0, 0);\n\n          this[$lastPromptOffset] = offset;\n        }\n      }\n\n      controls.update(time, delta);\n      if (scene.updateTarget(delta)) {\n        this[$onChange]({type: 'change', source: controls.changeSource});\n      }\n    }\n\n    [$deferInteractionPrompt]() {\n      // Effectively cancel the timer waiting for user interaction:\n      this[$waitingToPromptUser] = false;\n      this[$promptElement].classList.remove('visible');\n      this[$promptElementVisibleTime] = Infinity;\n    }\n\n    /**\n     * Updates the camera's near and far planes to enclose the scene when\n     * orbiting at the supplied radius.\n     */\n    [$updateCameraForRadius](radius: number) {\n      const maximumRadius =\n          Math.max(this[$scene].boundingSphere.radius, radius);\n\n      const near = 0;\n      const far = 2 * maximumRadius;\n      this[$controls].updateNearFar(near, far);\n    }\n\n    [$updateAria]() {\n      const {theta, phi} =\n          this[$controls]!.getCameraSpherical(this[$lastSpherical]);\n\n      const azimuthalQuadrant =\n          (4 + Math.floor(((theta % TAU) + QUARTER_PI) / HALF_PI)) % 4;\n\n      const polarTrient = Math.floor(phi / THIRD_PI);\n\n      const azimuthalQuadrantLabel =\n          AZIMUTHAL_QUADRANT_LABELS[azimuthalQuadrant];\n      const polarTrientLabel = POLAR_TRIENT_LABELS[polarTrient];\n\n      this[$updateStatus](\n          `View from stage ${polarTrientLabel}${azimuthalQuadrantLabel}`);\n    }\n\n    get[$ariaLabel]() {\n      return super[$ariaLabel] +\n          (this.cameraControls ? INTERACTION_PROMPT : '');\n    }\n\n    async[$onResize](event: any) {\n      const controls = this[$controls];\n      const scene = this[$scene];\n      const oldFramedFoV = scene.adjustedFoV(scene.framedFoVDeg);\n\n      // The super of $onResize may update the scene's adjustedFoV, so we\n      // compare the before and after to calculate the proper zoom.\n      super[$onResize](event);\n\n      const fovRatio = scene.adjustedFoV(scene.framedFoVDeg) / oldFramedFoV;\n      const fov =\n          controls.getFieldOfView() * (isFinite(fovRatio) ? fovRatio : 1);\n\n      controls.updateAspect(this[$scene].aspect);\n\n      this.requestUpdate('maxFieldOfView', this.maxFieldOfView);\n      await this.updateComplete;\n      this[$controls].setFieldOfView(fov);\n\n      this.jumpCameraToGoal();\n    }\n\n    [$onModelLoad]() {\n      super[$onModelLoad]();\n\n      if (this[$initialized]) {\n        this[$maintainThetaPhi] = true;\n      } else {\n        this[$initialized] = true;\n      }\n      this.requestUpdate('maxFieldOfView', this.maxFieldOfView);\n      this.requestUpdate('fieldOfView', this.fieldOfView);\n      this.requestUpdate('minCameraOrbit', this.minCameraOrbit);\n      this.requestUpdate('maxCameraOrbit', this.maxCameraOrbit);\n      this.requestUpdate('cameraOrbit', this.cameraOrbit);\n      this.requestUpdate('cameraTarget', this.cameraTarget);\n      this.jumpCameraToGoal();\n    }\n\n    [$onChange] = ({source}: ChangeEvent) => {\n      this[$updateAria]();\n      this[$needsRender]();\n\n      if (source === ChangeSource.USER_INTERACTION) {\n        this[$userHasInteracted] = true;\n        this[$deferInteractionPrompt]();\n      }\n\n      this.dispatchEvent(new CustomEvent<CameraChangeDetails>(\n          'camera-change', {detail: {source}}));\n    };\n\n    [$onPointerChange] = (event: PointerChangeEvent) => {\n      if (event.type === 'pointer-change-start') {\n        this[$container].classList.add('pointer-tumbling');\n      } else {\n        this[$container].classList.remove('pointer-tumbling');\n      }\n    };\n  }\n\n  return ControlsModelViewerElement;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}