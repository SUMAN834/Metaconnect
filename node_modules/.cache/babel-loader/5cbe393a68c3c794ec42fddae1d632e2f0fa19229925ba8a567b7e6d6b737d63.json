{"ast":null,"code":"import { BufferAttribute, ClampToEdgeWrapping, DoubleSide, InterpolateDiscrete, InterpolateLinear, LinearEncoding, LinearFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, MathUtils, Matrix4, MirroredRepeatWrapping, NearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, PropertyBinding, RGBAFormat, RepeatWrapping, Scene, Source, sRGBEncoding, Vector3 } from 'three';\nclass GLTFExporter {\n  constructor() {\n    this.pluginCallbacks = [];\n    this.register(function (writer) {\n      return new GLTFLightExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsUnlitExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsPBRSpecularGlossiness(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsTransmissionExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsVolumeExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsClearcoatExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsIridescenceExtension(writer);\n    });\n  }\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n    return this;\n  }\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n    return this;\n  }\n\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Function} onError  Callback on errors\n   * @param  {Object} options options\n   */\n  parse(input, onDone, onError, options) {\n    const writer = new GLTFWriter();\n    const plugins = [];\n    for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n      plugins.push(this.pluginCallbacks[i](writer));\n    }\n    writer.setPlugins(plugins);\n    writer.write(input, onDone, options).catch(onError);\n  }\n  parseAsync(input, options) {\n    const scope = this;\n    return new Promise(function (resolve, reject) {\n      scope.parse(input, resolve, reject, options);\n    });\n  }\n}\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst WEBGL_CONSTANTS = {\n  POINTS: 0x0000,\n  LINES: 0x0001,\n  LINE_LOOP: 0x0002,\n  LINE_STRIP: 0x0003,\n  TRIANGLES: 0x0004,\n  TRIANGLE_STRIP: 0x0005,\n  TRIANGLE_FAN: 0x0006,\n  UNSIGNED_BYTE: 0x1401,\n  UNSIGNED_SHORT: 0x1403,\n  FLOAT: 0x1406,\n  UNSIGNED_INT: 0x1405,\n  ARRAY_BUFFER: 0x8892,\n  ELEMENT_ARRAY_BUFFER: 0x8893,\n  NEAREST: 0x2600,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_NEAREST: 0x2700,\n  LINEAR_MIPMAP_NEAREST: 0x2701,\n  NEAREST_MIPMAP_LINEAR: 0x2702,\n  LINEAR_MIPMAP_LINEAR: 0x2703,\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497\n};\nconst THREE_TO_WEBGL = {};\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\nconst PATH_PROPERTIES = {\n  scale: 'scale',\n  position: 'translation',\n  quaternion: 'rotation',\n  morphTargetInfluences: 'weights'\n};\n\n// GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nconst GLB_HEADER_BYTES = 12;\nconst GLB_HEADER_MAGIC = 0x46546C67;\nconst GLB_VERSION = 2;\nconst GLB_CHUNK_PREFIX_BYTES = 8;\nconst GLB_CHUNK_TYPE_JSON = 0x4E4F534A;\nconst GLB_CHUNK_TYPE_BIN = 0x004E4942;\n\n//------------------------------------------------------------------------------\n// Utility functions\n//------------------------------------------------------------------------------\n\n/**\n * Compare two arrays\n * @param  {Array} array1 Array 1 to compare\n * @param  {Array} array2 Array 2 to compare\n * @return {Boolean}        Returns true if both arrays are equal\n */\nfunction equalArray(array1, array2) {\n  return array1.length === array2.length && array1.every(function (element, index) {\n    return element === array2[index];\n  });\n}\n\n/**\n * Converts a string to an ArrayBuffer.\n * @param  {string} text\n * @return {ArrayBuffer}\n */\nfunction stringToArrayBuffer(text) {\n  return new TextEncoder().encode(text).buffer;\n}\n\n/**\n * Is identity matrix\n *\n * @param {Matrix4} matrix\n * @returns {Boolean} Returns true, if parameter is identity matrix\n */\nfunction isIdentityMatrix(matrix) {\n  return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n}\n\n/**\n * Get the min and max vectors from the given attribute\n * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n * @param  {Integer} start\n * @param  {Integer} count\n * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n */\nfunction getMinMax(attribute, start, count) {\n  const output = {\n    min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n    max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n  };\n  for (let i = start; i < start + count; i++) {\n    for (let a = 0; a < attribute.itemSize; a++) {\n      let value;\n      if (attribute.itemSize > 4) {\n        // no support for interleaved data for itemSize > 4\n\n        value = attribute.array[i * attribute.itemSize + a];\n      } else {\n        if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n      }\n      output.min[a] = Math.min(output.min[a], value);\n      output.max[a] = Math.max(output.max[a], value);\n    }\n  }\n  return output;\n}\n\n/**\n * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n *\n * @param {Integer} bufferSize The size the original buffer.\n * @returns {Integer} new buffer size with required padding.\n *\n */\nfunction getPaddedBufferSize(bufferSize) {\n  return Math.ceil(bufferSize / 4) * 4;\n}\n\n/**\n * Returns a buffer aligned to 4-byte boundary.\n *\n * @param {ArrayBuffer} arrayBuffer Buffer to pad\n * @param {Integer} paddingByte (Optional)\n * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n */\nfunction getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {\n  const paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);\n  if (paddedLength !== arrayBuffer.byteLength) {\n    const array = new Uint8Array(paddedLength);\n    array.set(new Uint8Array(arrayBuffer));\n    if (paddingByte !== 0) {\n      for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\n        array[i] = paddingByte;\n      }\n    }\n    return array.buffer;\n  }\n  return arrayBuffer;\n}\nfunction getCanvas() {\n  if (typeof document === 'undefined' && typeof OffscreenCanvas !== 'undefined') {\n    return new OffscreenCanvas(1, 1);\n  }\n  return document.createElement('canvas');\n}\nfunction getToBlobPromise(canvas, mimeType) {\n  if (canvas.toBlob !== undefined) {\n    return new Promise(resolve => canvas.toBlob(resolve, mimeType));\n  }\n  let quality;\n\n  // Blink's implementation of convertToBlob seems to default to a quality level of 100%\n  // Use the Blink default quality levels of toBlob instead so that file sizes are comparable.\n  if (mimeType === 'image/jpeg') {\n    quality = 0.92;\n  } else if (mimeType === 'image/webp') {\n    quality = 0.8;\n  }\n  return canvas.convertToBlob({\n    type: mimeType,\n    quality: quality\n  });\n}\n\n/**\n * Writer\n */\nclass GLTFWriter {\n  constructor() {\n    this.plugins = [];\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n    this.byteOffset = 0;\n    this.buffers = [];\n    this.nodeMap = new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n    this.uids = new Map();\n    this.uid = 0;\n    this.json = {\n      asset: {\n        version: '2.0',\n        generator: 'THREE.GLTFExporter'\n      }\n    };\n    this.cache = {\n      meshes: new Map(),\n      attributes: new Map(),\n      attributesNormalized: new Map(),\n      materials: new Map(),\n      textures: new Map(),\n      images: new Map()\n    };\n  }\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Object} options options\n   */\n  async write(input, onDone, options) {\n    this.options = Object.assign({}, {\n      // default options\n      binary: false,\n      trs: false,\n      onlyVisible: true,\n      maxTextureSize: Infinity,\n      animations: [],\n      includeCustomExtensions: false\n    }, options);\n    if (this.options.animations.length > 0) {\n      // Only TRS properties, and not matrices, may be targeted by animation.\n      this.options.trs = true;\n    }\n    this.processInput(input);\n    await Promise.all(this.pending);\n    const writer = this;\n    const buffers = writer.buffers;\n    const json = writer.json;\n    options = writer.options;\n    const extensionsUsed = writer.extensionsUsed;\n\n    // Merge buffers.\n    const blob = new Blob(buffers, {\n      type: 'application/octet-stream'\n    });\n\n    // Declare extensions.\n    const extensionsUsedList = Object.keys(extensionsUsed);\n    if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList;\n\n    // Update bytelength of the single buffer.\n    if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;\n    if (options.binary === true) {\n      // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n      const reader = new FileReader();\n      reader.readAsArrayBuffer(blob);\n      reader.onloadend = function () {\n        // Binary chunk.\n        const binaryChunk = getPaddedArrayBuffer(reader.result);\n        const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n        binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n        binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);\n\n        // JSON chunk.\n        const jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 0x20);\n        const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n        jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n        jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);\n\n        // GLB header.\n        const header = new ArrayBuffer(GLB_HEADER_BYTES);\n        const headerView = new DataView(header);\n        headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n        headerView.setUint32(4, GLB_VERSION, true);\n        const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n        headerView.setUint32(8, totalByteLength, true);\n        const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n          type: 'application/octet-stream'\n        });\n        const glbReader = new FileReader();\n        glbReader.readAsArrayBuffer(glbBlob);\n        glbReader.onloadend = function () {\n          onDone(glbReader.result);\n        };\n      };\n    } else {\n      if (json.buffers && json.buffers.length > 0) {\n        const reader = new FileReader();\n        reader.readAsDataURL(blob);\n        reader.onloadend = function () {\n          const base64data = reader.result;\n          json.buffers[0].uri = base64data;\n          onDone(json);\n        };\n      } else {\n        onDone(json);\n      }\n    }\n  }\n\n  /**\n   * Serializes a userData.\n   *\n   * @param {THREE.Object3D|THREE.Material} object\n   * @param {Object} objectDef\n   */\n  serializeUserData(object, objectDef) {\n    if (Object.keys(object.userData).length === 0) return;\n    const options = this.options;\n    const extensionsUsed = this.extensionsUsed;\n    try {\n      const json = JSON.parse(JSON.stringify(object.userData));\n      if (options.includeCustomExtensions && json.gltfExtensions) {\n        if (objectDef.extensions === undefined) objectDef.extensions = {};\n        for (const extensionName in json.gltfExtensions) {\n          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\n          extensionsUsed[extensionName] = true;\n        }\n        delete json.gltfExtensions;\n      }\n      if (Object.keys(json).length > 0) objectDef.extras = json;\n    } catch (error) {\n      console.warn('THREE.GLTFExporter: userData of \\'' + object.name + '\\' ' + 'won\\'t be serialized because of JSON.stringify error - ' + error.message);\n    }\n  }\n\n  /**\n   * Returns ids for buffer attributes.\n   * @param  {Object} object\n   * @return {Integer}\n   */\n  getUID(attribute, isRelativeCopy = false) {\n    if (this.uids.has(attribute) === false) {\n      const uids = new Map();\n      uids.set(true, this.uid++);\n      uids.set(false, this.uid++);\n      this.uids.set(attribute, uids);\n    }\n    const uids = this.uids.get(attribute);\n    return uids.get(isRelativeCopy);\n  }\n\n  /**\n   * Checks if normal attribute values are normalized.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {Boolean}\n   */\n  isNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal)) return false;\n    const v = new Vector3();\n    for (let i = 0, il = normal.count; i < il; i++) {\n      // 0.0005 is from glTF-validator\n      if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1.0) > 0.0005) return false;\n    }\n    return true;\n  }\n\n  /**\n   * Creates normalized normal buffer attribute.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {BufferAttribute}\n   *\n   */\n  createNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);\n    const attribute = normal.clone();\n    const v = new Vector3();\n    for (let i = 0, il = attribute.count; i < il; i++) {\n      v.fromBufferAttribute(attribute, i);\n      if (v.x === 0 && v.y === 0 && v.z === 0) {\n        // if values can't be normalized set (1, 0, 0)\n        v.setX(1.0);\n      } else {\n        v.normalize();\n      }\n      attribute.setXYZ(i, v.x, v.y, v.z);\n    }\n    cache.attributesNormalized.set(normal, attribute);\n    return attribute;\n  }\n\n  /**\n   * Applies a texture transform, if present, to the map definition. Requires\n   * the KHR_texture_transform extension.\n   *\n   * @param {Object} mapDef\n   * @param {THREE.Texture} texture\n   */\n  applyTextureTransform(mapDef, texture) {\n    let didTransform = false;\n    const transformDef = {};\n    if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n      transformDef.offset = texture.offset.toArray();\n      didTransform = true;\n    }\n    if (texture.rotation !== 0) {\n      transformDef.rotation = texture.rotation;\n      didTransform = true;\n    }\n    if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n      transformDef.scale = texture.repeat.toArray();\n      didTransform = true;\n    }\n    if (didTransform) {\n      mapDef.extensions = mapDef.extensions || {};\n      mapDef.extensions['KHR_texture_transform'] = transformDef;\n      this.extensionsUsed['KHR_texture_transform'] = true;\n    }\n  }\n  buildMetalRoughTexture(metalnessMap, roughnessMap) {\n    if (metalnessMap === roughnessMap) return metalnessMap;\n    function getEncodingConversion(map) {\n      if (map.encoding === sRGBEncoding) {\n        return function SRGBToLinear(c) {\n          return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n        };\n      }\n      return function LinearToLinear(c) {\n        return c;\n      };\n    }\n    console.warn('THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.');\n    const metalness = metalnessMap?.image;\n    const roughness = roughnessMap?.image;\n    const width = Math.max(metalness?.width || 0, roughness?.width || 0);\n    const height = Math.max(metalness?.height || 0, roughness?.height || 0);\n    const canvas = getCanvas();\n    canvas.width = width;\n    canvas.height = height;\n    const context = canvas.getContext('2d');\n    context.fillStyle = '#00ffff';\n    context.fillRect(0, 0, width, height);\n    const composite = context.getImageData(0, 0, width, height);\n    if (metalness) {\n      context.drawImage(metalness, 0, 0, width, height);\n      const convert = getEncodingConversion(metalnessMap);\n      const data = context.getImageData(0, 0, width, height).data;\n      for (let i = 2; i < data.length; i += 4) {\n        composite.data[i] = convert(data[i] / 256) * 256;\n      }\n    }\n    if (roughness) {\n      context.drawImage(roughness, 0, 0, width, height);\n      const convert = getEncodingConversion(roughnessMap);\n      const data = context.getImageData(0, 0, width, height).data;\n      for (let i = 1; i < data.length; i += 4) {\n        composite.data[i] = convert(data[i] / 256) * 256;\n      }\n    }\n    context.putImageData(composite, 0, 0);\n\n    //\n\n    const reference = metalnessMap || roughnessMap;\n    const texture = reference.clone();\n    texture.source = new Source(canvas);\n    texture.encoding = LinearEncoding;\n    return texture;\n  }\n\n  /**\n   * Process a buffer to append to the default one.\n   * @param  {ArrayBuffer} buffer\n   * @return {Integer}\n   */\n  processBuffer(buffer) {\n    const json = this.json;\n    const buffers = this.buffers;\n    if (!json.buffers) json.buffers = [{\n      byteLength: 0\n    }];\n\n    // All buffers are merged before export.\n    buffers.push(buffer);\n    return 0;\n  }\n\n  /**\n   * Process and generate a BufferView\n   * @param  {BufferAttribute} attribute\n   * @param  {number} componentType\n   * @param  {number} start\n   * @param  {number} count\n   * @param  {number} target (Optional) Target usage of the BufferView\n   * @return {Object}\n   */\n  processBufferView(attribute, componentType, start, count, target) {\n    const json = this.json;\n    if (!json.bufferViews) json.bufferViews = [];\n\n    // Create a new dataview and dump the attribute's array into it\n\n    let componentSize;\n    if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n      componentSize = 1;\n    } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n      componentSize = 2;\n    } else {\n      componentSize = 4;\n    }\n    const byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize);\n    const dataView = new DataView(new ArrayBuffer(byteLength));\n    let offset = 0;\n    for (let i = start; i < start + count; i++) {\n      for (let a = 0; a < attribute.itemSize; a++) {\n        let value;\n        if (attribute.itemSize > 4) {\n          // no support for interleaved data for itemSize > 4\n\n          value = attribute.array[i * attribute.itemSize + a];\n        } else {\n          if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n        }\n        if (componentType === WEBGL_CONSTANTS.FLOAT) {\n          dataView.setFloat32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n          dataView.setUint32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n          dataView.setUint16(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n          dataView.setUint8(offset, value);\n        }\n        offset += componentSize;\n      }\n    }\n    const bufferViewDef = {\n      buffer: this.processBuffer(dataView.buffer),\n      byteOffset: this.byteOffset,\n      byteLength: byteLength\n    };\n    if (target !== undefined) bufferViewDef.target = target;\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n      // Only define byteStride for vertex attributes.\n      bufferViewDef.byteStride = attribute.itemSize * componentSize;\n    }\n    this.byteOffset += byteLength;\n    json.bufferViews.push(bufferViewDef);\n\n    // @TODO Merge bufferViews where possible.\n    const output = {\n      id: json.bufferViews.length - 1,\n      byteLength: 0\n    };\n    return output;\n  }\n\n  /**\n   * Process and generate a BufferView from an image Blob.\n   * @param {Blob} blob\n   * @return {Promise<Integer>}\n   */\n  processBufferViewImage(blob) {\n    const writer = this;\n    const json = writer.json;\n    if (!json.bufferViews) json.bufferViews = [];\n    return new Promise(function (resolve) {\n      const reader = new FileReader();\n      reader.readAsArrayBuffer(blob);\n      reader.onloadend = function () {\n        const buffer = getPaddedArrayBuffer(reader.result);\n        const bufferViewDef = {\n          buffer: writer.processBuffer(buffer),\n          byteOffset: writer.byteOffset,\n          byteLength: buffer.byteLength\n        };\n        writer.byteOffset += buffer.byteLength;\n        resolve(json.bufferViews.push(bufferViewDef) - 1);\n      };\n    });\n  }\n\n  /**\n   * Process attribute to generate an accessor\n   * @param  {BufferAttribute} attribute Attribute to process\n   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n   * @param  {Integer} start (Optional)\n   * @param  {Integer} count (Optional)\n   * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n   */\n  processAccessor(attribute, geometry, start, count) {\n    const json = this.json;\n    const types = {\n      1: 'SCALAR',\n      2: 'VEC2',\n      3: 'VEC3',\n      4: 'VEC4',\n      16: 'MAT4'\n    };\n    let componentType;\n\n    // Detect the component type of the attribute array (float, uint or ushort)\n    if (attribute.array.constructor === Float32Array) {\n      componentType = WEBGL_CONSTANTS.FLOAT;\n    } else if (attribute.array.constructor === Uint32Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n    } else if (attribute.array.constructor === Uint16Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n    } else if (attribute.array.constructor === Uint8Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n    } else {\n      throw new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type.');\n    }\n    if (start === undefined) start = 0;\n    if (count === undefined) count = attribute.count;\n\n    // Skip creating an accessor if the attribute doesn't have data to export\n    if (count === 0) return null;\n    const minMax = getMinMax(attribute, start, count);\n    let bufferViewTarget;\n\n    // If geometry isn't provided, don't infer the target usage of the bufferView. For\n    // animation samplers, target must not be set.\n    if (geometry !== undefined) {\n      bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n    }\n    const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\n    const accessorDef = {\n      bufferView: bufferView.id,\n      byteOffset: bufferView.byteOffset,\n      componentType: componentType,\n      count: count,\n      max: minMax.max,\n      min: minMax.min,\n      type: types[attribute.itemSize]\n    };\n    if (attribute.normalized === true) accessorDef.normalized = true;\n    if (!json.accessors) json.accessors = [];\n    return json.accessors.push(accessorDef) - 1;\n  }\n\n  /**\n   * Process image\n   * @param  {Image} image to process\n   * @param  {Integer} format of the image (RGBAFormat)\n   * @param  {Boolean} flipY before writing out the image\n   * @param  {String} mimeType export format\n   * @return {Integer}     Index of the processed texture in the \"images\" array\n   */\n  processImage(image, format, flipY, mimeType = 'image/png') {\n    const writer = this;\n    const cache = writer.cache;\n    const json = writer.json;\n    const options = writer.options;\n    const pending = writer.pending;\n    if (!cache.images.has(image)) cache.images.set(image, {});\n    const cachedImages = cache.images.get(image);\n    const key = mimeType + ':flipY/' + flipY.toString();\n    if (cachedImages[key] !== undefined) return cachedImages[key];\n    if (!json.images) json.images = [];\n    const imageDef = {\n      mimeType: mimeType\n    };\n    const canvas = getCanvas();\n    canvas.width = Math.min(image.width, options.maxTextureSize);\n    canvas.height = Math.min(image.height, options.maxTextureSize);\n    const ctx = canvas.getContext('2d');\n    if (flipY === true) {\n      ctx.translate(0, canvas.height);\n      ctx.scale(1, -1);\n    }\n    if (image.data !== undefined) {\n      // THREE.DataTexture\n\n      if (format !== RGBAFormat) {\n        console.error('GLTFExporter: Only RGBAFormat is supported.');\n      }\n      if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n        console.warn('GLTFExporter: Image size is bigger than maxTextureSize', image);\n      }\n      const data = new Uint8ClampedArray(image.height * image.width * 4);\n      for (let i = 0; i < data.length; i += 4) {\n        data[i + 0] = image.data[i + 0];\n        data[i + 1] = image.data[i + 1];\n        data[i + 2] = image.data[i + 2];\n        data[i + 3] = image.data[i + 3];\n      }\n      ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n    } else {\n      ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n    }\n    if (options.binary === true) {\n      pending.push(getToBlobPromise(canvas, mimeType).then(blob => writer.processBufferViewImage(blob)).then(bufferViewIndex => {\n        imageDef.bufferView = bufferViewIndex;\n      }));\n    } else {\n      if (canvas.toDataURL !== undefined) {\n        imageDef.uri = canvas.toDataURL(mimeType);\n      } else {\n        pending.push(getToBlobPromise(canvas, mimeType).then(blob => new FileReader().readAsDataURL(blob)).then(dataURL => {\n          imageDef.uri = dataURL;\n        }));\n      }\n    }\n    const index = json.images.push(imageDef) - 1;\n    cachedImages[key] = index;\n    return index;\n  }\n\n  /**\n   * Process sampler\n   * @param  {Texture} map Texture to process\n   * @return {Integer}     Index of the processed texture in the \"samplers\" array\n   */\n  processSampler(map) {\n    const json = this.json;\n    if (!json.samplers) json.samplers = [];\n    const samplerDef = {\n      magFilter: THREE_TO_WEBGL[map.magFilter],\n      minFilter: THREE_TO_WEBGL[map.minFilter],\n      wrapS: THREE_TO_WEBGL[map.wrapS],\n      wrapT: THREE_TO_WEBGL[map.wrapT]\n    };\n    return json.samplers.push(samplerDef) - 1;\n  }\n\n  /**\n   * Process texture\n   * @param  {Texture} map Map to process\n   * @return {Integer} Index of the processed texture in the \"textures\" array\n   */\n  processTexture(map) {\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.textures.has(map)) return cache.textures.get(map);\n    if (!json.textures) json.textures = [];\n    let mimeType = map.userData.mimeType;\n    if (mimeType === 'image/webp') mimeType = 'image/png';\n    const textureDef = {\n      sampler: this.processSampler(map),\n      source: this.processImage(map.image, map.format, map.flipY, mimeType)\n    };\n    if (map.name) textureDef.name = map.name;\n    this._invokeAll(function (ext) {\n      ext.writeTexture && ext.writeTexture(map, textureDef);\n    });\n    const index = json.textures.push(textureDef) - 1;\n    cache.textures.set(map, index);\n    return index;\n  }\n\n  /**\n   * Process material\n   * @param  {THREE.Material} material Material to process\n   * @return {Integer|null} Index of the processed material in the \"materials\" array\n   */\n  processMaterial(material) {\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.materials.has(material)) return cache.materials.get(material);\n    if (material.isShaderMaterial) {\n      console.warn('GLTFExporter: THREE.ShaderMaterial not supported.');\n      return null;\n    }\n    if (!json.materials) json.materials = [];\n\n    // @QUESTION Should we avoid including any attribute that has the default value?\n    const materialDef = {\n      pbrMetallicRoughness: {}\n    };\n    if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {\n      console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');\n    }\n\n    // pbrMetallicRoughness.baseColorFactor\n    const color = material.color.toArray().concat([material.opacity]);\n    if (!equalArray(color, [1, 1, 1, 1])) {\n      materialDef.pbrMetallicRoughness.baseColorFactor = color;\n    }\n    if (material.isMeshStandardMaterial) {\n      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n    } else {\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n    }\n\n    // pbrMetallicRoughness.metallicRoughnessTexture\n    if (material.metalnessMap || material.roughnessMap) {\n      const metalRoughTexture = this.buildMetalRoughTexture(material.metalnessMap, material.roughnessMap);\n      const metalRoughMapDef = {\n        index: this.processTexture(metalRoughTexture)\n      };\n      this.applyTextureTransform(metalRoughMapDef, metalRoughTexture);\n      materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n    }\n\n    // pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\n    if (material.map) {\n      const baseColorMapDef = {\n        index: this.processTexture(material.map)\n      };\n      this.applyTextureTransform(baseColorMapDef, material.map);\n      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n    }\n    if (material.emissive) {\n      // note: emissive components are limited to stay within the 0 - 1 range to accommodate glTF spec. see #21849 and #22000.\n      const emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity);\n      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);\n      if (maxEmissiveComponent > 1) {\n        emissive.multiplyScalar(1 / maxEmissiveComponent);\n        console.warn('THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited');\n      }\n      if (maxEmissiveComponent > 0) {\n        materialDef.emissiveFactor = emissive.toArray();\n      }\n\n      // emissiveTexture\n      if (material.emissiveMap) {\n        const emissiveMapDef = {\n          index: this.processTexture(material.emissiveMap)\n        };\n        this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n        materialDef.emissiveTexture = emissiveMapDef;\n      }\n    }\n\n    // normalTexture\n    if (material.normalMap) {\n      const normalMapDef = {\n        index: this.processTexture(material.normalMap)\n      };\n      if (material.normalScale && material.normalScale.x !== 1) {\n        // glTF normal scale is univariate. Ignore `y`, which may be flipped.\n        // Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n        normalMapDef.scale = material.normalScale.x;\n      }\n      this.applyTextureTransform(normalMapDef, material.normalMap);\n      materialDef.normalTexture = normalMapDef;\n    }\n\n    // occlusionTexture\n    if (material.aoMap) {\n      const occlusionMapDef = {\n        index: this.processTexture(material.aoMap),\n        texCoord: 1\n      };\n      if (material.aoMapIntensity !== 1.0) {\n        occlusionMapDef.strength = material.aoMapIntensity;\n      }\n      this.applyTextureTransform(occlusionMapDef, material.aoMap);\n      materialDef.occlusionTexture = occlusionMapDef;\n    }\n\n    // alphaMode\n    if (material.transparent) {\n      materialDef.alphaMode = 'BLEND';\n    } else {\n      if (material.alphaTest > 0.0) {\n        materialDef.alphaMode = 'MASK';\n        materialDef.alphaCutoff = material.alphaTest;\n      }\n    }\n\n    // doubleSided\n    if (material.side === DoubleSide) materialDef.doubleSided = true;\n    if (material.name !== '') materialDef.name = material.name;\n    this.serializeUserData(material, materialDef);\n    this._invokeAll(function (ext) {\n      ext.writeMaterial && ext.writeMaterial(material, materialDef);\n    });\n    const index = json.materials.push(materialDef) - 1;\n    cache.materials.set(material, index);\n    return index;\n  }\n\n  /**\n   * Process mesh\n   * @param  {THREE.Mesh} mesh Mesh to process\n   * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n   */\n  processMesh(mesh) {\n    const cache = this.cache;\n    const json = this.json;\n    const meshCacheKeyParts = [mesh.geometry.uuid];\n    if (Array.isArray(mesh.material)) {\n      for (let i = 0, l = mesh.material.length; i < l; i++) {\n        meshCacheKeyParts.push(mesh.material[i].uuid);\n      }\n    } else {\n      meshCacheKeyParts.push(mesh.material.uuid);\n    }\n    const meshCacheKey = meshCacheKeyParts.join(':');\n    if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);\n    const geometry = mesh.geometry;\n    let mode;\n\n    // Use the correct mode\n    if (mesh.isLineSegments) {\n      mode = WEBGL_CONSTANTS.LINES;\n    } else if (mesh.isLineLoop) {\n      mode = WEBGL_CONSTANTS.LINE_LOOP;\n    } else if (mesh.isLine) {\n      mode = WEBGL_CONSTANTS.LINE_STRIP;\n    } else if (mesh.isPoints) {\n      mode = WEBGL_CONSTANTS.POINTS;\n    } else {\n      mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n    }\n    const meshDef = {};\n    const attributes = {};\n    const primitives = [];\n    const targets = [];\n\n    // Conversion between attributes names in threejs and gltf spec\n    const nameConversion = {\n      uv: 'TEXCOORD_0',\n      uv2: 'TEXCOORD_1',\n      color: 'COLOR_0',\n      skinWeight: 'WEIGHTS_0',\n      skinIndex: 'JOINTS_0'\n    };\n    const originalNormal = geometry.getAttribute('normal');\n    if (originalNormal !== undefined && !this.isNormalizedNormalAttribute(originalNormal)) {\n      console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.');\n      geometry.setAttribute('normal', this.createNormalizedNormalAttribute(originalNormal));\n    }\n\n    // @QUESTION Detect if .vertexColors = true?\n    // For every attribute create an accessor\n    let modifiedAttribute = null;\n    for (let attributeName in geometry.attributes) {\n      // Ignore morph target attributes, which are exported later.\n      if (attributeName.slice(0, 5) === 'morph') continue;\n      const attribute = geometry.attributes[attributeName];\n      attributeName = nameConversion[attributeName] || attributeName.toUpperCase();\n\n      // Prefix all geometry attributes except the ones specifically\n      // listed in the spec; non-spec attributes are considered custom.\n      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n      if (!validVertexAttributes.test(attributeName)) attributeName = '_' + attributeName;\n      if (cache.attributes.has(this.getUID(attribute))) {\n        attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\n        continue;\n      }\n\n      // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n      modifiedAttribute = null;\n      const array = attribute.array;\n      if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n        console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n        modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n      }\n      const accessor = this.processAccessor(modifiedAttribute || attribute, geometry);\n      if (accessor !== null) {\n        attributes[attributeName] = accessor;\n        cache.attributes.set(this.getUID(attribute), accessor);\n      }\n    }\n    if (originalNormal !== undefined) geometry.setAttribute('normal', originalNormal);\n\n    // Skip if no exportable attributes found\n    if (Object.keys(attributes).length === 0) return null;\n\n    // Morph targets\n    if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\n      const weights = [];\n      const targetNames = [];\n      const reverseDictionary = {};\n      if (mesh.morphTargetDictionary !== undefined) {\n        for (const key in mesh.morphTargetDictionary) {\n          reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n        }\n      }\n      for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {\n        const target = {};\n        let warned = false;\n        for (const attributeName in geometry.morphAttributes) {\n          // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n          // Three.js doesn't support TANGENT yet.\n\n          if (attributeName !== 'position' && attributeName !== 'normal') {\n            if (!warned) {\n              console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.');\n              warned = true;\n            }\n            continue;\n          }\n          const attribute = geometry.morphAttributes[attributeName][i];\n          const gltfAttributeName = attributeName.toUpperCase();\n\n          // Three.js morph attribute has absolute values while the one of glTF has relative values.\n          //\n          // glTF 2.0 Specification:\n          // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n          const baseAttribute = geometry.attributes[attributeName];\n          if (cache.attributes.has(this.getUID(attribute, true))) {\n            target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute, true));\n            continue;\n          }\n\n          // Clones attribute not to override\n          const relativeAttribute = attribute.clone();\n          if (!geometry.morphTargetsRelative) {\n            for (let j = 0, jl = attribute.count; j < jl; j++) {\n              relativeAttribute.setXYZ(j, attribute.getX(j) - baseAttribute.getX(j), attribute.getY(j) - baseAttribute.getY(j), attribute.getZ(j) - baseAttribute.getZ(j));\n            }\n          }\n          target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry);\n          cache.attributes.set(this.getUID(baseAttribute, true), target[gltfAttributeName]);\n        }\n        targets.push(target);\n        weights.push(mesh.morphTargetInfluences[i]);\n        if (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[i]);\n      }\n      meshDef.weights = weights;\n      if (targetNames.length > 0) {\n        meshDef.extras = {};\n        meshDef.extras.targetNames = targetNames;\n      }\n    }\n    const isMultiMaterial = Array.isArray(mesh.material);\n    if (isMultiMaterial && geometry.groups.length === 0) return null;\n    const materials = isMultiMaterial ? mesh.material : [mesh.material];\n    const groups = isMultiMaterial ? geometry.groups : [{\n      materialIndex: 0,\n      start: undefined,\n      count: undefined\n    }];\n    for (let i = 0, il = groups.length; i < il; i++) {\n      const primitive = {\n        mode: mode,\n        attributes: attributes\n      };\n      this.serializeUserData(geometry, primitive);\n      if (targets.length > 0) primitive.targets = targets;\n      if (geometry.index !== null) {\n        let cacheKey = this.getUID(geometry.index);\n        if (groups[i].start !== undefined || groups[i].count !== undefined) {\n          cacheKey += ':' + groups[i].start + ':' + groups[i].count;\n        }\n        if (cache.attributes.has(cacheKey)) {\n          primitive.indices = cache.attributes.get(cacheKey);\n        } else {\n          primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);\n          cache.attributes.set(cacheKey, primitive.indices);\n        }\n        if (primitive.indices === null) delete primitive.indices;\n      }\n      const material = this.processMaterial(materials[groups[i].materialIndex]);\n      if (material !== null) primitive.material = material;\n      primitives.push(primitive);\n    }\n    meshDef.primitives = primitives;\n    if (!json.meshes) json.meshes = [];\n    this._invokeAll(function (ext) {\n      ext.writeMesh && ext.writeMesh(mesh, meshDef);\n    });\n    const index = json.meshes.push(meshDef) - 1;\n    cache.meshes.set(meshCacheKey, index);\n    return index;\n  }\n\n  /**\n   * Process camera\n   * @param  {THREE.Camera} camera Camera to process\n   * @return {Integer}      Index of the processed mesh in the \"camera\" array\n   */\n  processCamera(camera) {\n    const json = this.json;\n    if (!json.cameras) json.cameras = [];\n    const isOrtho = camera.isOrthographicCamera;\n    const cameraDef = {\n      type: isOrtho ? 'orthographic' : 'perspective'\n    };\n    if (isOrtho) {\n      cameraDef.orthographic = {\n        xmag: camera.right * 2,\n        ymag: camera.top * 2,\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    } else {\n      cameraDef.perspective = {\n        aspectRatio: camera.aspect,\n        yfov: MathUtils.degToRad(camera.fov),\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    }\n\n    // Question: Is saving \"type\" as name intentional?\n    if (camera.name !== '') cameraDef.name = camera.type;\n    return json.cameras.push(cameraDef) - 1;\n  }\n\n  /**\n   * Creates glTF animation entry from AnimationClip object.\n   *\n   * Status:\n   * - Only properties listed in PATH_PROPERTIES may be animated.\n   *\n   * @param {THREE.AnimationClip} clip\n   * @param {THREE.Object3D} root\n   * @return {number|null}\n   */\n  processAnimation(clip, root) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n    if (!json.animations) json.animations = [];\n    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n    const tracks = clip.tracks;\n    const channels = [];\n    const samplers = [];\n    for (let i = 0; i < tracks.length; ++i) {\n      const track = tracks[i];\n      const trackBinding = PropertyBinding.parseTrackName(track.name);\n      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\n      const trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n      if (trackBinding.objectName === 'bones') {\n        if (trackNode.isSkinnedMesh === true) {\n          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n        } else {\n          trackNode = undefined;\n        }\n      }\n      if (!trackNode || !trackProperty) {\n        console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n        return null;\n      }\n      const inputItemSize = 1;\n      let outputItemSize = track.values.length / track.times.length;\n      if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n        outputItemSize /= trackNode.morphTargetInfluences.length;\n      }\n      let interpolation;\n\n      // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n\n      // Detecting glTF cubic spline interpolant by checking factory method's special property\n      // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n      // valid value from .getInterpolation().\n      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\n        interpolation = 'CUBICSPLINE';\n\n        // itemSize of CUBICSPLINE keyframe is 9\n        // (VEC3 * 3: inTangent, splineVertex, and outTangent)\n        // but needs to be stored as VEC3 so dividing by 3 here.\n        outputItemSize /= 3;\n      } else if (track.getInterpolation() === InterpolateDiscrete) {\n        interpolation = 'STEP';\n      } else {\n        interpolation = 'LINEAR';\n      }\n      samplers.push({\n        input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n        output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n        interpolation: interpolation\n      });\n      channels.push({\n        sampler: samplers.length - 1,\n        target: {\n          node: nodeMap.get(trackNode),\n          path: trackProperty\n        }\n      });\n    }\n    json.animations.push({\n      name: clip.name || 'clip_' + json.animations.length,\n      samplers: samplers,\n      channels: channels\n    });\n    return json.animations.length - 1;\n  }\n\n  /**\n   * @param {THREE.Object3D} object\n   * @return {number|null}\n   */\n  processSkin(object) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n    const node = json.nodes[nodeMap.get(object)];\n    const skeleton = object.skeleton;\n    if (skeleton === undefined) return null;\n    const rootJoint = object.skeleton.bones[0];\n    if (rootJoint === undefined) return null;\n    const joints = [];\n    const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n    const temporaryBoneInverse = new Matrix4();\n    for (let i = 0; i < skeleton.bones.length; ++i) {\n      joints.push(nodeMap.get(skeleton.bones[i]));\n      temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n      temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\n    }\n    if (json.skins === undefined) json.skins = [];\n    json.skins.push({\n      inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n      joints: joints,\n      skeleton: nodeMap.get(rootJoint)\n    });\n    const skinIndex = node.skin = json.skins.length - 1;\n    return skinIndex;\n  }\n\n  /**\n   * Process Object3D node\n   * @param  {THREE.Object3D} node Object3D to processNode\n   * @return {Integer} Index of the node in the nodes list\n   */\n  processNode(object) {\n    const json = this.json;\n    const options = this.options;\n    const nodeMap = this.nodeMap;\n    if (!json.nodes) json.nodes = [];\n    const nodeDef = {};\n    if (options.trs) {\n      const rotation = object.quaternion.toArray();\n      const position = object.position.toArray();\n      const scale = object.scale.toArray();\n      if (!equalArray(rotation, [0, 0, 0, 1])) {\n        nodeDef.rotation = rotation;\n      }\n      if (!equalArray(position, [0, 0, 0])) {\n        nodeDef.translation = position;\n      }\n      if (!equalArray(scale, [1, 1, 1])) {\n        nodeDef.scale = scale;\n      }\n    } else {\n      if (object.matrixAutoUpdate) {\n        object.updateMatrix();\n      }\n      if (isIdentityMatrix(object.matrix) === false) {\n        nodeDef.matrix = object.matrix.elements;\n      }\n    }\n\n    // We don't export empty strings name because it represents no-name in Three.js.\n    if (object.name !== '') nodeDef.name = String(object.name);\n    this.serializeUserData(object, nodeDef);\n    if (object.isMesh || object.isLine || object.isPoints) {\n      const meshIndex = this.processMesh(object);\n      if (meshIndex !== null) nodeDef.mesh = meshIndex;\n    } else if (object.isCamera) {\n      nodeDef.camera = this.processCamera(object);\n    }\n    if (object.isSkinnedMesh) this.skins.push(object);\n    if (object.children.length > 0) {\n      const children = [];\n      for (let i = 0, l = object.children.length; i < l; i++) {\n        const child = object.children[i];\n        if (child.visible || options.onlyVisible === false) {\n          const nodeIndex = this.processNode(child);\n          if (nodeIndex !== null) children.push(nodeIndex);\n        }\n      }\n      if (children.length > 0) nodeDef.children = children;\n    }\n    this._invokeAll(function (ext) {\n      ext.writeNode && ext.writeNode(object, nodeDef);\n    });\n    const nodeIndex = json.nodes.push(nodeDef) - 1;\n    nodeMap.set(object, nodeIndex);\n    return nodeIndex;\n  }\n\n  /**\n   * Process Scene\n   * @param  {Scene} node Scene to process\n   */\n  processScene(scene) {\n    const json = this.json;\n    const options = this.options;\n    if (!json.scenes) {\n      json.scenes = [];\n      json.scene = 0;\n    }\n    const sceneDef = {};\n    if (scene.name !== '') sceneDef.name = scene.name;\n    json.scenes.push(sceneDef);\n    const nodes = [];\n    for (let i = 0, l = scene.children.length; i < l; i++) {\n      const child = scene.children[i];\n      if (child.visible || options.onlyVisible === false) {\n        const nodeIndex = this.processNode(child);\n        if (nodeIndex !== null) nodes.push(nodeIndex);\n      }\n    }\n    if (nodes.length > 0) sceneDef.nodes = nodes;\n    this.serializeUserData(scene, sceneDef);\n  }\n\n  /**\n   * Creates a Scene to hold a list of objects and parse it\n   * @param  {Array} objects List of objects to process\n   */\n  processObjects(objects) {\n    const scene = new Scene();\n    scene.name = 'AuxScene';\n    for (let i = 0; i < objects.length; i++) {\n      // We push directly to children instead of calling `add` to prevent\n      // modify the .parent and break its original scene and hierarchy\n      scene.children.push(objects[i]);\n    }\n    this.processScene(scene);\n  }\n\n  /**\n   * @param {THREE.Object3D|Array<THREE.Object3D>} input\n   */\n  processInput(input) {\n    const options = this.options;\n    input = input instanceof Array ? input : [input];\n    this._invokeAll(function (ext) {\n      ext.beforeParse && ext.beforeParse(input);\n    });\n    const objectsWithoutScene = [];\n    for (let i = 0; i < input.length; i++) {\n      if (input[i] instanceof Scene) {\n        this.processScene(input[i]);\n      } else {\n        objectsWithoutScene.push(input[i]);\n      }\n    }\n    if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);\n    for (let i = 0; i < this.skins.length; ++i) {\n      this.processSkin(this.skins[i]);\n    }\n    for (let i = 0; i < options.animations.length; ++i) {\n      this.processAnimation(options.animations[i], input[0]);\n    }\n    this._invokeAll(function (ext) {\n      ext.afterParse && ext.afterParse(input);\n    });\n  }\n  _invokeAll(func) {\n    for (let i = 0, il = this.plugins.length; i < il; i++) {\n      func(this.plugins[i]);\n    }\n  }\n}\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_lights_punctual';\n  }\n  writeNode(light, nodeDef) {\n    if (!light.isLight) return;\n    if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {\n      console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light);\n      return;\n    }\n    const writer = this.writer;\n    const json = writer.json;\n    const extensionsUsed = writer.extensionsUsed;\n    const lightDef = {};\n    if (light.name) lightDef.name = light.name;\n    lightDef.color = light.color.toArray();\n    lightDef.intensity = light.intensity;\n    if (light.isDirectionalLight) {\n      lightDef.type = 'directional';\n    } else if (light.isPointLight) {\n      lightDef.type = 'point';\n      if (light.distance > 0) lightDef.range = light.distance;\n    } else if (light.isSpotLight) {\n      lightDef.type = 'spot';\n      if (light.distance > 0) lightDef.range = light.distance;\n      lightDef.spot = {};\n      lightDef.spot.innerConeAngle = (light.penumbra - 1.0) * light.angle * -1.0;\n      lightDef.spot.outerConeAngle = light.angle;\n    }\n    if (light.decay !== undefined && light.decay !== 2) {\n      console.warn('THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.');\n    }\n    if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n      console.warn('THREE.GLTFExporter: Light direction may be lost. For best results, ' + 'make light.target a child of the light with position 0,0,-1.');\n    }\n    if (!extensionsUsed[this.name]) {\n      json.extensions = json.extensions || {};\n      json.extensions[this.name] = {\n        lights: []\n      };\n      extensionsUsed[this.name] = true;\n    }\n    const lights = json.extensions[this.name].lights;\n    lights.push(lightDef);\n    nodeDef.extensions = nodeDef.extensions || {};\n    nodeDef.extensions[this.name] = {\n      light: lights.length - 1\n    };\n  }\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_unlit';\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshBasicMaterial) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = {};\n    extensionsUsed[this.name] = true;\n    materialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n  }\n}\n\n/**\n * Specular-Glossiness Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness\n */\nclass GLTFMaterialsPBRSpecularGlossiness {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_pbrSpecularGlossiness';\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isGLTFSpecularGlossinessMaterial) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (materialDef.pbrMetallicRoughness.baseColorFactor) {\n      extensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;\n    }\n    const specularFactor = [1, 1, 1];\n    material.specular.toArray(specularFactor, 0);\n    extensionDef.specularFactor = specularFactor;\n    extensionDef.glossinessFactor = material.glossiness;\n    if (materialDef.pbrMetallicRoughness.baseColorTexture) {\n      extensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;\n    }\n    if (material.specularMap) {\n      const specularMapDef = {\n        index: writer.processTexture(material.specularMap)\n      };\n      writer.applyTextureTransform(specularMapDef, material.specularMap);\n      extensionDef.specularGlossinessTexture = specularMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_clearcoat';\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.clearcoatFactor = material.clearcoat;\n    if (material.clearcoatMap) {\n      const clearcoatMapDef = {\n        index: writer.processTexture(material.clearcoatMap)\n      };\n      writer.applyTextureTransform(clearcoatMapDef, material.clearcoatMap);\n      extensionDef.clearcoatTexture = clearcoatMapDef;\n    }\n    extensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;\n    if (material.clearcoatRoughnessMap) {\n      const clearcoatRoughnessMapDef = {\n        index: writer.processTexture(material.clearcoatRoughnessMap)\n      };\n      writer.applyTextureTransform(clearcoatRoughnessMapDef, material.clearcoatRoughnessMap);\n      extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;\n    }\n    if (material.clearcoatNormalMap) {\n      const clearcoatNormalMapDef = {\n        index: writer.processTexture(material.clearcoatNormalMap)\n      };\n      writer.applyTextureTransform(clearcoatNormalMapDef, material.clearcoatNormalMap);\n      extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_iridescence';\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.iridescenceFactor = material.iridescence;\n    if (material.iridescenceMap) {\n      const iridescenceMapDef = {\n        index: writer.processTexture(material.iridescenceMap)\n      };\n      writer.applyTextureTransform(iridescenceMapDef, material.iridescenceMap);\n      extensionDef.iridescenceTexture = iridescenceMapDef;\n    }\n    extensionDef.iridescenceIor = material.iridescenceIOR;\n    extensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[0];\n    extensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[1];\n    if (material.iridescenceThicknessMap) {\n      const iridescenceThicknessMapDef = {\n        index: writer.processTexture(material.iridescenceThicknessMap)\n      };\n      writer.applyTextureTransform(iridescenceThicknessMapDef, material.iridescenceThicknessMap);\n      extensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n */\nclass GLTFMaterialsTransmissionExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_transmission';\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.transmissionFactor = material.transmission;\n    if (material.transmissionMap) {\n      const transmissionMapDef = {\n        index: writer.processTexture(material.transmissionMap)\n      };\n      writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);\n      extensionDef.transmissionTexture = transmissionMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_volume';\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.thicknessFactor = material.thickness;\n    if (material.thicknessMap) {\n      const thicknessMapDef = {\n        index: writer.processTexture(material.thicknessMap)\n      };\n      writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);\n      extensionDef.thicknessTexture = thicknessMapDef;\n    }\n    extensionDef.attenuationDistance = material.attenuationDistance;\n    extensionDef.attenuationColor = material.attenuationColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\n\n/**\n * Static utility functions\n */\nGLTFExporter.Utils = {\n  insertKeyframe: function (track, time) {\n    const tolerance = 0.001; // 1ms\n    const valueSize = track.getValueSize();\n    const times = new track.TimeBufferType(track.times.length + 1);\n    const values = new track.ValueBufferType(track.values.length + valueSize);\n    const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n    let index;\n    if (track.times.length === 0) {\n      times[0] = time;\n      for (let i = 0; i < valueSize; i++) {\n        values[i] = 0;\n      }\n      index = 0;\n    } else if (time < track.times[0]) {\n      if (Math.abs(track.times[0] - time) < tolerance) return 0;\n      times[0] = time;\n      times.set(track.times, 1);\n      values.set(interpolant.evaluate(time), 0);\n      values.set(track.values, valueSize);\n      index = 0;\n    } else if (time > track.times[track.times.length - 1]) {\n      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n        return track.times.length - 1;\n      }\n      times[times.length - 1] = time;\n      times.set(track.times, 0);\n      values.set(track.values, 0);\n      values.set(interpolant.evaluate(time), track.values.length);\n      index = times.length - 1;\n    } else {\n      for (let i = 0; i < track.times.length; i++) {\n        if (Math.abs(track.times[i] - time) < tolerance) return i;\n        if (track.times[i] < time && track.times[i + 1] > time) {\n          times.set(track.times.slice(0, i + 1), 0);\n          times[i + 1] = time;\n          times.set(track.times.slice(i + 1), i + 2);\n          values.set(track.values.slice(0, (i + 1) * valueSize), 0);\n          values.set(interpolant.evaluate(time), (i + 1) * valueSize);\n          values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);\n          index = i + 1;\n          break;\n        }\n      }\n    }\n    track.times = times;\n    track.values = values;\n    return index;\n  },\n  mergeMorphTargetTracks: function (clip, root) {\n    const tracks = [];\n    const mergedTracks = {};\n    const sourceTracks = clip.tracks;\n    for (let i = 0; i < sourceTracks.length; ++i) {\n      let sourceTrack = sourceTracks[i];\n      const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\n      const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n      if (sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined) {\n        // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n        tracks.push(sourceTrack);\n        continue;\n      }\n      if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n          // This should never happen, because glTF morph target animations\n          // affect all targets already.\n          throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.');\n        }\n        console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.');\n        sourceTrack = sourceTrack.clone();\n        sourceTrack.setInterpolation(InterpolateLinear);\n      }\n      const targetCount = sourceTrackNode.morphTargetInfluences.length;\n      const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n      if (targetIndex === undefined) {\n        throw new Error('THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex);\n      }\n      let mergedTrack;\n\n      // If this is the first time we've seen this object, create a new\n      // track to store merged keyframe data for each morph target.\n      if (mergedTracks[sourceTrackNode.uuid] === undefined) {\n        mergedTrack = sourceTrack.clone();\n        const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n        for (let j = 0; j < mergedTrack.times.length; j++) {\n          values[j * targetCount + targetIndex] = mergedTrack.values[j];\n        }\n\n        // We need to take into consideration the intended target node\n        // of our original un-merged morphTarget animation.\n        mergedTrack.name = (sourceTrackBinding.nodeName || '') + '.morphTargetInfluences';\n        mergedTrack.values = values;\n        mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n        tracks.push(mergedTrack);\n        continue;\n      }\n      const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n      mergedTrack = mergedTracks[sourceTrackNode.uuid];\n\n      // For every existing keyframe of the merged track, write a (possibly\n      // interpolated) value from the source track.\n      for (let j = 0; j < mergedTrack.times.length; j++) {\n        mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);\n      }\n\n      // For every existing keyframe of the source track, write a (possibly\n      // new) keyframe to the merged track. Values from the previous loop may\n      // be written again, but keyframes are de-duplicated.\n      for (let j = 0; j < sourceTrack.times.length; j++) {\n        const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);\n        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];\n      }\n    }\n    clip.tracks = tracks;\n    return clip;\n  }\n};\nexport { GLTFExporter };","map":{"version":3,"names":["BufferAttribute","ClampToEdgeWrapping","DoubleSide","InterpolateDiscrete","InterpolateLinear","LinearEncoding","LinearFilter","LinearMipmapLinearFilter","LinearMipmapNearestFilter","MathUtils","Matrix4","MirroredRepeatWrapping","NearestFilter","NearestMipmapLinearFilter","NearestMipmapNearestFilter","PropertyBinding","RGBAFormat","RepeatWrapping","Scene","Source","sRGBEncoding","Vector3","GLTFExporter","constructor","pluginCallbacks","register","writer","GLTFLightExtension","GLTFMaterialsUnlitExtension","GLTFMaterialsPBRSpecularGlossiness","GLTFMaterialsTransmissionExtension","GLTFMaterialsVolumeExtension","GLTFMaterialsClearcoatExtension","GLTFMaterialsIridescenceExtension","callback","indexOf","push","unregister","splice","parse","input","onDone","onError","options","GLTFWriter","plugins","i","il","length","setPlugins","write","catch","parseAsync","scope","Promise","resolve","reject","WEBGL_CONSTANTS","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","UNSIGNED_BYTE","UNSIGNED_SHORT","FLOAT","UNSIGNED_INT","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","NEAREST","LINEAR","NEAREST_MIPMAP_NEAREST","LINEAR_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_LINEAR","CLAMP_TO_EDGE","MIRRORED_REPEAT","REPEAT","THREE_TO_WEBGL","PATH_PROPERTIES","scale","position","quaternion","morphTargetInfluences","GLB_HEADER_BYTES","GLB_HEADER_MAGIC","GLB_VERSION","GLB_CHUNK_PREFIX_BYTES","GLB_CHUNK_TYPE_JSON","GLB_CHUNK_TYPE_BIN","equalArray","array1","array2","every","element","index","stringToArrayBuffer","text","TextEncoder","encode","buffer","isIdentityMatrix","matrix","elements","getMinMax","attribute","start","count","output","min","Array","itemSize","fill","Number","POSITIVE_INFINITY","max","NEGATIVE_INFINITY","a","value","array","getX","getY","getZ","getW","Math","getPaddedBufferSize","bufferSize","ceil","getPaddedArrayBuffer","arrayBuffer","paddingByte","paddedLength","byteLength","Uint8Array","set","getCanvas","document","OffscreenCanvas","createElement","getToBlobPromise","canvas","mimeType","toBlob","undefined","quality","convertToBlob","type","pending","buffers","byteOffset","nodeMap","Map","skins","extensionsUsed","uids","uid","json","asset","version","generator","cache","meshes","attributes","attributesNormalized","materials","textures","images","Object","assign","binary","trs","onlyVisible","maxTextureSize","Infinity","animations","includeCustomExtensions","processInput","all","blob","Blob","extensionsUsedList","keys","size","reader","FileReader","readAsArrayBuffer","onloadend","binaryChunk","result","binaryChunkPrefix","DataView","ArrayBuffer","setUint32","jsonChunk","JSON","stringify","jsonChunkPrefix","header","headerView","totalByteLength","glbBlob","glbReader","readAsDataURL","base64data","uri","serializeUserData","object","objectDef","userData","gltfExtensions","extensions","extensionName","extras","error","console","warn","name","message","getUID","isRelativeCopy","has","get","isNormalizedNormalAttribute","normal","v","abs","fromBufferAttribute","createNormalizedNormalAttribute","clone","x","y","z","setX","normalize","setXYZ","applyTextureTransform","mapDef","texture","didTransform","transformDef","offset","toArray","rotation","repeat","buildMetalRoughTexture","metalnessMap","roughnessMap","getEncodingConversion","map","encoding","SRGBToLinear","c","pow","LinearToLinear","metalness","image","roughness","width","height","context","getContext","fillStyle","fillRect","composite","getImageData","drawImage","convert","data","putImageData","reference","source","processBuffer","processBufferView","componentType","target","bufferViews","componentSize","dataView","setFloat32","setUint16","setUint8","bufferViewDef","byteStride","id","processBufferViewImage","processAccessor","geometry","types","Float32Array","Uint32Array","Uint16Array","Error","minMax","bufferViewTarget","bufferView","accessorDef","normalized","accessors","processImage","format","flipY","cachedImages","key","toString","imageDef","ctx","translate","Uint8ClampedArray","ImageData","then","bufferViewIndex","toDataURL","dataURL","processSampler","samplers","samplerDef","magFilter","minFilter","wrapS","wrapT","processTexture","textureDef","sampler","_invokeAll","ext","writeTexture","processMaterial","material","isShaderMaterial","materialDef","pbrMetallicRoughness","isMeshStandardMaterial","isMeshBasicMaterial","color","concat","opacity","baseColorFactor","metallicFactor","roughnessFactor","metalRoughTexture","metalRoughMapDef","metallicRoughnessTexture","baseColorMapDef","baseColorTexture","emissive","multiplyScalar","emissiveIntensity","maxEmissiveComponent","r","g","b","emissiveFactor","emissiveMap","emissiveMapDef","emissiveTexture","normalMap","normalMapDef","normalScale","normalTexture","aoMap","occlusionMapDef","texCoord","aoMapIntensity","strength","occlusionTexture","transparent","alphaMode","alphaTest","alphaCutoff","side","doubleSided","writeMaterial","processMesh","mesh","meshCacheKeyParts","uuid","isArray","l","meshCacheKey","join","mode","isLineSegments","isLineLoop","isLine","isPoints","wireframe","meshDef","primitives","targets","nameConversion","uv","uv2","skinWeight","skinIndex","originalNormal","getAttribute","setAttribute","modifiedAttribute","attributeName","slice","toUpperCase","validVertexAttributes","test","accessor","weights","targetNames","reverseDictionary","morphTargetDictionary","warned","morphAttributes","gltfAttributeName","baseAttribute","relativeAttribute","morphTargetsRelative","j","jl","isMultiMaterial","groups","materialIndex","primitive","cacheKey","indices","writeMesh","processCamera","camera","cameras","isOrtho","isOrthographicCamera","cameraDef","orthographic","xmag","right","ymag","top","zfar","far","znear","near","perspective","aspectRatio","aspect","yfov","degToRad","fov","processAnimation","clip","root","Utils","mergeMorphTargetTracks","tracks","channels","track","trackBinding","parseTrackName","trackNode","findNode","nodeName","trackProperty","propertyName","objectName","isSkinnedMesh","skeleton","getBoneByName","objectIndex","inputItemSize","outputItemSize","values","times","interpolation","createInterpolant","isInterpolantFactoryMethodGLTFCubicSpline","getInterpolation","node","path","processSkin","nodes","rootJoint","bones","joints","inverseBindMatrices","temporaryBoneInverse","copy","boneInverses","multiply","bindMatrix","skin","processNode","nodeDef","translation","matrixAutoUpdate","updateMatrix","String","isMesh","meshIndex","isCamera","children","child","visible","nodeIndex","writeNode","processScene","scene","scenes","sceneDef","processObjects","objects","beforeParse","objectsWithoutScene","afterParse","func","light","isLight","isDirectionalLight","isPointLight","isSpotLight","lightDef","intensity","distance","range","spot","innerConeAngle","penumbra","angle","outerConeAngle","decay","parent","lights","isGLTFSpecularGlossinessMaterial","extensionDef","diffuseFactor","specularFactor","specular","glossinessFactor","glossiness","diffuseTexture","specularMap","specularMapDef","specularGlossinessTexture","isMeshPhysicalMaterial","clearcoatFactor","clearcoat","clearcoatMap","clearcoatMapDef","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughness","clearcoatRoughnessMap","clearcoatRoughnessMapDef","clearcoatRoughnessTexture","clearcoatNormalMap","clearcoatNormalMapDef","clearcoatNormalTexture","iridescenceFactor","iridescence","iridescenceMap","iridescenceMapDef","iridescenceTexture","iridescenceIor","iridescenceIOR","iridescenceThicknessMinimum","iridescenceThicknessRange","iridescenceThicknessMaximum","iridescenceThicknessMap","iridescenceThicknessMapDef","iridescenceThicknessTexture","transmission","transmissionFactor","transmissionMap","transmissionMapDef","transmissionTexture","thicknessFactor","thickness","thicknessMap","thicknessMapDef","thicknessTexture","attenuationDistance","attenuationColor","insertKeyframe","time","tolerance","valueSize","getValueSize","TimeBufferType","ValueBufferType","interpolant","evaluate","mergedTracks","sourceTracks","sourceTrack","sourceTrackBinding","sourceTrackNode","propertyIndex","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","setInterpolation","targetCount","targetIndex","mergedTrack","sourceInterpolant","keyframeIndex"],"sources":["C:/Users/SUMAN K/meta_transfer/node_modules/three/examples/jsm/exporters/GLTFExporter.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tClampToEdgeWrapping,\n\tDoubleSide,\n\tInterpolateDiscrete,\n\tInterpolateLinear,\n\tLinearEncoding,\n\tLinearFilter,\n\tLinearMipmapLinearFilter,\n\tLinearMipmapNearestFilter,\n\tMathUtils,\n\tMatrix4,\n\tMirroredRepeatWrapping,\n\tNearestFilter,\n\tNearestMipmapLinearFilter,\n\tNearestMipmapNearestFilter,\n\tPropertyBinding,\n\tRGBAFormat,\n\tRepeatWrapping,\n\tScene,\n\tSource,\n\tsRGBEncoding,\n\tVector3\n} from 'three';\n\nclass GLTFExporter {\n\n\tconstructor() {\n\n\t\tthis.pluginCallbacks = [];\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFLightExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsUnlitExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsPBRSpecularGlossiness( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsTransmissionExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsVolumeExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsClearcoatExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsIridescenceExtension( writer );\n\n\t\t} );\n\n\t}\n\n\tregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\n\n\t\t\tthis.pluginCallbacks.push( callback );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tunregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\n\n\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Parse scenes and generate GLTF output\n\t * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n\t * @param  {Function} onDone  Callback on completed\n\t * @param  {Function} onError  Callback on errors\n\t * @param  {Object} options options\n\t */\n\tparse( input, onDone, onError, options ) {\n\n\t\tconst writer = new GLTFWriter();\n\t\tconst plugins = [];\n\n\t\tfor ( let i = 0, il = this.pluginCallbacks.length; i < il; i ++ ) {\n\n\t\t\tplugins.push( this.pluginCallbacks[ i ]( writer ) );\n\n\t\t}\n\n\t\twriter.setPlugins( plugins );\n\t\twriter.write( input, onDone, options ).catch( onError );\n\n\t}\n\n\tparseAsync( input, options ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.parse( input, resolve, reject, options );\n\n\t\t} );\n\n\t}\n\n}\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst WEBGL_CONSTANTS = {\n\tPOINTS: 0x0000,\n\tLINES: 0x0001,\n\tLINE_LOOP: 0x0002,\n\tLINE_STRIP: 0x0003,\n\tTRIANGLES: 0x0004,\n\tTRIANGLE_STRIP: 0x0005,\n\tTRIANGLE_FAN: 0x0006,\n\n\tUNSIGNED_BYTE: 0x1401,\n\tUNSIGNED_SHORT: 0x1403,\n\tFLOAT: 0x1406,\n\tUNSIGNED_INT: 0x1405,\n\tARRAY_BUFFER: 0x8892,\n\tELEMENT_ARRAY_BUFFER: 0x8893,\n\n\tNEAREST: 0x2600,\n\tLINEAR: 0x2601,\n\tNEAREST_MIPMAP_NEAREST: 0x2700,\n\tLINEAR_MIPMAP_NEAREST: 0x2701,\n\tNEAREST_MIPMAP_LINEAR: 0x2702,\n\tLINEAR_MIPMAP_LINEAR: 0x2703,\n\n\tCLAMP_TO_EDGE: 33071,\n\tMIRRORED_REPEAT: 33648,\n\tREPEAT: 10497\n};\n\nconst THREE_TO_WEBGL = {};\n\nTHREE_TO_WEBGL[ NearestFilter ] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[ NearestMipmapNearestFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[ NearestMipmapLinearFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ LinearFilter ] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[ LinearMipmapNearestFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[ LinearMipmapLinearFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\n\nTHREE_TO_WEBGL[ ClampToEdgeWrapping ] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[ RepeatWrapping ] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[ MirroredRepeatWrapping ] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\n\nconst PATH_PROPERTIES = {\n\tscale: 'scale',\n\tposition: 'translation',\n\tquaternion: 'rotation',\n\tmorphTargetInfluences: 'weights'\n};\n\n// GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nconst GLB_HEADER_BYTES = 12;\nconst GLB_HEADER_MAGIC = 0x46546C67;\nconst GLB_VERSION = 2;\n\nconst GLB_CHUNK_PREFIX_BYTES = 8;\nconst GLB_CHUNK_TYPE_JSON = 0x4E4F534A;\nconst GLB_CHUNK_TYPE_BIN = 0x004E4942;\n\n//------------------------------------------------------------------------------\n// Utility functions\n//------------------------------------------------------------------------------\n\n/**\n * Compare two arrays\n * @param  {Array} array1 Array 1 to compare\n * @param  {Array} array2 Array 2 to compare\n * @return {Boolean}        Returns true if both arrays are equal\n */\nfunction equalArray( array1, array2 ) {\n\n\treturn ( array1.length === array2.length ) && array1.every( function ( element, index ) {\n\n\t\treturn element === array2[ index ];\n\n\t} );\n\n}\n\n/**\n * Converts a string to an ArrayBuffer.\n * @param  {string} text\n * @return {ArrayBuffer}\n */\nfunction stringToArrayBuffer( text ) {\n\n\treturn new TextEncoder().encode( text ).buffer;\n\n}\n\n/**\n * Is identity matrix\n *\n * @param {Matrix4} matrix\n * @returns {Boolean} Returns true, if parameter is identity matrix\n */\nfunction isIdentityMatrix( matrix ) {\n\n\treturn equalArray( matrix.elements, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ] );\n\n}\n\n/**\n * Get the min and max vectors from the given attribute\n * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n * @param  {Integer} start\n * @param  {Integer} count\n * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n */\nfunction getMinMax( attribute, start, count ) {\n\n\tconst output = {\n\n\t\tmin: new Array( attribute.itemSize ).fill( Number.POSITIVE_INFINITY ),\n\t\tmax: new Array( attribute.itemSize ).fill( Number.NEGATIVE_INFINITY )\n\n\t};\n\n\tfor ( let i = start; i < start + count; i ++ ) {\n\n\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\tlet value;\n\n\t\t\tif ( attribute.itemSize > 4 ) {\n\n\t\t\t\t // no support for interleaved data for itemSize > 4\n\n\t\t\t\tvalue = attribute.array[ i * attribute.itemSize + a ];\n\n\t\t\t} else {\n\n\t\t\t\tif ( a === 0 ) value = attribute.getX( i );\n\t\t\t\telse if ( a === 1 ) value = attribute.getY( i );\n\t\t\t\telse if ( a === 2 ) value = attribute.getZ( i );\n\t\t\t\telse if ( a === 3 ) value = attribute.getW( i );\n\n\t\t\t}\n\n\t\t\toutput.min[ a ] = Math.min( output.min[ a ], value );\n\t\t\toutput.max[ a ] = Math.max( output.max[ a ], value );\n\n\t\t}\n\n\t}\n\n\treturn output;\n\n}\n\n/**\n * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n *\n * @param {Integer} bufferSize The size the original buffer.\n * @returns {Integer} new buffer size with required padding.\n *\n */\nfunction getPaddedBufferSize( bufferSize ) {\n\n\treturn Math.ceil( bufferSize / 4 ) * 4;\n\n}\n\n/**\n * Returns a buffer aligned to 4-byte boundary.\n *\n * @param {ArrayBuffer} arrayBuffer Buffer to pad\n * @param {Integer} paddingByte (Optional)\n * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n */\nfunction getPaddedArrayBuffer( arrayBuffer, paddingByte = 0 ) {\n\n\tconst paddedLength = getPaddedBufferSize( arrayBuffer.byteLength );\n\n\tif ( paddedLength !== arrayBuffer.byteLength ) {\n\n\t\tconst array = new Uint8Array( paddedLength );\n\t\tarray.set( new Uint8Array( arrayBuffer ) );\n\n\t\tif ( paddingByte !== 0 ) {\n\n\t\t\tfor ( let i = arrayBuffer.byteLength; i < paddedLength; i ++ ) {\n\n\t\t\t\tarray[ i ] = paddingByte;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn array.buffer;\n\n\t}\n\n\treturn arrayBuffer;\n\n}\n\nfunction getCanvas() {\n\n\tif ( typeof document === 'undefined' && typeof OffscreenCanvas !== 'undefined' ) {\n\n\t\treturn new OffscreenCanvas( 1, 1 );\n\n\t}\n\n\treturn document.createElement( 'canvas' );\n\n}\n\nfunction getToBlobPromise( canvas, mimeType ) {\n\n\tif ( canvas.toBlob !== undefined ) {\n\n\t\treturn new Promise( ( resolve ) => canvas.toBlob( resolve, mimeType ) );\n\n\t}\n\n\tlet quality;\n\n\t// Blink's implementation of convertToBlob seems to default to a quality level of 100%\n\t// Use the Blink default quality levels of toBlob instead so that file sizes are comparable.\n\tif ( mimeType === 'image/jpeg' ) {\n\n\t\tquality = 0.92;\n\n\t} else if ( mimeType === 'image/webp' ) {\n\n\t\tquality = 0.8;\n\n\t}\n\n\treturn canvas.convertToBlob( {\n\n\t\ttype: mimeType,\n\t\tquality: quality\n\n\t} );\n\n}\n\n/**\n * Writer\n */\nclass GLTFWriter {\n\n\tconstructor() {\n\n\t\tthis.plugins = [];\n\n\t\tthis.options = {};\n\t\tthis.pending = [];\n\t\tthis.buffers = [];\n\n\t\tthis.byteOffset = 0;\n\t\tthis.buffers = [];\n\t\tthis.nodeMap = new Map();\n\t\tthis.skins = [];\n\t\tthis.extensionsUsed = {};\n\n\t\tthis.uids = new Map();\n\t\tthis.uid = 0;\n\n\t\tthis.json = {\n\t\t\tasset: {\n\t\t\t\tversion: '2.0',\n\t\t\t\tgenerator: 'THREE.GLTFExporter'\n\t\t\t}\n\t\t};\n\n\t\tthis.cache = {\n\t\t\tmeshes: new Map(),\n\t\t\tattributes: new Map(),\n\t\t\tattributesNormalized: new Map(),\n\t\t\tmaterials: new Map(),\n\t\t\ttextures: new Map(),\n\t\t\timages: new Map()\n\t\t};\n\n\t}\n\n\tsetPlugins( plugins ) {\n\n\t\tthis.plugins = plugins;\n\n\t}\n\n\t/**\n\t * Parse scenes and generate GLTF output\n\t * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n\t * @param  {Function} onDone  Callback on completed\n\t * @param  {Object} options options\n\t */\n\tasync write( input, onDone, options ) {\n\n\t\tthis.options = Object.assign( {}, {\n\t\t\t// default options\n\t\t\tbinary: false,\n\t\t\ttrs: false,\n\t\t\tonlyVisible: true,\n\t\t\tmaxTextureSize: Infinity,\n\t\t\tanimations: [],\n\t\t\tincludeCustomExtensions: false\n\t\t}, options );\n\n\t\tif ( this.options.animations.length > 0 ) {\n\n\t\t\t// Only TRS properties, and not matrices, may be targeted by animation.\n\t\t\tthis.options.trs = true;\n\n\t\t}\n\n\t\tthis.processInput( input );\n\n\t\tawait Promise.all( this.pending );\n\n\t\tconst writer = this;\n\t\tconst buffers = writer.buffers;\n\t\tconst json = writer.json;\n\t\toptions = writer.options;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\t// Merge buffers.\n\t\tconst blob = new Blob( buffers, { type: 'application/octet-stream' } );\n\n\t\t// Declare extensions.\n\t\tconst extensionsUsedList = Object.keys( extensionsUsed );\n\n\t\tif ( extensionsUsedList.length > 0 ) json.extensionsUsed = extensionsUsedList;\n\n\t\t// Update bytelength of the single buffer.\n\t\tif ( json.buffers && json.buffers.length > 0 ) json.buffers[ 0 ].byteLength = blob.size;\n\n\t\tif ( options.binary === true ) {\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n\t\t\tconst reader = new FileReader();\n\t\t\treader.readAsArrayBuffer( blob );\n\t\t\treader.onloadend = function () {\n\n\t\t\t\t// Binary chunk.\n\t\t\t\tconst binaryChunk = getPaddedArrayBuffer( reader.result );\n\t\t\t\tconst binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\tbinaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );\n\t\t\t\tbinaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );\n\n\t\t\t\t// JSON chunk.\n\t\t\t\tconst jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( json ) ), 0x20 );\n\t\t\t\tconst jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\tjsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );\n\t\t\t\tjsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );\n\n\t\t\t\t// GLB header.\n\t\t\t\tconst header = new ArrayBuffer( GLB_HEADER_BYTES );\n\t\t\t\tconst headerView = new DataView( header );\n\t\t\t\theaderView.setUint32( 0, GLB_HEADER_MAGIC, true );\n\t\t\t\theaderView.setUint32( 4, GLB_VERSION, true );\n\t\t\t\tconst totalByteLength = GLB_HEADER_BYTES\n\t\t\t\t\t+ jsonChunkPrefix.byteLength + jsonChunk.byteLength\n\t\t\t\t\t+ binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n\t\t\t\theaderView.setUint32( 8, totalByteLength, true );\n\n\t\t\t\tconst glbBlob = new Blob( [\n\t\t\t\t\theader,\n\t\t\t\t\tjsonChunkPrefix,\n\t\t\t\t\tjsonChunk,\n\t\t\t\t\tbinaryChunkPrefix,\n\t\t\t\t\tbinaryChunk\n\t\t\t\t], { type: 'application/octet-stream' } );\n\n\t\t\t\tconst glbReader = new FileReader();\n\t\t\t\tglbReader.readAsArrayBuffer( glbBlob );\n\t\t\t\tglbReader.onloadend = function () {\n\n\t\t\t\t\tonDone( glbReader.result );\n\n\t\t\t\t};\n\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tif ( json.buffers && json.buffers.length > 0 ) {\n\n\t\t\t\tconst reader = new FileReader();\n\t\t\t\treader.readAsDataURL( blob );\n\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\tconst base64data = reader.result;\n\t\t\t\t\tjson.buffers[ 0 ].uri = base64data;\n\t\t\t\t\tonDone( json );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tonDone( json );\n\n\t\t\t}\n\n\t\t}\n\n\n\t}\n\n\t/**\n\t * Serializes a userData.\n\t *\n\t * @param {THREE.Object3D|THREE.Material} object\n\t * @param {Object} objectDef\n\t */\n\tserializeUserData( object, objectDef ) {\n\n\t\tif ( Object.keys( object.userData ).length === 0 ) return;\n\n\t\tconst options = this.options;\n\t\tconst extensionsUsed = this.extensionsUsed;\n\n\t\ttry {\n\n\t\t\tconst json = JSON.parse( JSON.stringify( object.userData ) );\n\n\t\t\tif ( options.includeCustomExtensions && json.gltfExtensions ) {\n\n\t\t\t\tif ( objectDef.extensions === undefined ) objectDef.extensions = {};\n\n\t\t\t\tfor ( const extensionName in json.gltfExtensions ) {\n\n\t\t\t\t\tobjectDef.extensions[ extensionName ] = json.gltfExtensions[ extensionName ];\n\t\t\t\t\textensionsUsed[ extensionName ] = true;\n\n\t\t\t\t}\n\n\t\t\t\tdelete json.gltfExtensions;\n\n\t\t\t}\n\n\t\t\tif ( Object.keys( json ).length > 0 ) objectDef.extras = json;\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: userData of \\'' + object.name + '\\' ' +\n\t\t\t\t'won\\'t be serialized because of JSON.stringify error - ' + error.message );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns ids for buffer attributes.\n\t * @param  {Object} object\n\t * @return {Integer}\n\t */\n\tgetUID( attribute, isRelativeCopy = false ) {\n\n\t\tif ( this.uids.has( attribute ) === false ) {\n\n\t\t\tconst uids = new Map();\n\n\t\t\tuids.set( true, this.uid ++ );\n\t\t\tuids.set( false, this.uid ++ );\n\n\t\t\tthis.uids.set( attribute, uids );\n\n\t\t}\n\n\t\tconst uids = this.uids.get( attribute );\n\n\t\treturn uids.get( isRelativeCopy );\n\n\t}\n\n\t/**\n\t * Checks if normal attribute values are normalized.\n\t *\n\t * @param {BufferAttribute} normal\n\t * @returns {Boolean}\n\t */\n\tisNormalizedNormalAttribute( normal ) {\n\n\t\tconst cache = this.cache;\n\n\t\tif ( cache.attributesNormalized.has( normal ) ) return false;\n\n\t\tconst v = new Vector3();\n\n\t\tfor ( let i = 0, il = normal.count; i < il; i ++ ) {\n\n\t\t\t// 0.0005 is from glTF-validator\n\t\t\tif ( Math.abs( v.fromBufferAttribute( normal, i ).length() - 1.0 ) > 0.0005 ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Creates normalized normal buffer attribute.\n\t *\n\t * @param {BufferAttribute} normal\n\t * @returns {BufferAttribute}\n\t *\n\t */\n\tcreateNormalizedNormalAttribute( normal ) {\n\n\t\tconst cache = this.cache;\n\n\t\tif ( cache.attributesNormalized.has( normal ) )\treturn cache.attributesNormalized.get( normal );\n\n\t\tconst attribute = normal.clone();\n\t\tconst v = new Vector3();\n\n\t\tfor ( let i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\tv.fromBufferAttribute( attribute, i );\n\n\t\t\tif ( v.x === 0 && v.y === 0 && v.z === 0 ) {\n\n\t\t\t\t// if values can't be normalized set (1, 0, 0)\n\t\t\t\tv.setX( 1.0 );\n\n\t\t\t} else {\n\n\t\t\t\tv.normalize();\n\n\t\t\t}\n\n\t\t\tattribute.setXYZ( i, v.x, v.y, v.z );\n\n\t\t}\n\n\t\tcache.attributesNormalized.set( normal, attribute );\n\n\t\treturn attribute;\n\n\t}\n\n\t/**\n\t * Applies a texture transform, if present, to the map definition. Requires\n\t * the KHR_texture_transform extension.\n\t *\n\t * @param {Object} mapDef\n\t * @param {THREE.Texture} texture\n\t */\n\tapplyTextureTransform( mapDef, texture ) {\n\n\t\tlet didTransform = false;\n\t\tconst transformDef = {};\n\n\t\tif ( texture.offset.x !== 0 || texture.offset.y !== 0 ) {\n\n\t\t\ttransformDef.offset = texture.offset.toArray();\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( texture.rotation !== 0 ) {\n\n\t\t\ttransformDef.rotation = texture.rotation;\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( texture.repeat.x !== 1 || texture.repeat.y !== 1 ) {\n\n\t\t\ttransformDef.scale = texture.repeat.toArray();\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( didTransform ) {\n\n\t\t\tmapDef.extensions = mapDef.extensions || {};\n\t\t\tmapDef.extensions[ 'KHR_texture_transform' ] = transformDef;\n\t\t\tthis.extensionsUsed[ 'KHR_texture_transform' ] = true;\n\n\t\t}\n\n\t}\n\n\tbuildMetalRoughTexture( metalnessMap, roughnessMap ) {\n\n\t\tif ( metalnessMap === roughnessMap ) return metalnessMap;\n\n\t\tfunction getEncodingConversion( map ) {\n\n\t\t\tif ( map.encoding === sRGBEncoding ) {\n\n\t\t\t\treturn function SRGBToLinear( c ) {\n\n\t\t\t\t\treturn ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\treturn function LinearToLinear( c ) {\n\n\t\t\t\treturn c;\n\n\t\t\t};\n\n\t\t}\n\n\t\tconsole.warn( 'THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.' );\n\n\t\tconst metalness = metalnessMap?.image;\n\t\tconst roughness = roughnessMap?.image;\n\n\t\tconst width = Math.max( metalness?.width || 0, roughness?.width || 0 );\n\t\tconst height = Math.max( metalness?.height || 0, roughness?.height || 0 );\n\n\t\tconst canvas = getCanvas();\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\n\t\tconst context = canvas.getContext( '2d' );\n\t\tcontext.fillStyle = '#00ffff';\n\t\tcontext.fillRect( 0, 0, width, height );\n\n\t\tconst composite = context.getImageData( 0, 0, width, height );\n\n\t\tif ( metalness ) {\n\n\t\t\tcontext.drawImage( metalness, 0, 0, width, height );\n\n\t\t\tconst convert = getEncodingConversion( metalnessMap );\n\t\t\tconst data = context.getImageData( 0, 0, width, height ).data;\n\n\t\t\tfor ( let i = 2; i < data.length; i += 4 ) {\n\n\t\t\t\tcomposite.data[ i ] = convert( data[ i ] / 256 ) * 256;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( roughness ) {\n\n\t\t\tcontext.drawImage( roughness, 0, 0, width, height );\n\n\t\t\tconst convert = getEncodingConversion( roughnessMap );\n\t\t\tconst data = context.getImageData( 0, 0, width, height ).data;\n\n\t\t\tfor ( let i = 1; i < data.length; i += 4 ) {\n\n\t\t\t\tcomposite.data[ i ] = convert( data[ i ] / 256 ) * 256;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcontext.putImageData( composite, 0, 0 );\n\n\t\t//\n\n\t\tconst reference = metalnessMap || roughnessMap;\n\n\t\tconst texture = reference.clone();\n\n\t\ttexture.source = new Source( canvas );\n\t\ttexture.encoding = LinearEncoding;\n\n\t\treturn texture;\n\n\t}\n\n\t/**\n\t * Process a buffer to append to the default one.\n\t * @param  {ArrayBuffer} buffer\n\t * @return {Integer}\n\t */\n\tprocessBuffer( buffer ) {\n\n\t\tconst json = this.json;\n\t\tconst buffers = this.buffers;\n\n\t\tif ( ! json.buffers ) json.buffers = [ { byteLength: 0 } ];\n\n\t\t// All buffers are merged before export.\n\t\tbuffers.push( buffer );\n\n\t\treturn 0;\n\n\t}\n\n\t/**\n\t * Process and generate a BufferView\n\t * @param  {BufferAttribute} attribute\n\t * @param  {number} componentType\n\t * @param  {number} start\n\t * @param  {number} count\n\t * @param  {number} target (Optional) Target usage of the BufferView\n\t * @return {Object}\n\t */\n\tprocessBufferView( attribute, componentType, start, count, target ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.bufferViews ) json.bufferViews = [];\n\n\t\t// Create a new dataview and dump the attribute's array into it\n\n\t\tlet componentSize;\n\n\t\tif ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\n\n\t\t\tcomponentSize = 1;\n\n\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\n\n\t\t\tcomponentSize = 2;\n\n\t\t} else {\n\n\t\t\tcomponentSize = 4;\n\n\t\t}\n\n\t\tconst byteLength = getPaddedBufferSize( count * attribute.itemSize * componentSize );\n\t\tconst dataView = new DataView( new ArrayBuffer( byteLength ) );\n\t\tlet offset = 0;\n\n\t\tfor ( let i = start; i < start + count; i ++ ) {\n\n\t\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\t\tlet value;\n\n\t\t\t\tif ( attribute.itemSize > 4 ) {\n\n\t\t\t\t\t // no support for interleaved data for itemSize > 4\n\n\t\t\t\t\tvalue = attribute.array[ i * attribute.itemSize + a ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( a === 0 ) value = attribute.getX( i );\n\t\t\t\t\telse if ( a === 1 ) value = attribute.getY( i );\n\t\t\t\t\telse if ( a === 2 ) value = attribute.getZ( i );\n\t\t\t\t\telse if ( a === 3 ) value = attribute.getW( i );\n\n\t\t\t\t}\n\n\t\t\t\tif ( componentType === WEBGL_CONSTANTS.FLOAT ) {\n\n\t\t\t\t\tdataView.setFloat32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_INT ) {\n\n\t\t\t\t\tdataView.setUint32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\n\n\t\t\t\t\tdataView.setUint16( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\n\n\t\t\t\t\tdataView.setUint8( offset, value );\n\n\t\t\t\t}\n\n\t\t\t\toffset += componentSize;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bufferViewDef = {\n\n\t\t\tbuffer: this.processBuffer( dataView.buffer ),\n\t\t\tbyteOffset: this.byteOffset,\n\t\t\tbyteLength: byteLength\n\n\t\t};\n\n\t\tif ( target !== undefined ) bufferViewDef.target = target;\n\n\t\tif ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {\n\n\t\t\t// Only define byteStride for vertex attributes.\n\t\t\tbufferViewDef.byteStride = attribute.itemSize * componentSize;\n\n\t\t}\n\n\t\tthis.byteOffset += byteLength;\n\n\t\tjson.bufferViews.push( bufferViewDef );\n\n\t\t// @TODO Merge bufferViews where possible.\n\t\tconst output = {\n\n\t\t\tid: json.bufferViews.length - 1,\n\t\t\tbyteLength: 0\n\n\t\t};\n\n\t\treturn output;\n\n\t}\n\n\t/**\n\t * Process and generate a BufferView from an image Blob.\n\t * @param {Blob} blob\n\t * @return {Promise<Integer>}\n\t */\n\tprocessBufferViewImage( blob ) {\n\n\t\tconst writer = this;\n\t\tconst json = writer.json;\n\n\t\tif ( ! json.bufferViews ) json.bufferViews = [];\n\n\t\treturn new Promise( function ( resolve ) {\n\n\t\t\tconst reader = new FileReader();\n\t\t\treader.readAsArrayBuffer( blob );\n\t\t\treader.onloadend = function () {\n\n\t\t\t\tconst buffer = getPaddedArrayBuffer( reader.result );\n\n\t\t\t\tconst bufferViewDef = {\n\t\t\t\t\tbuffer: writer.processBuffer( buffer ),\n\t\t\t\t\tbyteOffset: writer.byteOffset,\n\t\t\t\t\tbyteLength: buffer.byteLength\n\t\t\t\t};\n\n\t\t\t\twriter.byteOffset += buffer.byteLength;\n\t\t\t\tresolve( json.bufferViews.push( bufferViewDef ) - 1 );\n\n\t\t\t};\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Process attribute to generate an accessor\n\t * @param  {BufferAttribute} attribute Attribute to process\n\t * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n\t * @param  {Integer} start (Optional)\n\t * @param  {Integer} count (Optional)\n\t * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n\t */\n\tprocessAccessor( attribute, geometry, start, count ) {\n\n\t\tconst json = this.json;\n\n\t\tconst types = {\n\n\t\t\t1: 'SCALAR',\n\t\t\t2: 'VEC2',\n\t\t\t3: 'VEC3',\n\t\t\t4: 'VEC4',\n\t\t\t16: 'MAT4'\n\n\t\t};\n\n\t\tlet componentType;\n\n\t\t// Detect the component type of the attribute array (float, uint or ushort)\n\t\tif ( attribute.array.constructor === Float32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.FLOAT;\n\n\t\t} else if ( attribute.array.constructor === Uint32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n\n\t\t} else if ( attribute.array.constructor === Uint16Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n\n\t\t} else if ( attribute.array.constructor === Uint8Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.GLTFExporter: Unsupported bufferAttribute component type.' );\n\n\t\t}\n\n\t\tif ( start === undefined ) start = 0;\n\t\tif ( count === undefined ) count = attribute.count;\n\n\t\t// Skip creating an accessor if the attribute doesn't have data to export\n\t\tif ( count === 0 ) return null;\n\n\t\tconst minMax = getMinMax( attribute, start, count );\n\t\tlet bufferViewTarget;\n\n\t\t// If geometry isn't provided, don't infer the target usage of the bufferView. For\n\t\t// animation samplers, target must not be set.\n\t\tif ( geometry !== undefined ) {\n\n\t\t\tbufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n\n\t\t}\n\n\t\tconst bufferView = this.processBufferView( attribute, componentType, start, count, bufferViewTarget );\n\n\t\tconst accessorDef = {\n\n\t\t\tbufferView: bufferView.id,\n\t\t\tbyteOffset: bufferView.byteOffset,\n\t\t\tcomponentType: componentType,\n\t\t\tcount: count,\n\t\t\tmax: minMax.max,\n\t\t\tmin: minMax.min,\n\t\t\ttype: types[ attribute.itemSize ]\n\n\t\t};\n\n\t\tif ( attribute.normalized === true ) accessorDef.normalized = true;\n\t\tif ( ! json.accessors ) json.accessors = [];\n\n\t\treturn json.accessors.push( accessorDef ) - 1;\n\n\t}\n\n\t/**\n\t * Process image\n\t * @param  {Image} image to process\n\t * @param  {Integer} format of the image (RGBAFormat)\n\t * @param  {Boolean} flipY before writing out the image\n\t * @param  {String} mimeType export format\n\t * @return {Integer}     Index of the processed texture in the \"images\" array\n\t */\n\tprocessImage( image, format, flipY, mimeType = 'image/png' ) {\n\n\t\tconst writer = this;\n\t\tconst cache = writer.cache;\n\t\tconst json = writer.json;\n\t\tconst options = writer.options;\n\t\tconst pending = writer.pending;\n\n\t\tif ( ! cache.images.has( image ) ) cache.images.set( image, {} );\n\n\t\tconst cachedImages = cache.images.get( image );\n\n\t\tconst key = mimeType + ':flipY/' + flipY.toString();\n\n\t\tif ( cachedImages[ key ] !== undefined ) return cachedImages[ key ];\n\n\t\tif ( ! json.images ) json.images = [];\n\n\t\tconst imageDef = { mimeType: mimeType };\n\n\t\tconst canvas = getCanvas();\n\n\t\tcanvas.width = Math.min( image.width, options.maxTextureSize );\n\t\tcanvas.height = Math.min( image.height, options.maxTextureSize );\n\n\t\tconst ctx = canvas.getContext( '2d' );\n\n\t\tif ( flipY === true ) {\n\n\t\t\tctx.translate( 0, canvas.height );\n\t\t\tctx.scale( 1, - 1 );\n\n\t\t}\n\n\t\tif ( image.data !== undefined ) { // THREE.DataTexture\n\n\t\t\tif ( format !== RGBAFormat ) {\n\n\t\t\t\tconsole.error( 'GLTFExporter: Only RGBAFormat is supported.' );\n\n\t\t\t}\n\n\t\t\tif ( image.width > options.maxTextureSize || image.height > options.maxTextureSize ) {\n\n\t\t\t\tconsole.warn( 'GLTFExporter: Image size is bigger than maxTextureSize', image );\n\n\t\t\t}\n\n\t\t\tconst data = new Uint8ClampedArray( image.height * image.width * 4 );\n\n\t\t\tfor ( let i = 0; i < data.length; i += 4 ) {\n\n\t\t\t\tdata[ i + 0 ] = image.data[ i + 0 ];\n\t\t\t\tdata[ i + 1 ] = image.data[ i + 1 ];\n\t\t\t\tdata[ i + 2 ] = image.data[ i + 2 ];\n\t\t\t\tdata[ i + 3 ] = image.data[ i + 3 ];\n\n\t\t\t}\n\n\t\t\tctx.putImageData( new ImageData( data, image.width, image.height ), 0, 0 );\n\n\t\t} else {\n\n\t\t\tctx.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\t}\n\n\t\tif ( options.binary === true ) {\n\n\t\t\tpending.push(\n\n\t\t\t\tgetToBlobPromise( canvas, mimeType )\n\t\t\t\t\t.then( blob => writer.processBufferViewImage( blob ) )\n\t\t\t\t\t.then( bufferViewIndex => {\n\n\t\t\t\t\t\timageDef.bufferView = bufferViewIndex;\n\n\t\t\t\t\t} )\n\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tif ( canvas.toDataURL !== undefined ) {\n\n\t\t\t\timageDef.uri = canvas.toDataURL( mimeType );\n\n\t\t\t} else {\n\n\t\t\t\tpending.push(\n\n\t\t\t\t\tgetToBlobPromise( canvas, mimeType )\n\t\t\t\t\t\t.then( blob => new FileReader().readAsDataURL( blob ) )\n\t\t\t\t\t\t.then( dataURL => {\n\n\t\t\t\t\t\t\timageDef.uri = dataURL;\n\n\t\t\t\t\t\t} )\n\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst index = json.images.push( imageDef ) - 1;\n\t\tcachedImages[ key ] = index;\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process sampler\n\t * @param  {Texture} map Texture to process\n\t * @return {Integer}     Index of the processed texture in the \"samplers\" array\n\t */\n\tprocessSampler( map ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.samplers ) json.samplers = [];\n\n\t\tconst samplerDef = {\n\t\t\tmagFilter: THREE_TO_WEBGL[ map.magFilter ],\n\t\t\tminFilter: THREE_TO_WEBGL[ map.minFilter ],\n\t\t\twrapS: THREE_TO_WEBGL[ map.wrapS ],\n\t\t\twrapT: THREE_TO_WEBGL[ map.wrapT ]\n\t\t};\n\n\t\treturn json.samplers.push( samplerDef ) - 1;\n\n\t}\n\n\t/**\n\t * Process texture\n\t * @param  {Texture} map Map to process\n\t * @return {Integer} Index of the processed texture in the \"textures\" array\n\t */\n\tprocessTexture( map ) {\n\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tif ( cache.textures.has( map ) ) return cache.textures.get( map );\n\n\t\tif ( ! json.textures ) json.textures = [];\n\n\t\tlet mimeType = map.userData.mimeType;\n\n\t\tif ( mimeType === 'image/webp' ) mimeType = 'image/png';\n\n\t\tconst textureDef = {\n\t\t\tsampler: this.processSampler( map ),\n\t\t\tsource: this.processImage( map.image, map.format, map.flipY, mimeType )\n\t\t};\n\n\t\tif ( map.name ) textureDef.name = map.name;\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.writeTexture && ext.writeTexture( map, textureDef );\n\n\t\t} );\n\n\t\tconst index = json.textures.push( textureDef ) - 1;\n\t\tcache.textures.set( map, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process material\n\t * @param  {THREE.Material} material Material to process\n\t * @return {Integer|null} Index of the processed material in the \"materials\" array\n\t */\n\tprocessMaterial( material ) {\n\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tif ( cache.materials.has( material ) ) return cache.materials.get( material );\n\n\t\tif ( material.isShaderMaterial ) {\n\n\t\t\tconsole.warn( 'GLTFExporter: THREE.ShaderMaterial not supported.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( ! json.materials ) json.materials = [];\n\n\t\t// @QUESTION Should we avoid including any attribute that has the default value?\n\t\tconst materialDef = {\tpbrMetallicRoughness: {} };\n\n\t\tif ( material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true ) {\n\n\t\t\tconsole.warn( 'GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.' );\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.baseColorFactor\n\t\tconst color = material.color.toArray().concat( [ material.opacity ] );\n\n\t\tif ( ! equalArray( color, [ 1, 1, 1, 1 ] ) ) {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.baseColorFactor = color;\n\n\t\t}\n\n\t\tif ( material.isMeshStandardMaterial ) {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n\n\t\t} else {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.metallicRoughnessTexture\n\t\tif ( material.metalnessMap || material.roughnessMap ) {\n\n\t\t\tconst metalRoughTexture = this.buildMetalRoughTexture( material.metalnessMap, material.roughnessMap );\n\n\t\t\tconst metalRoughMapDef = { index: this.processTexture( metalRoughTexture ) };\n\t\t\tthis.applyTextureTransform( metalRoughMapDef, metalRoughTexture );\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\n\t\tif ( material.map ) {\n\n\t\t\tconst baseColorMapDef = { index: this.processTexture( material.map ) };\n\t\t\tthis.applyTextureTransform( baseColorMapDef, material.map );\n\t\t\tmaterialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n\n\t\t}\n\n\t\tif ( material.emissive ) {\n\n\t\t\t// note: emissive components are limited to stay within the 0 - 1 range to accommodate glTF spec. see #21849 and #22000.\n\t\t\tconst emissive = material.emissive.clone().multiplyScalar( material.emissiveIntensity );\n\t\t\tconst maxEmissiveComponent = Math.max( emissive.r, emissive.g, emissive.b );\n\n\t\t\tif ( maxEmissiveComponent > 1 ) {\n\n\t\t\t\temissive.multiplyScalar( 1 / maxEmissiveComponent );\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited' );\n\n\t\t\t}\n\n\t\t\tif ( maxEmissiveComponent > 0 ) {\n\n\t\t\t\tmaterialDef.emissiveFactor = emissive.toArray();\n\n\t\t\t}\n\n\t\t\t// emissiveTexture\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tconst emissiveMapDef = { index: this.processTexture( material.emissiveMap ) };\n\t\t\t\tthis.applyTextureTransform( emissiveMapDef, material.emissiveMap );\n\t\t\t\tmaterialDef.emissiveTexture = emissiveMapDef;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// normalTexture\n\t\tif ( material.normalMap ) {\n\n\t\t\tconst normalMapDef = { index: this.processTexture( material.normalMap ) };\n\n\t\t\tif ( material.normalScale && material.normalScale.x !== 1 ) {\n\n\t\t\t\t// glTF normal scale is univariate. Ignore `y`, which may be flipped.\n\t\t\t\t// Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\tnormalMapDef.scale = material.normalScale.x;\n\n\t\t\t}\n\n\t\t\tthis.applyTextureTransform( normalMapDef, material.normalMap );\n\t\t\tmaterialDef.normalTexture = normalMapDef;\n\n\t\t}\n\n\t\t// occlusionTexture\n\t\tif ( material.aoMap ) {\n\n\t\t\tconst occlusionMapDef = {\n\t\t\t\tindex: this.processTexture( material.aoMap ),\n\t\t\t\ttexCoord: 1\n\t\t\t};\n\n\t\t\tif ( material.aoMapIntensity !== 1.0 ) {\n\n\t\t\t\tocclusionMapDef.strength = material.aoMapIntensity;\n\n\t\t\t}\n\n\t\t\tthis.applyTextureTransform( occlusionMapDef, material.aoMap );\n\t\t\tmaterialDef.occlusionTexture = occlusionMapDef;\n\n\t\t}\n\n\t\t// alphaMode\n\t\tif ( material.transparent ) {\n\n\t\t\tmaterialDef.alphaMode = 'BLEND';\n\n\t\t} else {\n\n\t\t\tif ( material.alphaTest > 0.0 ) {\n\n\t\t\t\tmaterialDef.alphaMode = 'MASK';\n\t\t\t\tmaterialDef.alphaCutoff = material.alphaTest;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// doubleSided\n\t\tif ( material.side === DoubleSide ) materialDef.doubleSided = true;\n\t\tif ( material.name !== '' ) materialDef.name = material.name;\n\n\t\tthis.serializeUserData( material, materialDef );\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.writeMaterial && ext.writeMaterial( material, materialDef );\n\n\t\t} );\n\n\t\tconst index = json.materials.push( materialDef ) - 1;\n\t\tcache.materials.set( material, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process mesh\n\t * @param  {THREE.Mesh} mesh Mesh to process\n\t * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n\t */\n\tprocessMesh( mesh ) {\n\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tconst meshCacheKeyParts = [ mesh.geometry.uuid ];\n\n\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\tfor ( let i = 0, l = mesh.material.length; i < l; i ++ ) {\n\n\t\t\t\tmeshCacheKeyParts.push( mesh.material[ i ].uuid\t);\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tmeshCacheKeyParts.push( mesh.material.uuid );\n\n\t\t}\n\n\t\tconst meshCacheKey = meshCacheKeyParts.join( ':' );\n\n\t\tif ( cache.meshes.has( meshCacheKey ) ) return cache.meshes.get( meshCacheKey );\n\n\t\tconst geometry = mesh.geometry;\n\n\t\tlet mode;\n\n\t\t// Use the correct mode\n\t\tif ( mesh.isLineSegments ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINES;\n\n\t\t} else if ( mesh.isLineLoop ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINE_LOOP;\n\n\t\t} else if ( mesh.isLine ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINE_STRIP;\n\n\t\t} else if ( mesh.isPoints ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.POINTS;\n\n\t\t} else {\n\n\t\t\tmode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n\n\t\t}\n\n\t\tconst meshDef = {};\n\t\tconst attributes = {};\n\t\tconst primitives = [];\n\t\tconst targets = [];\n\n\t\t// Conversion between attributes names in threejs and gltf spec\n\t\tconst nameConversion = {\n\t\t\tuv: 'TEXCOORD_0',\n\t\t\tuv2: 'TEXCOORD_1',\n\t\t\tcolor: 'COLOR_0',\n\t\t\tskinWeight: 'WEIGHTS_0',\n\t\t\tskinIndex: 'JOINTS_0'\n\t\t};\n\n\t\tconst originalNormal = geometry.getAttribute( 'normal' );\n\n\t\tif ( originalNormal !== undefined && ! this.isNormalizedNormalAttribute( originalNormal ) ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.' );\n\n\t\t\tgeometry.setAttribute( 'normal', this.createNormalizedNormalAttribute( originalNormal ) );\n\n\t\t}\n\n\t\t// @QUESTION Detect if .vertexColors = true?\n\t\t// For every attribute create an accessor\n\t\tlet modifiedAttribute = null;\n\n\t\tfor ( let attributeName in geometry.attributes ) {\n\n\t\t\t// Ignore morph target attributes, which are exported later.\n\t\t\tif ( attributeName.slice( 0, 5 ) === 'morph' ) continue;\n\n\t\t\tconst attribute = geometry.attributes[ attributeName ];\n\t\t\tattributeName = nameConversion[ attributeName ] || attributeName.toUpperCase();\n\n\t\t\t// Prefix all geometry attributes except the ones specifically\n\t\t\t// listed in the spec; non-spec attributes are considered custom.\n\t\t\tconst validVertexAttributes =\n\t\t\t\t\t/^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n\n\t\t\tif ( ! validVertexAttributes.test( attributeName ) ) attributeName = '_' + attributeName;\n\n\t\t\tif ( cache.attributes.has( this.getUID( attribute ) ) ) {\n\n\t\t\t\tattributes[ attributeName ] = cache.attributes.get( this.getUID( attribute ) );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n\t\t\tmodifiedAttribute = null;\n\t\t\tconst array = attribute.array;\n\n\t\t\tif ( attributeName === 'JOINTS_0' &&\n\t\t\t\t! ( array instanceof Uint16Array ) &&\n\t\t\t\t! ( array instanceof Uint8Array ) ) {\n\n\t\t\t\tconsole.warn( 'GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.' );\n\t\t\t\tmodifiedAttribute = new BufferAttribute( new Uint16Array( array ), attribute.itemSize, attribute.normalized );\n\n\t\t\t}\n\n\t\t\tconst accessor = this.processAccessor( modifiedAttribute || attribute, geometry );\n\n\t\t\tif ( accessor !== null ) {\n\n\t\t\t\tattributes[ attributeName ] = accessor;\n\t\t\t\tcache.attributes.set( this.getUID( attribute ), accessor );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( originalNormal !== undefined ) geometry.setAttribute( 'normal', originalNormal );\n\n\t\t// Skip if no exportable attributes found\n\t\tif ( Object.keys( attributes ).length === 0 ) return null;\n\n\t\t// Morph targets\n\t\tif ( mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0 ) {\n\n\t\t\tconst weights = [];\n\t\t\tconst targetNames = [];\n\t\t\tconst reverseDictionary = {};\n\n\t\t\tif ( mesh.morphTargetDictionary !== undefined ) {\n\n\t\t\t\tfor ( const key in mesh.morphTargetDictionary ) {\n\n\t\t\t\t\treverseDictionary[ mesh.morphTargetDictionary[ key ] ] = key;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < mesh.morphTargetInfluences.length; ++ i ) {\n\n\t\t\t\tconst target = {};\n\t\t\t\tlet warned = false;\n\n\t\t\t\tfor ( const attributeName in geometry.morphAttributes ) {\n\n\t\t\t\t\t// glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n\t\t\t\t\t// Three.js doesn't support TANGENT yet.\n\n\t\t\t\t\tif ( attributeName !== 'position' && attributeName !== 'normal' ) {\n\n\t\t\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Only POSITION and NORMAL morph are supported.' );\n\t\t\t\t\t\t\twarned = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst attribute = geometry.morphAttributes[ attributeName ][ i ];\n\t\t\t\t\tconst gltfAttributeName = attributeName.toUpperCase();\n\n\t\t\t\t\t// Three.js morph attribute has absolute values while the one of glTF has relative values.\n\t\t\t\t\t//\n\t\t\t\t\t// glTF 2.0 Specification:\n\t\t\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n\t\t\t\t\tconst baseAttribute = geometry.attributes[ attributeName ];\n\n\t\t\t\t\tif ( cache.attributes.has( this.getUID( attribute, true ) ) ) {\n\n\t\t\t\t\t\ttarget[ gltfAttributeName ] = cache.attributes.get( this.getUID( attribute, true ) );\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Clones attribute not to override\n\t\t\t\t\tconst relativeAttribute = attribute.clone();\n\n\t\t\t\t\tif ( ! geometry.morphTargetsRelative ) {\n\n\t\t\t\t\t\tfor ( let j = 0, jl = attribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\trelativeAttribute.setXYZ(\n\t\t\t\t\t\t\t\tj,\n\t\t\t\t\t\t\t\tattribute.getX( j ) - baseAttribute.getX( j ),\n\t\t\t\t\t\t\t\tattribute.getY( j ) - baseAttribute.getY( j ),\n\t\t\t\t\t\t\t\tattribute.getZ( j ) - baseAttribute.getZ( j )\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttarget[ gltfAttributeName ] = this.processAccessor( relativeAttribute, geometry );\n\t\t\t\t\tcache.attributes.set( this.getUID( baseAttribute, true ), target[ gltfAttributeName ] );\n\n\t\t\t\t}\n\n\t\t\t\ttargets.push( target );\n\n\t\t\t\tweights.push( mesh.morphTargetInfluences[ i ] );\n\n\t\t\t\tif ( mesh.morphTargetDictionary !== undefined ) targetNames.push( reverseDictionary[ i ] );\n\n\t\t\t}\n\n\t\t\tmeshDef.weights = weights;\n\n\t\t\tif ( targetNames.length > 0 ) {\n\n\t\t\t\tmeshDef.extras = {};\n\t\t\t\tmeshDef.extras.targetNames = targetNames;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst isMultiMaterial = Array.isArray( mesh.material );\n\n\t\tif ( isMultiMaterial && geometry.groups.length === 0 ) return null;\n\n\t\tconst materials = isMultiMaterial ? mesh.material : [ mesh.material ];\n\t\tconst groups = isMultiMaterial ? geometry.groups : [ { materialIndex: 0, start: undefined, count: undefined } ];\n\n\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\tconst primitive = {\n\t\t\t\tmode: mode,\n\t\t\t\tattributes: attributes,\n\t\t\t};\n\n\t\t\tthis.serializeUserData( geometry, primitive );\n\n\t\t\tif ( targets.length > 0 ) primitive.targets = targets;\n\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\tlet cacheKey = this.getUID( geometry.index );\n\n\t\t\t\tif ( groups[ i ].start !== undefined || groups[ i ].count !== undefined ) {\n\n\t\t\t\t\tcacheKey += ':' + groups[ i ].start + ':' + groups[ i ].count;\n\n\t\t\t\t}\n\n\t\t\t\tif ( cache.attributes.has( cacheKey ) ) {\n\n\t\t\t\t\tprimitive.indices = cache.attributes.get( cacheKey );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tprimitive.indices = this.processAccessor( geometry.index, geometry, groups[ i ].start, groups[ i ].count );\n\t\t\t\t\tcache.attributes.set( cacheKey, primitive.indices );\n\n\t\t\t\t}\n\n\t\t\t\tif ( primitive.indices === null ) delete primitive.indices;\n\n\t\t\t}\n\n\t\t\tconst material = this.processMaterial( materials[ groups[ i ].materialIndex ] );\n\n\t\t\tif ( material !== null ) primitive.material = material;\n\n\t\t\tprimitives.push( primitive );\n\n\t\t}\n\n\t\tmeshDef.primitives = primitives;\n\n\t\tif ( ! json.meshes ) json.meshes = [];\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.writeMesh && ext.writeMesh( mesh, meshDef );\n\n\t\t} );\n\n\t\tconst index = json.meshes.push( meshDef ) - 1;\n\t\tcache.meshes.set( meshCacheKey, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process camera\n\t * @param  {THREE.Camera} camera Camera to process\n\t * @return {Integer}      Index of the processed mesh in the \"camera\" array\n\t */\n\tprocessCamera( camera ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.cameras ) json.cameras = [];\n\n\t\tconst isOrtho = camera.isOrthographicCamera;\n\n\t\tconst cameraDef = {\n\t\t\ttype: isOrtho ? 'orthographic' : 'perspective'\n\t\t};\n\n\t\tif ( isOrtho ) {\n\n\t\t\tcameraDef.orthographic = {\n\t\t\t\txmag: camera.right * 2,\n\t\t\t\tymag: camera.top * 2,\n\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tcameraDef.perspective = {\n\t\t\t\taspectRatio: camera.aspect,\n\t\t\t\tyfov: MathUtils.degToRad( camera.fov ),\n\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\t\t\t};\n\n\t\t}\n\n\t\t// Question: Is saving \"type\" as name intentional?\n\t\tif ( camera.name !== '' ) cameraDef.name = camera.type;\n\n\t\treturn json.cameras.push( cameraDef ) - 1;\n\n\t}\n\n\t/**\n\t * Creates glTF animation entry from AnimationClip object.\n\t *\n\t * Status:\n\t * - Only properties listed in PATH_PROPERTIES may be animated.\n\t *\n\t * @param {THREE.AnimationClip} clip\n\t * @param {THREE.Object3D} root\n\t * @return {number|null}\n\t */\n\tprocessAnimation( clip, root ) {\n\n\t\tconst json = this.json;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tif ( ! json.animations ) json.animations = [];\n\n\t\tclip = GLTFExporter.Utils.mergeMorphTargetTracks( clip.clone(), root );\n\n\t\tconst tracks = clip.tracks;\n\t\tconst channels = [];\n\t\tconst samplers = [];\n\n\t\tfor ( let i = 0; i < tracks.length; ++ i ) {\n\n\t\t\tconst track = tracks[ i ];\n\t\t\tconst trackBinding = PropertyBinding.parseTrackName( track.name );\n\t\t\tlet trackNode = PropertyBinding.findNode( root, trackBinding.nodeName );\n\t\t\tconst trackProperty = PATH_PROPERTIES[ trackBinding.propertyName ];\n\n\t\t\tif ( trackBinding.objectName === 'bones' ) {\n\n\t\t\t\tif ( trackNode.isSkinnedMesh === true ) {\n\n\t\t\t\t\ttrackNode = trackNode.skeleton.getBoneByName( trackBinding.objectIndex );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttrackNode = undefined;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! trackNode || ! trackProperty ) {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Could not export animation track \"%s\".', track.name );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tconst inputItemSize = 1;\n\t\t\tlet outputItemSize = track.values.length / track.times.length;\n\n\t\t\tif ( trackProperty === PATH_PROPERTIES.morphTargetInfluences ) {\n\n\t\t\t\toutputItemSize /= trackNode.morphTargetInfluences.length;\n\n\t\t\t}\n\n\t\t\tlet interpolation;\n\n\t\t\t// @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n\n\t\t\t// Detecting glTF cubic spline interpolant by checking factory method's special property\n\t\t\t// GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n\t\t\t// valid value from .getInterpolation().\n\t\t\tif ( track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ) {\n\n\t\t\t\tinterpolation = 'CUBICSPLINE';\n\n\t\t\t\t// itemSize of CUBICSPLINE keyframe is 9\n\t\t\t\t// (VEC3 * 3: inTangent, splineVertex, and outTangent)\n\t\t\t\t// but needs to be stored as VEC3 so dividing by 3 here.\n\t\t\t\toutputItemSize /= 3;\n\n\t\t\t} else if ( track.getInterpolation() === InterpolateDiscrete ) {\n\n\t\t\t\tinterpolation = 'STEP';\n\n\t\t\t} else {\n\n\t\t\t\tinterpolation = 'LINEAR';\n\n\t\t\t}\n\n\t\t\tsamplers.push( {\n\t\t\t\tinput: this.processAccessor( new BufferAttribute( track.times, inputItemSize ) ),\n\t\t\t\toutput: this.processAccessor( new BufferAttribute( track.values, outputItemSize ) ),\n\t\t\t\tinterpolation: interpolation\n\t\t\t} );\n\n\t\t\tchannels.push( {\n\t\t\t\tsampler: samplers.length - 1,\n\t\t\t\ttarget: {\n\t\t\t\t\tnode: nodeMap.get( trackNode ),\n\t\t\t\t\tpath: trackProperty\n\t\t\t\t}\n\t\t\t} );\n\n\t\t}\n\n\t\tjson.animations.push( {\n\t\t\tname: clip.name || 'clip_' + json.animations.length,\n\t\t\tsamplers: samplers,\n\t\t\tchannels: channels\n\t\t} );\n\n\t\treturn json.animations.length - 1;\n\n\t}\n\n\t/**\n\t * @param {THREE.Object3D} object\n\t * @return {number|null}\n\t */\n\t processSkin( object ) {\n\n\t\tconst json = this.json;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tconst node = json.nodes[ nodeMap.get( object ) ];\n\n\t\tconst skeleton = object.skeleton;\n\n\t\tif ( skeleton === undefined ) return null;\n\n\t\tconst rootJoint = object.skeleton.bones[ 0 ];\n\n\t\tif ( rootJoint === undefined ) return null;\n\n\t\tconst joints = [];\n\t\tconst inverseBindMatrices = new Float32Array( skeleton.bones.length * 16 );\n\t\tconst temporaryBoneInverse = new Matrix4();\n\n\t\tfor ( let i = 0; i < skeleton.bones.length; ++ i ) {\n\n\t\t\tjoints.push( nodeMap.get( skeleton.bones[ i ] ) );\n\t\t\ttemporaryBoneInverse.copy( skeleton.boneInverses[ i ] );\n\t\t\ttemporaryBoneInverse.multiply( object.bindMatrix ).toArray( inverseBindMatrices, i * 16 );\n\n\t\t}\n\n\t\tif ( json.skins === undefined ) json.skins = [];\n\n\t\tjson.skins.push( {\n\t\t\tinverseBindMatrices: this.processAccessor( new BufferAttribute( inverseBindMatrices, 16 ) ),\n\t\t\tjoints: joints,\n\t\t\tskeleton: nodeMap.get( rootJoint )\n\t\t} );\n\n\t\tconst skinIndex = node.skin = json.skins.length - 1;\n\n\t\treturn skinIndex;\n\n\t}\n\n\t/**\n\t * Process Object3D node\n\t * @param  {THREE.Object3D} node Object3D to processNode\n\t * @return {Integer} Index of the node in the nodes list\n\t */\n\tprocessNode( object ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tif ( ! json.nodes ) json.nodes = [];\n\n\t\tconst nodeDef = {};\n\n\t\tif ( options.trs ) {\n\n\t\t\tconst rotation = object.quaternion.toArray();\n\t\t\tconst position = object.position.toArray();\n\t\t\tconst scale = object.scale.toArray();\n\n\t\t\tif ( ! equalArray( rotation, [ 0, 0, 0, 1 ] ) ) {\n\n\t\t\t\tnodeDef.rotation = rotation;\n\n\t\t\t}\n\n\t\t\tif ( ! equalArray( position, [ 0, 0, 0 ] ) ) {\n\n\t\t\t\tnodeDef.translation = position;\n\n\t\t\t}\n\n\t\t\tif ( ! equalArray( scale, [ 1, 1, 1 ] ) ) {\n\n\t\t\t\tnodeDef.scale = scale;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( object.matrixAutoUpdate ) {\n\n\t\t\t\tobject.updateMatrix();\n\n\t\t\t}\n\n\t\t\tif ( isIdentityMatrix( object.matrix ) === false ) {\n\n\t\t\t\tnodeDef.matrix = object.matrix.elements;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// We don't export empty strings name because it represents no-name in Three.js.\n\t\tif ( object.name !== '' ) nodeDef.name = String( object.name );\n\n\t\tthis.serializeUserData( object, nodeDef );\n\n\t\tif ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\tconst meshIndex = this.processMesh( object );\n\n\t\t\tif ( meshIndex !== null ) nodeDef.mesh = meshIndex;\n\n\t\t} else if ( object.isCamera ) {\n\n\t\t\tnodeDef.camera = this.processCamera( object );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) this.skins.push( object );\n\n\t\tif ( object.children.length > 0 ) {\n\n\t\t\tconst children = [];\n\n\t\t\tfor ( let i = 0, l = object.children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = object.children[ i ];\n\n\t\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\t\tconst nodeIndex = this.processNode( child );\n\n\t\t\t\t\tif ( nodeIndex !== null ) children.push( nodeIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( children.length > 0 ) nodeDef.children = children;\n\n\t\t}\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.writeNode && ext.writeNode( object, nodeDef );\n\n\t\t} );\n\n\t\tconst nodeIndex = json.nodes.push( nodeDef ) - 1;\n\t\tnodeMap.set( object, nodeIndex );\n\t\treturn nodeIndex;\n\n\t}\n\n\t/**\n\t * Process Scene\n\t * @param  {Scene} node Scene to process\n\t */\n\tprocessScene( scene ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\n\t\tif ( ! json.scenes ) {\n\n\t\t\tjson.scenes = [];\n\t\t\tjson.scene = 0;\n\n\t\t}\n\n\t\tconst sceneDef = {};\n\n\t\tif ( scene.name !== '' ) sceneDef.name = scene.name;\n\n\t\tjson.scenes.push( sceneDef );\n\n\t\tconst nodes = [];\n\n\t\tfor ( let i = 0, l = scene.children.length; i < l; i ++ ) {\n\n\t\t\tconst child = scene.children[ i ];\n\n\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\tconst nodeIndex = this.processNode( child );\n\n\t\t\t\tif ( nodeIndex !== null ) nodes.push( nodeIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( nodes.length > 0 ) sceneDef.nodes = nodes;\n\n\t\tthis.serializeUserData( scene, sceneDef );\n\n\t}\n\n\t/**\n\t * Creates a Scene to hold a list of objects and parse it\n\t * @param  {Array} objects List of objects to process\n\t */\n\tprocessObjects( objects ) {\n\n\t\tconst scene = new Scene();\n\t\tscene.name = 'AuxScene';\n\n\t\tfor ( let i = 0; i < objects.length; i ++ ) {\n\n\t\t\t// We push directly to children instead of calling `add` to prevent\n\t\t\t// modify the .parent and break its original scene and hierarchy\n\t\t\tscene.children.push( objects[ i ] );\n\n\t\t}\n\n\t\tthis.processScene( scene );\n\n\t}\n\n\t/**\n\t * @param {THREE.Object3D|Array<THREE.Object3D>} input\n\t */\n\tprocessInput( input ) {\n\n\t\tconst options = this.options;\n\n\t\tinput = input instanceof Array ? input : [ input ];\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.beforeParse && ext.beforeParse( input );\n\n\t\t} );\n\n\t\tconst objectsWithoutScene = [];\n\n\t\tfor ( let i = 0; i < input.length; i ++ ) {\n\n\t\t\tif ( input[ i ] instanceof Scene ) {\n\n\t\t\t\tthis.processScene( input[ i ] );\n\n\t\t\t} else {\n\n\t\t\t\tobjectsWithoutScene.push( input[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( objectsWithoutScene.length > 0 ) this.processObjects( objectsWithoutScene );\n\n\t\tfor ( let i = 0; i < this.skins.length; ++ i ) {\n\n\t\t\tthis.processSkin( this.skins[ i ] );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < options.animations.length; ++ i ) {\n\n\t\t\tthis.processAnimation( options.animations[ i ], input[ 0 ] );\n\n\t\t}\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.afterParse && ext.afterParse( input );\n\n\t\t} );\n\n\t}\n\n\t_invokeAll( func ) {\n\n\t\tfor ( let i = 0, il = this.plugins.length; i < il; i ++ ) {\n\n\t\t\tfunc( this.plugins[ i ] );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_lights_punctual';\n\n\t}\n\n\twriteNode( light, nodeDef ) {\n\n\t\tif ( ! light.isLight ) return;\n\n\t\tif ( ! light.isDirectionalLight && ! light.isPointLight && ! light.isSpotLight ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst writer = this.writer;\n\t\tconst json = writer.json;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst lightDef = {};\n\n\t\tif ( light.name ) lightDef.name = light.name;\n\n\t\tlightDef.color = light.color.toArray();\n\n\t\tlightDef.intensity = light.intensity;\n\n\t\tif ( light.isDirectionalLight ) {\n\n\t\t\tlightDef.type = 'directional';\n\n\t\t} else if ( light.isPointLight ) {\n\n\t\t\tlightDef.type = 'point';\n\n\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\n\t\t} else if ( light.isSpotLight ) {\n\n\t\t\tlightDef.type = 'spot';\n\n\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\n\t\t\tlightDef.spot = {};\n\t\t\tlightDef.spot.innerConeAngle = ( light.penumbra - 1.0 ) * light.angle * - 1.0;\n\t\t\tlightDef.spot.outerConeAngle = light.angle;\n\n\t\t}\n\n\t\tif ( light.decay !== undefined && light.decay !== 2 ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, '\n\t\t\t\t+ 'and expects light.decay=2.' );\n\n\t\t}\n\n\t\tif ( light.target\n\t\t\t\t&& ( light.target.parent !== light\n\t\t\t\t|| light.target.position.x !== 0\n\t\t\t\t|| light.target.position.y !== 0\n\t\t\t\t|| light.target.position.z !== - 1 ) ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Light direction may be lost. For best results, '\n\t\t\t\t+ 'make light.target a child of the light with position 0,0,-1.' );\n\n\t\t}\n\n\t\tif ( ! extensionsUsed[ this.name ] ) {\n\n\t\t\tjson.extensions = json.extensions || {};\n\t\t\tjson.extensions[ this.name ] = { lights: [] };\n\t\t\textensionsUsed[ this.name ] = true;\n\n\t\t}\n\n\t\tconst lights = json.extensions[ this.name ].lights;\n\t\tlights.push( lightDef );\n\n\t\tnodeDef.extensions = nodeDef.extensions || {};\n\t\tnodeDef.extensions[ this.name ] = { light: lights.length - 1 };\n\n\t}\n\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_unlit';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshBasicMaterial ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = {};\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n\n\t}\n\n}\n\n/**\n * Specular-Glossiness Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness\n */\nclass GLTFMaterialsPBRSpecularGlossiness {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_pbrSpecularGlossiness';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isGLTFSpecularGlossinessMaterial ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( materialDef.pbrMetallicRoughness.baseColorFactor ) {\n\n\t\t\textensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;\n\n\t\t}\n\n\t\tconst specularFactor = [ 1, 1, 1 ];\n\t\tmaterial.specular.toArray( specularFactor, 0 );\n\t\textensionDef.specularFactor = specularFactor;\n\t\textensionDef.glossinessFactor = material.glossiness;\n\n\t\tif ( materialDef.pbrMetallicRoughness.baseColorTexture ) {\n\n\t\t\textensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;\n\n\t\t}\n\n\t\tif ( material.specularMap ) {\n\n\t\t\tconst specularMapDef = { index: writer.processTexture( material.specularMap ) };\n\t\t\twriter.applyTextureTransform( specularMapDef, material.specularMap );\n\t\t\textensionDef.specularGlossinessTexture = specularMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_clearcoat';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.clearcoatFactor = material.clearcoat;\n\n\t\tif ( material.clearcoatMap ) {\n\n\t\t\tconst clearcoatMapDef = { index: writer.processTexture( material.clearcoatMap ) };\n\t\t\twriter.applyTextureTransform( clearcoatMapDef, material.clearcoatMap );\n\t\t\textensionDef.clearcoatTexture = clearcoatMapDef;\n\n\t\t}\n\n\t\textensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;\n\n\t\tif ( material.clearcoatRoughnessMap ) {\n\n\t\t\tconst clearcoatRoughnessMapDef = { index: writer.processTexture( material.clearcoatRoughnessMap ) };\n\t\t\twriter.applyTextureTransform( clearcoatRoughnessMapDef, material.clearcoatRoughnessMap );\n\t\t\textensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;\n\n\t\t}\n\n\t\tif ( material.clearcoatNormalMap ) {\n\n\t\t\tconst clearcoatNormalMapDef = { index: writer.processTexture( material.clearcoatNormalMap ) };\n\t\t\twriter.applyTextureTransform( clearcoatNormalMapDef, material.clearcoatNormalMap );\n\t\t\textensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\n\t}\n\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_iridescence';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.iridescenceFactor = material.iridescence;\n\n\t\tif ( material.iridescenceMap ) {\n\n\t\t\tconst iridescenceMapDef = { index: writer.processTexture( material.iridescenceMap ) };\n\t\t\twriter.applyTextureTransform( iridescenceMapDef, material.iridescenceMap );\n\t\t\textensionDef.iridescenceTexture = iridescenceMapDef;\n\n\t\t}\n\n\t\textensionDef.iridescenceIor = material.iridescenceIOR;\n\t\textensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[ 0 ];\n\t\textensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[ 1 ];\n\n\t\tif ( material.iridescenceThicknessMap ) {\n\n\t\t\tconst iridescenceThicknessMapDef = { index: writer.processTexture( material.iridescenceThicknessMap ) };\n\t\t\twriter.applyTextureTransform( iridescenceThicknessMapDef, material.iridescenceThicknessMap );\n\t\t\textensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n */\nclass GLTFMaterialsTransmissionExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_transmission';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.transmissionFactor = material.transmission;\n\n\t\tif ( material.transmissionMap ) {\n\n\t\t\tconst transmissionMapDef = { index: writer.processTexture( material.transmissionMap ) };\n\t\t\twriter.applyTextureTransform( transmissionMapDef, material.transmissionMap );\n\t\t\textensionDef.transmissionTexture = transmissionMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_volume';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.thicknessFactor = material.thickness;\n\n\t\tif ( material.thicknessMap ) {\n\n\t\t\tconst thicknessMapDef = { index: writer.processTexture( material.thicknessMap ) };\n\t\t\twriter.applyTextureTransform( thicknessMapDef, material.thicknessMap );\n\t\t\textensionDef.thicknessTexture = thicknessMapDef;\n\n\t\t}\n\n\t\textensionDef.attenuationDistance = material.attenuationDistance;\n\t\textensionDef.attenuationColor = material.attenuationColor.toArray();\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Static utility functions\n */\nGLTFExporter.Utils = {\n\n\tinsertKeyframe: function ( track, time ) {\n\n\t\tconst tolerance = 0.001; // 1ms\n\t\tconst valueSize = track.getValueSize();\n\n\t\tconst times = new track.TimeBufferType( track.times.length + 1 );\n\t\tconst values = new track.ValueBufferType( track.values.length + valueSize );\n\t\tconst interpolant = track.createInterpolant( new track.ValueBufferType( valueSize ) );\n\n\t\tlet index;\n\n\t\tif ( track.times.length === 0 ) {\n\n\t\t\ttimes[ 0 ] = time;\n\n\t\t\tfor ( let i = 0; i < valueSize; i ++ ) {\n\n\t\t\t\tvalues[ i ] = 0;\n\n\t\t\t}\n\n\t\t\tindex = 0;\n\n\t\t} else if ( time < track.times[ 0 ] ) {\n\n\t\t\tif ( Math.abs( track.times[ 0 ] - time ) < tolerance ) return 0;\n\n\t\t\ttimes[ 0 ] = time;\n\t\t\ttimes.set( track.times, 1 );\n\n\t\t\tvalues.set( interpolant.evaluate( time ), 0 );\n\t\t\tvalues.set( track.values, valueSize );\n\n\t\t\tindex = 0;\n\n\t\t} else if ( time > track.times[ track.times.length - 1 ] ) {\n\n\t\t\tif ( Math.abs( track.times[ track.times.length - 1 ] - time ) < tolerance ) {\n\n\t\t\t\treturn track.times.length - 1;\n\n\t\t\t}\n\n\t\t\ttimes[ times.length - 1 ] = time;\n\t\t\ttimes.set( track.times, 0 );\n\n\t\t\tvalues.set( track.values, 0 );\n\t\t\tvalues.set( interpolant.evaluate( time ), track.values.length );\n\n\t\t\tindex = times.length - 1;\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < track.times.length; i ++ ) {\n\n\t\t\t\tif ( Math.abs( track.times[ i ] - time ) < tolerance ) return i;\n\n\t\t\t\tif ( track.times[ i ] < time && track.times[ i + 1 ] > time ) {\n\n\t\t\t\t\ttimes.set( track.times.slice( 0, i + 1 ), 0 );\n\t\t\t\t\ttimes[ i + 1 ] = time;\n\t\t\t\t\ttimes.set( track.times.slice( i + 1 ), i + 2 );\n\n\t\t\t\t\tvalues.set( track.values.slice( 0, ( i + 1 ) * valueSize ), 0 );\n\t\t\t\t\tvalues.set( interpolant.evaluate( time ), ( i + 1 ) * valueSize );\n\t\t\t\t\tvalues.set( track.values.slice( ( i + 1 ) * valueSize ), ( i + 2 ) * valueSize );\n\n\t\t\t\t\tindex = i + 1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\ttrack.times = times;\n\t\ttrack.values = values;\n\n\t\treturn index;\n\n\t},\n\n\tmergeMorphTargetTracks: function ( clip, root ) {\n\n\t\tconst tracks = [];\n\t\tconst mergedTracks = {};\n\t\tconst sourceTracks = clip.tracks;\n\n\t\tfor ( let i = 0; i < sourceTracks.length; ++ i ) {\n\n\t\t\tlet sourceTrack = sourceTracks[ i ];\n\t\t\tconst sourceTrackBinding = PropertyBinding.parseTrackName( sourceTrack.name );\n\t\t\tconst sourceTrackNode = PropertyBinding.findNode( root, sourceTrackBinding.nodeName );\n\n\t\t\tif ( sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined ) {\n\n\t\t\t\t// Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n\t\t\t\ttracks.push( sourceTrack );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete\n\t\t\t\t&& sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear ) {\n\n\t\t\t\tif ( sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\t\t\t// This should never happen, because glTF morph target animations\n\t\t\t\t\t// affect all targets already.\n\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.' );\n\n\t\t\t\t}\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.' );\n\n\t\t\t\tsourceTrack = sourceTrack.clone();\n\t\t\t\tsourceTrack.setInterpolation( InterpolateLinear );\n\n\t\t\t}\n\n\t\t\tconst targetCount = sourceTrackNode.morphTargetInfluences.length;\n\t\t\tconst targetIndex = sourceTrackNode.morphTargetDictionary[ sourceTrackBinding.propertyIndex ];\n\n\t\t\tif ( targetIndex === undefined ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex );\n\n\t\t\t}\n\n\t\t\tlet mergedTrack;\n\n\t\t\t// If this is the first time we've seen this object, create a new\n\t\t\t// track to store merged keyframe data for each morph target.\n\t\t\tif ( mergedTracks[ sourceTrackNode.uuid ] === undefined ) {\n\n\t\t\t\tmergedTrack = sourceTrack.clone();\n\n\t\t\t\tconst values = new mergedTrack.ValueBufferType( targetCount * mergedTrack.times.length );\n\n\t\t\t\tfor ( let j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\t\tvalues[ j * targetCount + targetIndex ] = mergedTrack.values[ j ];\n\n\t\t\t\t}\n\n\t\t\t\t// We need to take into consideration the intended target node\n\t\t\t\t// of our original un-merged morphTarget animation.\n\t\t\t\tmergedTrack.name = ( sourceTrackBinding.nodeName || '' ) + '.morphTargetInfluences';\n\t\t\t\tmergedTrack.values = values;\n\n\t\t\t\tmergedTracks[ sourceTrackNode.uuid ] = mergedTrack;\n\t\t\t\ttracks.push( mergedTrack );\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst sourceInterpolant = sourceTrack.createInterpolant( new sourceTrack.ValueBufferType( 1 ) );\n\n\t\t\tmergedTrack = mergedTracks[ sourceTrackNode.uuid ];\n\n\t\t\t// For every existing keyframe of the merged track, write a (possibly\n\t\t\t// interpolated) value from the source track.\n\t\t\tfor ( let j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\tmergedTrack.values[ j * targetCount + targetIndex ] = sourceInterpolant.evaluate( mergedTrack.times[ j ] );\n\n\t\t\t}\n\n\t\t\t// For every existing keyframe of the source track, write a (possibly\n\t\t\t// new) keyframe to the merged track. Values from the previous loop may\n\t\t\t// be written again, but keyframes are de-duplicated.\n\t\t\tfor ( let j = 0; j < sourceTrack.times.length; j ++ ) {\n\n\t\t\t\tconst keyframeIndex = this.insertKeyframe( mergedTrack, sourceTrack.times[ j ] );\n\t\t\t\tmergedTrack.values[ keyframeIndex * targetCount + targetIndex ] = sourceTrack.values[ j ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tclip.tracks = tracks;\n\n\t\treturn clip;\n\n\t}\n\n};\n\nexport { GLTFExporter };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}