{"ast":null,"code":"/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a;\nimport { Color, DoubleSide, FrontSide } from 'three';\nimport { PBRMetallicRoughness } from './pbr-metallic-roughness.js';\nimport { TextureInfo, TextureUsage } from './texture-info.js';\nimport { $correlatedObjects, $onUpdate, $sourceObject, ThreeDOMElement } from './three-dom-element.js';\nconst $pbrMetallicRoughness = Symbol('pbrMetallicRoughness');\nconst $normalTexture = Symbol('normalTexture');\nconst $occlusionTexture = Symbol('occlusionTexture');\nconst $emissiveTexture = Symbol('emissiveTexture');\nconst $backingThreeMaterial = Symbol('backingThreeMaterial');\nconst $applyAlphaCutoff = Symbol('applyAlphaCutoff');\nexport const $lazyLoadGLTFInfo = Symbol('lazyLoadGLTFInfo');\nconst $initialize = Symbol('initialize');\nexport const $getLoadedMaterial = Symbol('getLoadedMaterial');\nexport const $ensureMaterialIsLoaded = Symbol('ensureMaterialIsLoaded');\nexport const $gltfIndex = Symbol('gltfIndex');\nexport const $setActive = Symbol('setActive');\nexport const $variantIndices = Symbol('variantIndices');\nconst $isActive = Symbol('isActive');\nexport const $variantSet = Symbol('variantSet');\nconst $modelVariants = Symbol('modelVariants');\n/**\n * Material facade implementation for Three.js materials\n */\nexport class Material extends ThreeDOMElement {\n  constructor(onUpdate, gltf, gltfMaterial, gltfIndex, isActive, modelVariants, correlatedMaterials, lazyLoadInfo = undefined) {\n    super(onUpdate, gltfMaterial, correlatedMaterials);\n    this[_a] = new Set();\n    this[$gltfIndex] = gltfIndex;\n    this[$isActive] = isActive;\n    this[$modelVariants] = modelVariants;\n    if (lazyLoadInfo == null) {\n      this[$initialize](gltf);\n    } else {\n      this[$lazyLoadGLTFInfo] = lazyLoadInfo;\n    }\n  }\n  get [(_a = $variantSet, $backingThreeMaterial)]() {\n    return this[$correlatedObjects].values().next().value;\n  }\n  [$initialize](gltf) {\n    const onUpdate = this[$onUpdate];\n    const gltfMaterial = this[$sourceObject];\n    const correlatedMaterials = this[$correlatedObjects];\n    if (gltfMaterial.extensions && gltfMaterial.extensions['KHR_materials_pbrSpecularGlossiness']) {\n      console.warn(`Material ${gltfMaterial.name} uses a deprecated extension\n          \"KHR_materials_pbrSpecularGlossiness\", please use\n          \"pbrMetallicRoughness\" instead. Specular Glossiness materials are\n          currently supported for rendering, but not for our scene-graph API,\n          nor for auto-generation of USDZ for Quick Look.`);\n    }\n    if (gltfMaterial.pbrMetallicRoughness == null) {\n      gltfMaterial.pbrMetallicRoughness = {};\n    }\n    this[$pbrMetallicRoughness] = new PBRMetallicRoughness(onUpdate, gltf, gltfMaterial.pbrMetallicRoughness, correlatedMaterials);\n    if (gltfMaterial.emissiveFactor == null) {\n      gltfMaterial.emissiveFactor = [0, 0, 0];\n    }\n    if (gltfMaterial.doubleSided == null) {\n      gltfMaterial.doubleSided = false;\n    }\n    if (gltfMaterial.alphaMode == null) {\n      gltfMaterial.alphaMode = 'OPAQUE';\n    }\n    if (gltfMaterial.alphaCutoff == null) {\n      gltfMaterial.alphaCutoff = 0.5;\n    }\n    const {\n      normalTexture: gltfNormalTexture,\n      occlusionTexture: gltfOcclusionTexture,\n      emissiveTexture: gltfEmissiveTexture\n    } = gltfMaterial;\n    const {\n      normalMap,\n      aoMap,\n      emissiveMap\n    } = correlatedMaterials.values().next().value;\n    this[$normalTexture] = new TextureInfo(onUpdate, TextureUsage.Normal, normalMap, correlatedMaterials, gltf, gltfNormalTexture ? gltfNormalTexture : null);\n    this[$occlusionTexture] = new TextureInfo(onUpdate, TextureUsage.Occlusion, aoMap, correlatedMaterials, gltf, gltfOcclusionTexture ? gltfOcclusionTexture : null);\n    this[$emissiveTexture] = new TextureInfo(onUpdate, TextureUsage.Emissive, emissiveMap, correlatedMaterials, gltf, gltfEmissiveTexture ? gltfEmissiveTexture : null);\n  }\n  async [$getLoadedMaterial]() {\n    if (this[$lazyLoadGLTFInfo] != null) {\n      const {\n        set,\n        material\n      } = await this[$lazyLoadGLTFInfo].doLazyLoad();\n      // Fills in the missing data.\n      this[$correlatedObjects] = set;\n      this[$initialize](this[$lazyLoadGLTFInfo].gltf);\n      // Releases lazy load info.\n      this[$lazyLoadGLTFInfo] = undefined;\n      // Redefines the method as a noop method.\n      this.ensureLoaded = async () => {};\n      return material;\n    }\n    return this[$correlatedObjects].values().next().value;\n  }\n  [$ensureMaterialIsLoaded]() {\n    if (this[$lazyLoadGLTFInfo] == null) {\n      return;\n    }\n    throw new Error(`Material \"${this.name}\" has not been loaded, call 'await\n    myMaterial.ensureLoaded()' before using an unloaded material.`);\n  }\n  async ensureLoaded() {\n    await this[$getLoadedMaterial]();\n  }\n  get isLoaded() {\n    return this[$lazyLoadGLTFInfo] == null;\n  }\n  get isActive() {\n    return this[$isActive];\n  }\n  [$setActive](isActive) {\n    this[$isActive] = isActive;\n  }\n  get name() {\n    return this[$sourceObject].name;\n  }\n  set name(name) {\n    const sourceMaterial = this[$sourceObject];\n    if (sourceMaterial != null) {\n      sourceMaterial.name = name;\n    }\n    if (this[$correlatedObjects] != null) {\n      for (const threeMaterial of this[$correlatedObjects]) {\n        threeMaterial.name = name;\n      }\n    }\n  }\n  get pbrMetallicRoughness() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrMetallicRoughness];\n  }\n  get normalTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$normalTexture];\n  }\n  get occlusionTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$occlusionTexture];\n  }\n  get emissiveTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$emissiveTexture];\n  }\n  get emissiveFactor() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$sourceObject].emissiveFactor;\n  }\n  get index() {\n    return this[$gltfIndex];\n  }\n  [$variantIndices]() {\n    return this[$variantSet];\n  }\n  hasVariant(name) {\n    const variantData = this[$modelVariants].get(name);\n    return variantData != null && this[$variantSet].has(variantData.index);\n  }\n  setEmissiveFactor(rgb) {\n    this[$ensureMaterialIsLoaded]();\n    const color = new Color();\n    if (rgb instanceof Array) {\n      color.fromArray(rgb);\n    } else {\n      color.set(rgb).convertSRGBToLinear();\n    }\n    for (const material of this[$correlatedObjects]) {\n      material.emissive.set(color);\n    }\n    this[$sourceObject].emissiveFactor = color.toArray();\n    this[$onUpdate]();\n  }\n  [$applyAlphaCutoff]() {\n    this[$ensureMaterialIsLoaded]();\n    const gltfMaterial = this[$sourceObject];\n    for (const material of this[$correlatedObjects]) {\n      if (this[$sourceObject].alphaMode === 'MASK') {\n        material.alphaTest = gltfMaterial.alphaCutoff;\n      } else {\n        material.alphaTest = undefined;\n      }\n      material.needsUpdate = true;\n    }\n  }\n  setAlphaCutoff(cutoff) {\n    this[$ensureMaterialIsLoaded]();\n    this[$sourceObject].alphaCutoff = cutoff;\n    this[$applyAlphaCutoff]();\n    this[$onUpdate]();\n  }\n  getAlphaCutoff() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$sourceObject].alphaCutoff;\n  }\n  setDoubleSided(doubleSided) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      // When double-sided is disabled gltf spec dictates that Back-Face culling\n      // must be disabled, in three.js parlance that would mean FrontSide\n      // rendering only.\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#double-sided\n      material.side = doubleSided ? DoubleSide : FrontSide;\n      material.needsUpdate = true;\n    }\n    this[$sourceObject].doubleSided = doubleSided;\n    this[$onUpdate]();\n  }\n  getDoubleSided() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$sourceObject].doubleSided;\n  }\n  setAlphaMode(alphaMode) {\n    this[$ensureMaterialIsLoaded]();\n    const enableTransparency = (material, enabled) => {\n      material.transparent = enabled;\n      material.depthWrite = !enabled;\n    };\n    this[$sourceObject].alphaMode = alphaMode;\n    for (const material of this[$correlatedObjects]) {\n      enableTransparency(material, alphaMode === 'BLEND');\n      this[$applyAlphaCutoff]();\n      material.needsUpdate = true;\n    }\n    this[$onUpdate]();\n  }\n  getAlphaMode() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$sourceObject].alphaMode;\n  }\n}","map":{"version":3,"names":["Color","DoubleSide","FrontSide","PBRMetallicRoughness","TextureInfo","TextureUsage","$correlatedObjects","$onUpdate","$sourceObject","ThreeDOMElement","$pbrMetallicRoughness","Symbol","$normalTexture","$occlusionTexture","$emissiveTexture","$backingThreeMaterial","$applyAlphaCutoff","$lazyLoadGLTFInfo","$initialize","$getLoadedMaterial","$ensureMaterialIsLoaded","$gltfIndex","$setActive","$variantIndices","$isActive","$variantSet","$modelVariants","Material","constructor","onUpdate","gltf","gltfMaterial","gltfIndex","isActive","modelVariants","correlatedMaterials","lazyLoadInfo","undefined","_a","Set","values","next","value","extensions","console","warn","name","pbrMetallicRoughness","emissiveFactor","doubleSided","alphaMode","alphaCutoff","normalTexture","gltfNormalTexture","occlusionTexture","gltfOcclusionTexture","emissiveTexture","gltfEmissiveTexture","normalMap","aoMap","emissiveMap","Normal","Occlusion","Emissive","set","material","doLazyLoad","ensureLoaded","Error","isLoaded","sourceMaterial","threeMaterial","index","hasVariant","variantData","get","has","setEmissiveFactor","rgb","color","Array","fromArray","convertSRGBToLinear","emissive","toArray","alphaTest","needsUpdate","setAlphaCutoff","cutoff","getAlphaCutoff","setDoubleSided","side","getDoubleSided","setAlphaMode","enableTransparency","enabled","transparent","depthWrite","getAlphaMode"],"sources":["C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\@google\\model-viewer\\src\\features\\scene-graph\\material.ts"],"sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Color, DoubleSide, FrontSide, MeshStandardMaterial} from 'three';\n\nimport {AlphaMode, GLTF, Material as GLTFMaterial, RGB} from '../../three-components/gltf-instance/gltf-2.0.js';\nimport {Material as DefaultedMaterial} from '../../three-components/gltf-instance/gltf-defaulted.js';\n\nimport {Material as MaterialInterface} from './api.js';\nimport {LazyLoader, VariantData} from './model.js';\nimport {PBRMetallicRoughness} from './pbr-metallic-roughness.js';\nimport {TextureInfo, TextureUsage} from './texture-info.js';\nimport {$correlatedObjects, $onUpdate, $sourceObject, ThreeDOMElement} from './three-dom-element.js';\n\n\n\nconst $pbrMetallicRoughness = Symbol('pbrMetallicRoughness');\nconst $normalTexture = Symbol('normalTexture');\nconst $occlusionTexture = Symbol('occlusionTexture');\nconst $emissiveTexture = Symbol('emissiveTexture');\nconst $backingThreeMaterial = Symbol('backingThreeMaterial');\nconst $applyAlphaCutoff = Symbol('applyAlphaCutoff');\nexport const $lazyLoadGLTFInfo = Symbol('lazyLoadGLTFInfo');\nconst $initialize = Symbol('initialize');\nexport const $getLoadedMaterial = Symbol('getLoadedMaterial');\nexport const $ensureMaterialIsLoaded = Symbol('ensureMaterialIsLoaded');\nexport const $gltfIndex = Symbol('gltfIndex');\nexport const $setActive = Symbol('setActive');\nexport const $variantIndices = Symbol('variantIndices');\nconst $isActive = Symbol('isActive');\nexport const $variantSet = Symbol('variantSet');\nconst $modelVariants = Symbol('modelVariants');\n\n/**\n * Material facade implementation for Three.js materials\n */\nexport class Material extends ThreeDOMElement implements MaterialInterface {\n  private[$pbrMetallicRoughness]!: PBRMetallicRoughness;\n  private[$normalTexture]!: TextureInfo;\n  private[$occlusionTexture]!: TextureInfo;\n  private[$emissiveTexture]!: TextureInfo;\n  private[$lazyLoadGLTFInfo]?: LazyLoader;\n  private[$gltfIndex]: number;\n  private[$isActive]: boolean;\n  private[$variantSet] = new Set<number>();\n  readonly[$modelVariants]: Map<string, VariantData>;\n\n  get[$backingThreeMaterial](): MeshStandardMaterial {\n    return (this[$correlatedObjects] as Set<MeshStandardMaterial>)\n        .values()\n        .next()\n        .value;\n  }\n\n  constructor(\n      onUpdate: () => void, gltf: GLTF, gltfMaterial: GLTFMaterial,\n      gltfIndex: number, isActive: boolean,\n      modelVariants: Map<string, VariantData>,\n      correlatedMaterials: Set<MeshStandardMaterial>,\n      lazyLoadInfo: LazyLoader|undefined = undefined) {\n    super(onUpdate, gltfMaterial, correlatedMaterials);\n    this[$gltfIndex] = gltfIndex;\n    this[$isActive] = isActive;\n    this[$modelVariants] = modelVariants;\n\n    if (lazyLoadInfo == null) {\n      this[$initialize](gltf);\n    } else {\n      this[$lazyLoadGLTFInfo] = lazyLoadInfo;\n    }\n  }\n\n  private[$initialize](gltf: GLTF): void {\n    const onUpdate = this[$onUpdate] as () => void;\n    const gltfMaterial = this[$sourceObject] as GLTFMaterial;\n    const correlatedMaterials =\n        this[$correlatedObjects] as Set<MeshStandardMaterial>;\n\n    if (gltfMaterial.extensions &&\n        gltfMaterial.extensions['KHR_materials_pbrSpecularGlossiness']) {\n      console.warn(`Material ${gltfMaterial.name} uses a deprecated extension\n          \"KHR_materials_pbrSpecularGlossiness\", please use\n          \"pbrMetallicRoughness\" instead. Specular Glossiness materials are\n          currently supported for rendering, but not for our scene-graph API,\n          nor for auto-generation of USDZ for Quick Look.`);\n    }\n\n    if (gltfMaterial.pbrMetallicRoughness == null) {\n      gltfMaterial.pbrMetallicRoughness = {};\n    }\n    this[$pbrMetallicRoughness] = new PBRMetallicRoughness(\n        onUpdate, gltf, gltfMaterial.pbrMetallicRoughness, correlatedMaterials);\n\n    if (gltfMaterial.emissiveFactor == null) {\n      gltfMaterial.emissiveFactor = [0, 0, 0];\n    }\n\n    if (gltfMaterial.doubleSided == null) {\n      gltfMaterial.doubleSided = false;\n    }\n\n    if (gltfMaterial.alphaMode == null) {\n      gltfMaterial.alphaMode = 'OPAQUE';\n    }\n\n    if (gltfMaterial.alphaCutoff == null) {\n      gltfMaterial.alphaCutoff = 0.5;\n    }\n\n    const {\n      normalTexture: gltfNormalTexture,\n      occlusionTexture: gltfOcclusionTexture,\n      emissiveTexture: gltfEmissiveTexture\n    } = gltfMaterial;\n\n    const {normalMap, aoMap, emissiveMap} =\n        correlatedMaterials.values().next().value;\n\n    this[$normalTexture] = new TextureInfo(\n        onUpdate,\n        TextureUsage.Normal,\n        normalMap,\n        correlatedMaterials,\n        gltf,\n        gltfNormalTexture ? gltfNormalTexture : null,\n    );\n\n    this[$occlusionTexture] = new TextureInfo(\n        onUpdate,\n        TextureUsage.Occlusion,\n        aoMap,\n        correlatedMaterials,\n        gltf,\n        gltfOcclusionTexture ? gltfOcclusionTexture : null,\n    );\n\n    this[$emissiveTexture] = new TextureInfo(\n        onUpdate,\n        TextureUsage.Emissive,\n        emissiveMap,\n        correlatedMaterials,\n        gltf,\n        gltfEmissiveTexture ? gltfEmissiveTexture : null,\n    );\n  }\n\n  async[$getLoadedMaterial](): Promise<MeshStandardMaterial> {\n    if (this[$lazyLoadGLTFInfo] != null) {\n      const {set, material} = await this[$lazyLoadGLTFInfo]!.doLazyLoad();\n\n      // Fills in the missing data.\n      this[$correlatedObjects] = set as Set<MeshStandardMaterial>;\n\n      this[$initialize](this[$lazyLoadGLTFInfo]!.gltf);\n      // Releases lazy load info.\n      this[$lazyLoadGLTFInfo] = undefined;\n      // Redefines the method as a noop method.\n      this.ensureLoaded = async () => {};\n      return material as MeshStandardMaterial;\n    }\n    return this[$correlatedObjects]!.values().next().value;\n  }\n\n  [$ensureMaterialIsLoaded]() {\n    if (this[$lazyLoadGLTFInfo] == null) {\n      return;\n    }\n    throw new Error(`Material \"${this.name}\" has not been loaded, call 'await\n    myMaterial.ensureLoaded()' before using an unloaded material.`);\n  }\n\n  async ensureLoaded() {\n    await this[$getLoadedMaterial]();\n  }\n\n  get isLoaded() {\n    return this[$lazyLoadGLTFInfo] == null;\n  }\n\n  get isActive(): boolean {\n    return this[$isActive];\n  }\n\n  [$setActive](isActive: boolean) {\n    this[$isActive] = isActive;\n  }\n\n  get name(): string {\n    return (this[$sourceObject] as Material).name;\n  }\n\n  set name(name: string) {\n    const sourceMaterial = (this[$sourceObject] as Material);\n    if (sourceMaterial != null) {\n      sourceMaterial.name = name;\n    }\n\n    if (this[$correlatedObjects] != null) {\n      for (const threeMaterial of this[$correlatedObjects]!) {\n        threeMaterial.name = name;\n      }\n    }\n  }\n\n  get pbrMetallicRoughness(): PBRMetallicRoughness {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrMetallicRoughness];\n  }\n\n  get normalTexture(): TextureInfo {\n    this[$ensureMaterialIsLoaded]();\n    return this[$normalTexture];\n  }\n\n  get occlusionTexture(): TextureInfo {\n    this[$ensureMaterialIsLoaded]();\n    return this[$occlusionTexture];\n  }\n\n  get emissiveTexture(): TextureInfo {\n    this[$ensureMaterialIsLoaded]();\n    return this[$emissiveTexture];\n  }\n\n  get emissiveFactor(): RGB {\n    this[$ensureMaterialIsLoaded]();\n    return (this[$sourceObject] as DefaultedMaterial).emissiveFactor;\n  }\n\n  get index(): number {\n    return this[$gltfIndex];\n  }\n\n  [$variantIndices]() {\n    return this[$variantSet];\n  }\n\n  hasVariant(name: string): boolean {\n    const variantData = this[$modelVariants].get(name);\n    return variantData != null && this[$variantSet].has(variantData.index);\n  }\n\n  setEmissiveFactor(rgb: RGB|string) {\n    this[$ensureMaterialIsLoaded]();\n    const color = new Color();\n    if (rgb instanceof Array) {\n      color.fromArray(rgb);\n    } else {\n      color.set(rgb).convertSRGBToLinear();\n    }\n    for (const material of this[$correlatedObjects] as\n         Set<MeshStandardMaterial>) {\n      material.emissive.set(color);\n    }\n    (this[$sourceObject] as DefaultedMaterial).emissiveFactor =\n        color.toArray() as [number, number, number];\n    this[$onUpdate]();\n  }\n\n  [$applyAlphaCutoff]() {\n    this[$ensureMaterialIsLoaded]();\n    const gltfMaterial = this[$sourceObject] as DefaultedMaterial;\n    for (const material of this[$correlatedObjects] as\n         Set<MeshStandardMaterial>) {\n      if ((this[$sourceObject] as DefaultedMaterial).alphaMode === 'MASK') {\n        material.alphaTest = gltfMaterial.alphaCutoff;\n      } else {\n        (material.alphaTest as number | undefined) = undefined;\n      }\n\n      material.needsUpdate = true;\n    }\n  }\n\n  setAlphaCutoff(cutoff: number): void {\n    this[$ensureMaterialIsLoaded]();\n    (this[$sourceObject] as DefaultedMaterial).alphaCutoff = cutoff;\n    this[$applyAlphaCutoff]();\n    this[$onUpdate]();\n  }\n\n  getAlphaCutoff(): number {\n    this[$ensureMaterialIsLoaded]();\n    return (this[$sourceObject] as DefaultedMaterial).alphaCutoff;\n  }\n\n  setDoubleSided(doubleSided: boolean): void {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects] as\n         Set<MeshStandardMaterial>) {\n      // When double-sided is disabled gltf spec dictates that Back-Face culling\n      // must be disabled, in three.js parlance that would mean FrontSide\n      // rendering only.\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#double-sided\n      material.side = doubleSided ? DoubleSide : FrontSide;\n      material.needsUpdate = true;\n    }\n    (this[$sourceObject] as DefaultedMaterial).doubleSided = doubleSided;\n    this[$onUpdate]();\n  }\n\n  getDoubleSided(): boolean {\n    this[$ensureMaterialIsLoaded]();\n    return (this[$sourceObject] as DefaultedMaterial).doubleSided;\n  }\n\n  setAlphaMode(alphaMode: AlphaMode): void {\n    this[$ensureMaterialIsLoaded]();\n    const enableTransparency =\n        (material: MeshStandardMaterial, enabled: boolean): void => {\n          material.transparent = enabled;\n          material.depthWrite = !enabled;\n        };\n\n    (this[$sourceObject] as DefaultedMaterial).alphaMode = alphaMode;\n\n    for (const material of this[$correlatedObjects] as\n         Set<MeshStandardMaterial>) {\n      enableTransparency(material, alphaMode === 'BLEND');\n      this[$applyAlphaCutoff]();\n      material.needsUpdate = true;\n    }\n\n    this[$onUpdate]();\n  }\n\n  getAlphaMode(): AlphaMode {\n    this[$ensureMaterialIsLoaded]();\n    return (this[$sourceObject] as DefaultedMaterial).alphaMode;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}