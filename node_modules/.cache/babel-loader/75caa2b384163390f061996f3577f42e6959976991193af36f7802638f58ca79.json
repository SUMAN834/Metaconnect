{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { BackSide, BoxGeometry, CubeCamera, EquirectangularReflectionMapping, EventDispatcher, HalfFloatType, LinearEncoding, Mesh, NoBlending, NoToneMapping, RGBAFormat, Scene, ShaderMaterial, sRGBEncoding, TextureLoader, Vector3, WebGLCubeRenderTarget } from 'three';\nimport { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';\nimport { deserializeUrl, timePasses } from '../utilities.js';\nimport EnvironmentScene from './EnvironmentScene.js';\nimport EnvironmentSceneAlt from './EnvironmentSceneAlt.js';\nconst GENERATED_SIGMA = 0.04;\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\nconst HDR_FILE_RE = /\\.hdr(\\.js)?$/;\nconst ldrLoader = new TextureLoader();\nconst hdrLoader = new RGBELoader();\nhdrLoader.setDataType(HalfFloatType);\nexport default class TextureUtils extends EventDispatcher {\n  constructor(threeRenderer) {\n    super();\n    this.threeRenderer = threeRenderer;\n    this.generatedEnvironmentMap = null;\n    this.generatedEnvironmentMapAlt = null;\n    this.skyboxCache = new Map();\n    this.blurMaterial = null;\n    this.blurScene = null;\n  }\n  async load(url, progressCallback = () => {}) {\n    try {\n      const isHDR = HDR_FILE_RE.test(url);\n      const loader = isHDR ? hdrLoader : ldrLoader;\n      const texture = await new Promise((resolve, reject) => loader.load(url, resolve, event => {\n        progressCallback(event.loaded / event.total * 0.9);\n      }, reject));\n      progressCallback(1.0);\n      texture.name = url;\n      texture.mapping = EquirectangularReflectionMapping;\n      if (!isHDR) {\n        texture.encoding = sRGBEncoding;\n      }\n      return texture;\n    } finally {\n      if (progressCallback) {\n        progressCallback(1);\n      }\n    }\n  }\n  /**\n   * Returns a { skybox, environmentMap } object with the targets/textures\n   * accordingly. `skybox` is a WebGLRenderCubeTarget, and `environmentMap`\n   * is a Texture from a WebGLRenderCubeTarget.\n   */\n  async generateEnvironmentMapAndSkybox(skyboxUrl = null, environmentMapUrl = null, progressCallback = () => {}) {\n    const useAltEnvironment = environmentMapUrl !== 'legacy';\n    if (environmentMapUrl === 'legacy' || environmentMapUrl === 'neutral') {\n      environmentMapUrl = null;\n    }\n    environmentMapUrl = deserializeUrl(environmentMapUrl);\n    let skyboxLoads = Promise.resolve(null);\n    let environmentMapLoads;\n    // If we have a skybox URL, attempt to load it as a cubemap\n    if (!!skyboxUrl) {\n      skyboxLoads = this.loadEquirectFromUrl(skyboxUrl, progressCallback);\n    }\n    if (!!environmentMapUrl) {\n      // We have an available environment map URL\n      environmentMapLoads = this.loadEquirectFromUrl(environmentMapUrl, progressCallback);\n    } else if (!!skyboxUrl) {\n      // Fallback to deriving the environment map from an available skybox\n      environmentMapLoads = this.loadEquirectFromUrl(skyboxUrl, progressCallback);\n    } else {\n      // Fallback to generating the environment map\n      environmentMapLoads = useAltEnvironment ? this.loadGeneratedEnvironmentMapAlt() : this.loadGeneratedEnvironmentMap();\n    }\n    const [environmentMap, skybox] = await Promise.all([environmentMapLoads, skyboxLoads]);\n    if (environmentMap == null) {\n      throw new Error('Failed to load environment map.');\n    }\n    return {\n      environmentMap,\n      skybox\n    };\n  }\n  /**\n   * Loads an equirect Texture from a given URL, for use as a skybox.\n   */\n  async loadEquirectFromUrl(url, progressCallback) {\n    if (!this.skyboxCache.has(url)) {\n      const skyboxMapLoads = this.load(url, progressCallback);\n      this.skyboxCache.set(url, skyboxMapLoads);\n    }\n    return this.skyboxCache.get(url);\n  }\n  async GenerateEnvironmentMap(scene, name) {\n    await timePasses();\n    const renderer = this.threeRenderer;\n    const cubeTarget = new WebGLCubeRenderTarget(256, {\n      generateMipmaps: false,\n      type: HalfFloatType,\n      format: RGBAFormat,\n      encoding: LinearEncoding,\n      depthBuffer: true\n    });\n    const cubeCamera = new CubeCamera(0.1, 100, cubeTarget);\n    const generatedEnvironmentMap = cubeCamera.renderTarget.texture;\n    generatedEnvironmentMap.name = name;\n    const outputEncoding = renderer.outputEncoding;\n    const toneMapping = renderer.toneMapping;\n    renderer.toneMapping = NoToneMapping;\n    renderer.outputEncoding = LinearEncoding;\n    cubeCamera.update(renderer, scene);\n    this.blurCubemap(cubeTarget, GENERATED_SIGMA);\n    renderer.toneMapping = toneMapping;\n    renderer.outputEncoding = outputEncoding;\n    return generatedEnvironmentMap;\n  }\n  /**\n   * Loads a dynamically generated environment map.\n   */\n  async loadGeneratedEnvironmentMap() {\n    if (this.generatedEnvironmentMap == null) {\n      this.generatedEnvironmentMap = this.GenerateEnvironmentMap(new EnvironmentScene(), 'legacy');\n    }\n    return this.generatedEnvironmentMap;\n  }\n  /**\n   * Loads a dynamically generated environment map, designed to be neutral and\n   * color-preserving. Shows less contrast around the different sides of the\n   * object.\n   */\n  async loadGeneratedEnvironmentMapAlt() {\n    if (this.generatedEnvironmentMapAlt == null) {\n      this.generatedEnvironmentMapAlt = this.GenerateEnvironmentMap(new EnvironmentSceneAlt(), 'neutral');\n    }\n    return this.generatedEnvironmentMapAlt;\n  }\n  blurCubemap(cubeTarget, sigma) {\n    if (this.blurMaterial == null) {\n      this.blurMaterial = this.getBlurShader(MAX_SAMPLES);\n      const box = new BoxGeometry();\n      const blurMesh = new Mesh(box, this.blurMaterial);\n      this.blurScene = new Scene();\n      this.blurScene.add(blurMesh);\n    }\n    const tempTarget = cubeTarget.clone();\n    this.halfblur(cubeTarget, tempTarget, sigma, 'latitudinal');\n    this.halfblur(tempTarget, cubeTarget, sigma, 'longitudinal');\n    // Disposing this target after we're done with it somehow corrupts Safari's\n    // whole graphics driver. It's random, but occurs more frequently on\n    // lower-powered GPUs (macbooks with intel graphics, older iPhones). It goes\n    // beyond just messing up the PMREM, as it also occasionally causes\n    // visible corruption on the canvas and even on the rest of the page.\n    /** tempTarget.dispose(); */\n  }\n\n  halfblur(targetIn, targetOut, sigmaRadians, direction) {\n    // Number of standard deviations at which to cut off the discrete\n    // approximation.\n    const STANDARD_DEVIATIONS = 3;\n    const pixels = targetIn.width;\n    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);\n    const sigmaPixels = sigmaRadians / radiansPerPixel;\n    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;\n    if (samples > MAX_SAMPLES) {\n      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);\n    }\n    const weights = [];\n    let sum = 0;\n    for (let i = 0; i < MAX_SAMPLES; ++i) {\n      const x = i / sigmaPixels;\n      const weight = Math.exp(-x * x / 2);\n      weights.push(weight);\n      if (i == 0) {\n        sum += weight;\n      } else if (i < samples) {\n        sum += 2 * weight;\n      }\n    }\n    for (let i = 0; i < weights.length; i++) {\n      weights[i] = weights[i] / sum;\n    }\n    const blurUniforms = this.blurMaterial.uniforms;\n    blurUniforms['envMap'].value = targetIn.texture;\n    blurUniforms['samples'].value = samples;\n    blurUniforms['weights'].value = weights;\n    blurUniforms['latitudinal'].value = direction === 'latitudinal';\n    blurUniforms['dTheta'].value = radiansPerPixel;\n    const cubeCamera = new CubeCamera(0.1, 100, targetOut);\n    cubeCamera.update(this.threeRenderer, this.blurScene);\n  }\n  getBlurShader(maxSamples) {\n    const weights = new Float32Array(maxSamples);\n    const poleAxis = new Vector3(0, 1, 0);\n    const shaderMaterial = new ShaderMaterial({\n      name: 'SphericalGaussianBlur',\n      defines: {\n        'n': maxSamples\n      },\n      uniforms: {\n        'envMap': {\n          value: null\n        },\n        'samples': {\n          value: 1\n        },\n        'weights': {\n          value: weights\n        },\n        'latitudinal': {\n          value: false\n        },\n        'dTheta': {\n          value: 0\n        },\n        'poleAxis': {\n          value: poleAxis\n        }\n      },\n      vertexShader: /* glsl */`\n      \n      varying vec3 vOutputDirection;\n  \n      void main() {\n  \n        vOutputDirection = vec3( position );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  \n      }\n    `,\n      fragmentShader: /* glsl */`\n        varying vec3 vOutputDirection;\n  \n        uniform samplerCube envMap;\n        uniform int samples;\n        uniform float weights[ n ];\n        uniform bool latitudinal;\n        uniform float dTheta;\n        uniform vec3 poleAxis;\n  \n        vec3 getSample( float theta, vec3 axis ) {\n  \n          float cosTheta = cos( theta );\n          // Rodrigues' axis-angle rotation\n          vec3 sampleDirection = vOutputDirection * cosTheta\n            + cross( axis, vOutputDirection ) * sin( theta )\n            + axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n  \n          return vec3( textureCube( envMap, sampleDirection ) );\n  \n        }\n  \n        void main() {\n  \n          vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n  \n          if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n  \n            axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n  \n          }\n  \n          axis = normalize( axis );\n  \n          gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n          gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n  \n          for ( int i = 1; i < n; i++ ) {\n  \n            if ( i >= samples ) {\n  \n              break;\n  \n            }\n  \n            float theta = dTheta * float( i );\n            gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n            gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n  \n          }\n        }\n      `,\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false,\n      side: BackSide\n    });\n    return shaderMaterial;\n  }\n  async dispose() {\n    for (const [, promise] of this.skyboxCache) {\n      const skybox = await promise;\n      skybox.dispose();\n    }\n    if (this.generatedEnvironmentMap != null) {\n      (await this.generatedEnvironmentMap).dispose();\n      this.generatedEnvironmentMap = null;\n    }\n    if (this.generatedEnvironmentMapAlt != null) {\n      (await this.generatedEnvironmentMapAlt).dispose();\n      this.generatedEnvironmentMapAlt = null;\n    }\n    if (this.blurMaterial != null) {\n      this.blurMaterial.dispose();\n    }\n  }\n}","map":{"version":3,"names":["BackSide","BoxGeometry","CubeCamera","EquirectangularReflectionMapping","EventDispatcher","HalfFloatType","LinearEncoding","Mesh","NoBlending","NoToneMapping","RGBAFormat","Scene","ShaderMaterial","sRGBEncoding","TextureLoader","Vector3","WebGLCubeRenderTarget","RGBELoader","deserializeUrl","timePasses","EnvironmentScene","EnvironmentSceneAlt","GENERATED_SIGMA","MAX_SAMPLES","HDR_FILE_RE","ldrLoader","hdrLoader","setDataType","TextureUtils","constructor","threeRenderer","generatedEnvironmentMap","generatedEnvironmentMapAlt","skyboxCache","Map","blurMaterial","blurScene","load","url","progressCallback","isHDR","test","loader","texture","Promise","resolve","reject","event","loaded","total","name","mapping","encoding","generateEnvironmentMapAndSkybox","skyboxUrl","environmentMapUrl","useAltEnvironment","skyboxLoads","environmentMapLoads","loadEquirectFromUrl","loadGeneratedEnvironmentMapAlt","loadGeneratedEnvironmentMap","environmentMap","skybox","all","Error","has","skyboxMapLoads","set","get","GenerateEnvironmentMap","scene","renderer","cubeTarget","generateMipmaps","type","format","depthBuffer","cubeCamera","renderTarget","outputEncoding","toneMapping","update","blurCubemap","sigma","getBlurShader","box","blurMesh","add","tempTarget","clone","halfblur","targetIn","targetOut","sigmaRadians","direction","STANDARD_DEVIATIONS","pixels","width","radiansPerPixel","isFinite","Math","PI","sigmaPixels","samples","floor","console","warn","weights","sum","i","x","weight","exp","push","length","blurUniforms","uniforms","value","maxSamples","Float32Array","poleAxis","shaderMaterial","defines","vertexShader","fragmentShader","blending","depthTest","depthWrite","side","dispose","promise"],"sources":["C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\@google\\model-viewer\\src\\three-components\\TextureUtils.ts"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {BackSide, BoxGeometry, CubeCamera, CubeTexture, EquirectangularReflectionMapping, EventDispatcher, HalfFloatType, LinearEncoding, Mesh, NoBlending, NoToneMapping, RGBAFormat, Scene, ShaderMaterial, sRGBEncoding, Texture, TextureLoader, Vector3, WebGLCubeRenderTarget, WebGLRenderer} from 'three';\nimport {RGBELoader} from 'three/examples/jsm/loaders/RGBELoader.js';\n\nimport {deserializeUrl, timePasses} from '../utilities.js';\n\nimport EnvironmentScene from './EnvironmentScene.js';\nimport EnvironmentSceneAlt from './EnvironmentSceneAlt.js';\n\nexport interface EnvironmentMapAndSkybox {\n  environmentMap: Texture;\n  skybox: Texture|null;\n}\n\nconst GENERATED_SIGMA = 0.04;\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\n\nconst HDR_FILE_RE = /\\.hdr(\\.js)?$/;\nconst ldrLoader = new TextureLoader();\nconst hdrLoader = new RGBELoader();\nhdrLoader.setDataType(HalfFloatType);\n\nexport default class TextureUtils extends EventDispatcher {\n  private generatedEnvironmentMap: Promise<CubeTexture>|null = null;\n  private generatedEnvironmentMapAlt: Promise<CubeTexture>|null = null;\n\n  private skyboxCache = new Map<string, Promise<Texture>>();\n\n  private blurMaterial: ShaderMaterial|null = null;\n  private blurScene: Scene|null = null;\n\n  constructor(private threeRenderer: WebGLRenderer) {\n    super();\n  }\n\n  async load(\n      url: string, progressCallback: (progress: number) => void = () => {}):\n      Promise<Texture> {\n    try {\n      const isHDR: boolean = HDR_FILE_RE.test(url);\n      const loader = isHDR ? hdrLoader : ldrLoader;\n      const texture: Texture = await new Promise<Texture>(\n          (resolve, reject) => loader.load(\n              url, resolve, (event: {loaded: number, total: number}) => {\n                progressCallback(event.loaded / event.total * 0.9);\n              }, reject));\n\n      progressCallback(1.0);\n\n      texture.name = url;\n      texture.mapping = EquirectangularReflectionMapping;\n\n      if (!isHDR) {\n        texture.encoding = sRGBEncoding;\n      }\n\n      return texture;\n\n    } finally {\n      if (progressCallback) {\n        progressCallback(1);\n      }\n    }\n  }\n\n  /**\n   * Returns a { skybox, environmentMap } object with the targets/textures\n   * accordingly. `skybox` is a WebGLRenderCubeTarget, and `environmentMap`\n   * is a Texture from a WebGLRenderCubeTarget.\n   */\n  async generateEnvironmentMapAndSkybox(\n      skyboxUrl: string|null = null, environmentMapUrl: string|null = null,\n      progressCallback: (progress: number) => void = () => {}):\n      Promise<EnvironmentMapAndSkybox> {\n    const useAltEnvironment = environmentMapUrl !== 'legacy';\n    if (environmentMapUrl === 'legacy' || environmentMapUrl === 'neutral') {\n      environmentMapUrl = null;\n    }\n    environmentMapUrl = deserializeUrl(environmentMapUrl);\n\n    let skyboxLoads: Promise<Texture|null> = Promise.resolve(null);\n    let environmentMapLoads: Promise<Texture>;\n\n    // If we have a skybox URL, attempt to load it as a cubemap\n    if (!!skyboxUrl) {\n      skyboxLoads = this.loadEquirectFromUrl(skyboxUrl, progressCallback);\n    }\n\n    if (!!environmentMapUrl) {\n      // We have an available environment map URL\n      environmentMapLoads =\n          this.loadEquirectFromUrl(environmentMapUrl, progressCallback);\n    } else if (!!skyboxUrl) {\n      // Fallback to deriving the environment map from an available skybox\n      environmentMapLoads =\n          this.loadEquirectFromUrl(skyboxUrl, progressCallback);\n    } else {\n      // Fallback to generating the environment map\n      environmentMapLoads = useAltEnvironment ?\n          this.loadGeneratedEnvironmentMapAlt() :\n          this.loadGeneratedEnvironmentMap();\n    }\n\n    const [environmentMap, skybox] =\n        await Promise.all([environmentMapLoads, skyboxLoads]);\n\n    if (environmentMap == null) {\n      throw new Error('Failed to load environment map.');\n    }\n\n    return {environmentMap, skybox};\n  }\n\n  /**\n   * Loads an equirect Texture from a given URL, for use as a skybox.\n   */\n  private async loadEquirectFromUrl(\n      url: string,\n      progressCallback: (progress: number) => void): Promise<Texture> {\n    if (!this.skyboxCache.has(url)) {\n      const skyboxMapLoads = this.load(url, progressCallback);\n\n      this.skyboxCache.set(url, skyboxMapLoads);\n    }\n\n    return this.skyboxCache.get(url)!;\n  }\n\n  private async GenerateEnvironmentMap(scene: Scene, name: string) {\n    await timePasses();\n\n    const renderer = this.threeRenderer;\n    const cubeTarget = new WebGLCubeRenderTarget(256, {\n      generateMipmaps: false,\n      type: HalfFloatType,\n      format: RGBAFormat,\n      encoding: LinearEncoding,\n      depthBuffer: true\n    });\n    const cubeCamera = new CubeCamera(0.1, 100, cubeTarget);\n    const generatedEnvironmentMap = cubeCamera.renderTarget.texture;\n    generatedEnvironmentMap.name = name;\n\n    const outputEncoding = renderer.outputEncoding;\n    const toneMapping = renderer.toneMapping;\n    renderer.toneMapping = NoToneMapping;\n    renderer.outputEncoding = LinearEncoding;\n\n    cubeCamera.update(renderer, scene);\n\n    this.blurCubemap(cubeTarget, GENERATED_SIGMA);\n\n    renderer.toneMapping = toneMapping;\n    renderer.outputEncoding = outputEncoding;\n\n    return generatedEnvironmentMap;\n  }\n\n  /**\n   * Loads a dynamically generated environment map.\n   */\n  private async loadGeneratedEnvironmentMap(): Promise<CubeTexture> {\n    if (this.generatedEnvironmentMap == null) {\n      this.generatedEnvironmentMap =\n          this.GenerateEnvironmentMap(new EnvironmentScene(), 'legacy');\n    }\n    return this.generatedEnvironmentMap;\n  }\n\n  /**\n   * Loads a dynamically generated environment map, designed to be neutral and\n   * color-preserving. Shows less contrast around the different sides of the\n   * object.\n   */\n  private async loadGeneratedEnvironmentMapAlt(): Promise<CubeTexture> {\n    if (this.generatedEnvironmentMapAlt == null) {\n      this.generatedEnvironmentMapAlt =\n          this.GenerateEnvironmentMap(new EnvironmentSceneAlt(), 'neutral');\n    }\n    return this.generatedEnvironmentMapAlt;\n  }\n\n  private blurCubemap(cubeTarget: WebGLCubeRenderTarget, sigma: number) {\n    if (this.blurMaterial == null) {\n      this.blurMaterial = this.getBlurShader(MAX_SAMPLES);\n      const box = new BoxGeometry();\n      const blurMesh = new Mesh(box, this.blurMaterial!);\n      this.blurScene = new Scene();\n      this.blurScene.add(blurMesh);\n    }\n    const tempTarget = cubeTarget.clone();\n    this.halfblur(cubeTarget, tempTarget, sigma, 'latitudinal');\n    this.halfblur(tempTarget, cubeTarget, sigma, 'longitudinal');\n    // Disposing this target after we're done with it somehow corrupts Safari's\n    // whole graphics driver. It's random, but occurs more frequently on\n    // lower-powered GPUs (macbooks with intel graphics, older iPhones). It goes\n    // beyond just messing up the PMREM, as it also occasionally causes\n    // visible corruption on the canvas and even on the rest of the page.\n    /** tempTarget.dispose(); */\n  }\n\n  private halfblur(\n      targetIn: WebGLCubeRenderTarget, targetOut: WebGLCubeRenderTarget,\n      sigmaRadians: number, direction: 'latitudinal'|'longitudinal') {\n    // Number of standard deviations at which to cut off the discrete\n    // approximation.\n    const STANDARD_DEVIATIONS = 3;\n\n    const pixels = targetIn.width;\n    const radiansPerPixel = isFinite(sigmaRadians) ?\n        Math.PI / (2 * pixels) :\n        2 * Math.PI / (2 * MAX_SAMPLES - 1);\n    const sigmaPixels = sigmaRadians / radiansPerPixel;\n    const samples = isFinite(sigmaRadians) ?\n        1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) :\n        MAX_SAMPLES;\n\n    if (samples > MAX_SAMPLES) {\n      console.warn(`sigmaRadians, ${\n          sigmaRadians}, is too large and will clip, as it requested ${\n          samples} samples when the maximum is set to ${MAX_SAMPLES}`);\n    }\n\n    const weights = [];\n    let sum = 0;\n\n    for (let i = 0; i < MAX_SAMPLES; ++i) {\n      const x = i / sigmaPixels;\n      const weight = Math.exp(-x * x / 2);\n      weights.push(weight);\n\n      if (i == 0) {\n        sum += weight;\n\n      } else if (i < samples) {\n        sum += 2 * weight;\n      }\n    }\n\n    for (let i = 0; i < weights.length; i++) {\n      weights[i] = weights[i] / sum;\n    }\n\n    const blurUniforms = this.blurMaterial!.uniforms;\n    blurUniforms['envMap'].value = targetIn.texture;\n    blurUniforms['samples'].value = samples;\n    blurUniforms['weights'].value = weights;\n    blurUniforms['latitudinal'].value = direction === 'latitudinal';\n    blurUniforms['dTheta'].value = radiansPerPixel;\n\n    const cubeCamera = new CubeCamera(0.1, 100, targetOut);\n    cubeCamera.update(this.threeRenderer, this.blurScene!);\n  }\n\n  private getBlurShader(maxSamples: number) {\n    const weights = new Float32Array(maxSamples);\n    const poleAxis = new Vector3(0, 1, 0);\n    const shaderMaterial = new ShaderMaterial({\n\n      name: 'SphericalGaussianBlur',\n\n      defines: {'n': maxSamples},\n\n      uniforms: {\n        'envMap': {value: null},\n        'samples': {value: 1},\n        'weights': {value: weights},\n        'latitudinal': {value: false},\n        'dTheta': {value: 0},\n        'poleAxis': {value: poleAxis}\n      },\n\n      vertexShader: /* glsl */ `\n      \n      varying vec3 vOutputDirection;\n  \n      void main() {\n  \n        vOutputDirection = vec3( position );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  \n      }\n    `,\n\n      fragmentShader: /* glsl */ `\n        varying vec3 vOutputDirection;\n  \n        uniform samplerCube envMap;\n        uniform int samples;\n        uniform float weights[ n ];\n        uniform bool latitudinal;\n        uniform float dTheta;\n        uniform vec3 poleAxis;\n  \n        vec3 getSample( float theta, vec3 axis ) {\n  \n          float cosTheta = cos( theta );\n          // Rodrigues' axis-angle rotation\n          vec3 sampleDirection = vOutputDirection * cosTheta\n            + cross( axis, vOutputDirection ) * sin( theta )\n            + axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n  \n          return vec3( textureCube( envMap, sampleDirection ) );\n  \n        }\n  \n        void main() {\n  \n          vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n  \n          if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n  \n            axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n  \n          }\n  \n          axis = normalize( axis );\n  \n          gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n          gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n  \n          for ( int i = 1; i < n; i++ ) {\n  \n            if ( i >= samples ) {\n  \n              break;\n  \n            }\n  \n            float theta = dTheta * float( i );\n            gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n            gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n  \n          }\n        }\n      `,\n\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false,\n      side: BackSide\n\n    });\n\n    return shaderMaterial;\n  }\n\n  async dispose() {\n    for (const [, promise] of this.skyboxCache) {\n      const skybox = await promise;\n      skybox.dispose();\n    }\n    if (this.generatedEnvironmentMap != null) {\n      (await this.generatedEnvironmentMap).dispose();\n      this.generatedEnvironmentMap = null;\n    }\n    if (this.generatedEnvironmentMapAlt != null) {\n      (await this.generatedEnvironmentMapAlt).dispose();\n      this.generatedEnvironmentMapAlt = null;\n    }\n    if (this.blurMaterial != null) {\n      this.blurMaterial.dispose();\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}