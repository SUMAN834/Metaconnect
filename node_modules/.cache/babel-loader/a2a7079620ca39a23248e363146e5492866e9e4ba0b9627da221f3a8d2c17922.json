{"ast":null,"code":"/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Mesh, MeshBasicMaterial, OrthographicCamera, PlaneGeometry, Scene, WebGLRenderTarget } from 'three';\nimport { blobCanvas } from '../../model-viewer-base.js';\nimport { Renderer } from '../../three-components/Renderer.js';\nimport { $correlatedObjects, $sourceObject, ThreeDOMElement } from './three-dom-element.js';\nconst quadMaterial = new MeshBasicMaterial();\nconst quad = new PlaneGeometry(2, 2);\nlet adhocNum = 0;\nexport const $threeTexture = Symbol('threeTexture');\nexport const $applyTexture = Symbol('applyTexture');\n/**\n * Image facade implementation for Three.js textures\n */\nexport class Image extends ThreeDOMElement {\n  get [$threeTexture]() {\n    var _a;\n    console.assert(this[$correlatedObjects] != null && this[$correlatedObjects].size > 0, 'Image correlated object is undefined');\n    return (_a = this[$correlatedObjects]) === null || _a === void 0 ? void 0 : _a.values().next().value;\n  }\n  constructor(onUpdate, texture, gltfImage) {\n    gltfImage = gltfImage !== null && gltfImage !== void 0 ? gltfImage : {\n      name: texture && texture.image && texture.image.src ? texture.image.src.split('/').pop() : 'adhoc_image',\n      uri: texture && texture.image && texture.image.src ? texture.image.src : 'adhoc_image' + adhocNum++\n    };\n    super(onUpdate, gltfImage, new Set(texture ? [texture] : []));\n  }\n  get name() {\n    return this[$sourceObject].name || '';\n  }\n  get uri() {\n    return this[$sourceObject].uri;\n  }\n  get bufferView() {\n    return this[$sourceObject].bufferView;\n  }\n  get type() {\n    return this.uri != null ? 'external' : 'embedded';\n  }\n  set name(name) {\n    this[$sourceObject].name = name;\n  }\n  async createThumbnail(width, height) {\n    const scene = new Scene();\n    quadMaterial.map = this[$threeTexture];\n    const mesh = new Mesh(quad, quadMaterial);\n    scene.add(mesh);\n    const camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n    const {\n      threeRenderer\n    } = Renderer.singleton;\n    const renderTarget = new WebGLRenderTarget(width, height);\n    threeRenderer.setRenderTarget(renderTarget);\n    threeRenderer.render(scene, camera);\n    threeRenderer.setRenderTarget(null);\n    const buffer = new Uint8Array(width * height * 4);\n    threeRenderer.readRenderTargetPixels(renderTarget, 0, 0, width, height, buffer);\n    blobCanvas.width = width;\n    blobCanvas.height = height;\n    const blobContext = blobCanvas.getContext('2d');\n    const imageData = blobContext.createImageData(width, height);\n    imageData.data.set(buffer);\n    blobContext.putImageData(imageData, 0, 0);\n    return new Promise(async (resolve, reject) => {\n      blobCanvas.toBlob(blob => {\n        if (!blob) {\n          return reject('Failed to capture thumbnail.');\n        }\n        resolve(URL.createObjectURL(blob));\n      }, 'image/png');\n    });\n  }\n}","map":{"version":3,"names":["Mesh","MeshBasicMaterial","OrthographicCamera","PlaneGeometry","Scene","WebGLRenderTarget","blobCanvas","Renderer","$correlatedObjects","$sourceObject","ThreeDOMElement","quadMaterial","quad","adhocNum","$threeTexture","Symbol","$applyTexture","Image","console","assert","size","_a","values","next","value","constructor","onUpdate","texture","gltfImage","name","image","src","split","pop","uri","Set","bufferView","type","createThumbnail","width","height","scene","map","mesh","add","camera","threeRenderer","singleton","renderTarget","setRenderTarget","render","buffer","Uint8Array","readRenderTargetPixels","blobContext","getContext","imageData","createImageData","data","set","putImageData","Promise","resolve","reject","toBlob","blob","URL","createObjectURL"],"sources":["C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\@google\\model-viewer\\src\\features\\scene-graph\\image.ts"],"sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Mesh, MeshBasicMaterial, OrthographicCamera, PlaneGeometry, Scene, Texture as ThreeTexture, WebGLRenderTarget} from 'three';\n\nimport {blobCanvas} from '../../model-viewer-base.js';\nimport {Image as GLTFImage} from '../../three-components/gltf-instance/gltf-2.0.js';\nimport {Renderer} from '../../three-components/Renderer.js';\n\nimport {Image as ImageInterface} from './api.js';\nimport {$correlatedObjects, $sourceObject, ThreeDOMElement} from './three-dom-element.js';\n\n\nconst quadMaterial = new MeshBasicMaterial();\nconst quad = new PlaneGeometry(2, 2);\nlet adhocNum = 0;\n\nexport const $threeTexture = Symbol('threeTexture');\nexport const $applyTexture = Symbol('applyTexture');\n\n/**\n * Image facade implementation for Three.js textures\n */\nexport class Image extends ThreeDOMElement implements ImageInterface {\n  get[$threeTexture]() {\n    console.assert(\n        this[$correlatedObjects] != null && this[$correlatedObjects]!.size > 0,\n        'Image correlated object is undefined');\n    return this[$correlatedObjects]?.values().next().value as ThreeTexture;\n  }\n\n  constructor(\n      onUpdate: () => void, texture: ThreeTexture|null,\n      gltfImage: GLTFImage|null) {\n    gltfImage = gltfImage ?? {\n      name: (texture && texture.image && texture.image.src) ?\n          texture.image.src.split('/').pop() :\n          'adhoc_image',\n      uri: (texture && texture.image && texture.image.src) ?\n          texture.image.src :\n          'adhoc_image' + adhocNum++\n    };\n    super(onUpdate, gltfImage, new Set<ThreeTexture>(texture ? [texture] : []));\n  }\n\n  get name(): string {\n    return (this[$sourceObject] as GLTFImage).name || '';\n  }\n\n  get uri(): string|undefined {\n    return (this[$sourceObject] as GLTFImage).uri;\n  }\n\n  get bufferView(): number|undefined {\n    return (this[$sourceObject] as GLTFImage).bufferView;\n  }\n\n  get type(): 'embedded'|'external' {\n    return this.uri != null ? 'external' : 'embedded';\n  }\n\n  set name(name: string) {\n    (this[$sourceObject] as GLTFImage).name = name;\n  }\n\n  async createThumbnail(width: number, height: number): Promise<string> {\n    const scene = new Scene();\n    quadMaterial.map = this[$threeTexture];\n    const mesh = new Mesh(quad, quadMaterial);\n    scene.add(mesh);\n    const camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\n    const {threeRenderer} = Renderer.singleton;\n    const renderTarget = new WebGLRenderTarget(width, height);\n    threeRenderer.setRenderTarget(renderTarget);\n    threeRenderer.render(scene, camera);\n    threeRenderer.setRenderTarget(null);\n\n    const buffer = new Uint8Array(width * height * 4);\n    threeRenderer.readRenderTargetPixels(\n        renderTarget, 0, 0, width, height, buffer);\n\n    blobCanvas.width = width;\n    blobCanvas.height = height;\n    const blobContext = blobCanvas.getContext('2d')!;\n    const imageData = blobContext.createImageData(width, height);\n    imageData.data.set(buffer);\n    blobContext.putImageData(imageData, 0, 0);\n\n    return new Promise<string>(async (resolve, reject) => {\n      blobCanvas.toBlob(blob => {\n        if (!blob) {\n          return reject('Failed to capture thumbnail.');\n        }\n        resolve(URL.createObjectURL(blob));\n      }, 'image/png');\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}