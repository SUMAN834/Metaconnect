{"ast":null,"code":"/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b;\nimport { LinearEncoding, sRGBEncoding, Vector2 } from 'three';\nimport { $threeTexture } from './image.js';\nimport { Texture } from './texture.js';\nconst $texture = Symbol('texture');\nconst $transform = Symbol('transform');\nexport const $materials = Symbol('materials');\nexport const $usage = Symbol('usage');\n// Defines what a texture will be used for.\nexport var TextureUsage;\n(function (TextureUsage) {\n  TextureUsage[TextureUsage[\"Base\"] = 0] = \"Base\";\n  TextureUsage[TextureUsage[\"MetallicRoughness\"] = 1] = \"MetallicRoughness\";\n  TextureUsage[TextureUsage[\"Normal\"] = 2] = \"Normal\";\n  TextureUsage[TextureUsage[\"Occlusion\"] = 3] = \"Occlusion\";\n  TextureUsage[TextureUsage[\"Emissive\"] = 4] = \"Emissive\";\n})(TextureUsage || (TextureUsage = {}));\n/**\n * TextureInfo facade implementation for Three.js materials\n */\nexport class TextureInfo {\n  constructor(onUpdate, usage, threeTexture, material, gltf, gltfTextureInfo) {\n    this[_a] = null;\n    this[_b] = {\n      rotation: 0,\n      scale: new Vector2(1, 1),\n      offset: new Vector2(0, 0)\n    };\n    // Creates image, sampler, and texture if valid texture info is provided.\n    if (gltfTextureInfo && threeTexture) {\n      const gltfTexture = gltf.textures ? gltf.textures[gltfTextureInfo.index] : null;\n      const sampler = gltfTexture ? gltf.samplers ? gltf.samplers[gltfTexture.sampler] : null : null;\n      const image = gltfTexture ? gltf.images ? gltf.images[gltfTexture.source] : null : null;\n      this[$transform].rotation = threeTexture.rotation;\n      this[$transform].scale.copy(threeTexture.repeat);\n      this[$transform].offset.copy(threeTexture.offset);\n      this[$texture] = new Texture(onUpdate, threeTexture, gltfTexture, sampler, image);\n    }\n    this.onUpdate = onUpdate;\n    this[$materials] = material;\n    this[$usage] = usage;\n  }\n  get texture() {\n    return this[$texture];\n  }\n  setTexture(texture) {\n    const threeTexture = texture != null ? texture.source[$threeTexture] : null;\n    let encoding = sRGBEncoding;\n    this[$texture] = texture;\n    if (this[$materials]) {\n      for (const material of this[$materials]) {\n        switch (this[$usage]) {\n          case TextureUsage.Base:\n            material.map = threeTexture;\n            break;\n          case TextureUsage.MetallicRoughness:\n            encoding = LinearEncoding;\n            material.metalnessMap = threeTexture;\n            material.roughnessMap = threeTexture;\n            break;\n          case TextureUsage.Normal:\n            encoding = LinearEncoding;\n            material.normalMap = threeTexture;\n            break;\n          case TextureUsage.Occlusion:\n            encoding = LinearEncoding;\n            material.aoMap = threeTexture;\n            break;\n          case TextureUsage.Emissive:\n            material.emissiveMap = threeTexture;\n            break;\n          default:\n        }\n        material.needsUpdate = true;\n      }\n    }\n    if (threeTexture) {\n      // Updates the encoding for the texture, affects all references.\n      threeTexture.encoding = encoding;\n      threeTexture.rotation = this[$transform].rotation;\n      threeTexture.repeat = this[$transform].scale;\n      threeTexture.offset = this[$transform].offset;\n    }\n    this.onUpdate();\n  }\n}\n_a = $texture, _b = $transform;","map":{"version":3,"names":["LinearEncoding","sRGBEncoding","Vector2","$threeTexture","Texture","$texture","Symbol","$transform","$materials","$usage","TextureUsage","TextureInfo","constructor","onUpdate","usage","threeTexture","material","gltf","gltfTextureInfo","_a","_b","rotation","scale","offset","gltfTexture","textures","index","sampler","samplers","image","images","source","copy","repeat","texture","setTexture","encoding","Base","map","MetallicRoughness","metalnessMap","roughnessMap","Normal","normalMap","Occlusion","aoMap","Emissive","emissiveMap","needsUpdate"],"sources":["C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\@google\\model-viewer\\src\\features\\scene-graph\\texture-info.ts"],"sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {LinearEncoding, MeshStandardMaterial, sRGBEncoding, Texture as ThreeTexture, TextureEncoding, Vector2} from 'three';\n\nimport {GLTF, TextureInfo as GLTFTextureInfo} from '../../three-components/gltf-instance/gltf-2.0.js';\n\nimport {TextureInfo as TextureInfoInterface} from './api.js';\nimport {$threeTexture} from './image.js';\nimport {Texture} from './texture.js';\n\nconst $texture = Symbol('texture');\nconst $transform = Symbol('transform');\nexport const $materials = Symbol('materials');\nexport const $usage = Symbol('usage');\n\n// Defines what a texture will be used for.\nexport enum TextureUsage {\n  Base,\n  MetallicRoughness,\n  Normal,\n  Occlusion,\n  Emissive,\n}\n\ninterface TextureTransform {\n  rotation: number;\n  scale: Vector2;\n  offset: Vector2;\n}\n\n/**\n * TextureInfo facade implementation for Three.js materials\n */\nexport class TextureInfo implements TextureInfoInterface {\n  private[$texture]: Texture|null = null;\n  private[$transform]: TextureTransform = {\n    rotation: 0,\n    scale: new Vector2(1, 1),\n    offset: new Vector2(0, 0)\n  };\n\n  // Holds a reference to the Three data that backs the material object.\n  [$materials]: Set<MeshStandardMaterial>|null;\n\n  // Texture usage defines the how the texture is used (ie Normal, Emissive...\n  // etc)\n  [$usage]: TextureUsage;\n  onUpdate: () => void;\n\n  constructor(\n      onUpdate: () => void, usage: TextureUsage,\n      threeTexture: ThreeTexture|null, material: Set<MeshStandardMaterial>,\n      gltf: GLTF, gltfTextureInfo: GLTFTextureInfo|null) {\n    // Creates image, sampler, and texture if valid texture info is provided.\n    if (gltfTextureInfo && threeTexture) {\n      const gltfTexture =\n          gltf.textures ? gltf.textures[gltfTextureInfo.index] : null;\n      const sampler = gltfTexture ?\n          (gltf.samplers ? gltf.samplers[gltfTexture.sampler!] : null) :\n          null;\n      const image = gltfTexture ?\n          (gltf.images ? gltf.images[gltfTexture.source!] : null) :\n          null;\n\n      this[$transform].rotation = threeTexture.rotation;\n      this[$transform].scale.copy(threeTexture.repeat);\n      this[$transform].offset.copy(threeTexture.offset);\n\n      this[$texture] =\n          new Texture(onUpdate, threeTexture, gltfTexture, sampler, image);\n    }\n\n    this.onUpdate = onUpdate;\n    this[$materials] = material;\n    this[$usage] = usage;\n  }\n\n  get texture(): Texture|null {\n    return this[$texture];\n  }\n\n  setTexture(texture: Texture|null): void {\n    const threeTexture: ThreeTexture|null =\n        texture != null ? texture.source[$threeTexture] : null;\n    let encoding: TextureEncoding = sRGBEncoding;\n    this[$texture] = texture;\n\n    if (this[$materials]) {\n      for (const material of this[$materials]!) {\n        switch (this[$usage]) {\n          case TextureUsage.Base:\n            material.map = threeTexture;\n            break;\n          case TextureUsage.MetallicRoughness:\n            encoding = LinearEncoding;\n            material.metalnessMap = threeTexture;\n            material.roughnessMap = threeTexture;\n            break;\n          case TextureUsage.Normal:\n            encoding = LinearEncoding;\n            material.normalMap = threeTexture;\n            break;\n          case TextureUsage.Occlusion:\n            encoding = LinearEncoding;\n            material.aoMap = threeTexture;\n            break;\n          case TextureUsage.Emissive:\n            material.emissiveMap = threeTexture;\n            break;\n          default:\n        }\n        material.needsUpdate = true;\n      }\n    }\n\n    if (threeTexture) {\n      // Updates the encoding for the texture, affects all references.\n      threeTexture.encoding = encoding;\n      threeTexture.rotation = this[$transform].rotation;\n      threeTexture.repeat = this[$transform].scale;\n      threeTexture.offset = this[$transform].offset;\n    }\n    this.onUpdate();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}