{"ast":null,"code":"const EventEmitter = require('events');\nconst EthereumProvider = require('ethereum-provider').default;\nconst ConnectionManager = require('../ConnectionManager');\nconst monitor = provider => {\n  function update(status) {\n    provider.status = status;\n    if (provider instanceof EventEmitter) provider.emit('status', status);\n  }\n  async function checkSyncing() {\n    try {\n      if (await provider.send('eth_syncing')) {\n        update('syncing');\n      }\n    } catch (e) {\n      // don't do anything if it can't be determined whether the node is syncing or not\n    }\n  }\n  async function checkConnected() {\n    if (provider.inSetup) return setTimeout(checkConnected, 1000);\n    try {\n      await provider.send('eth_chainId');\n      update('connected');\n      setTimeout(checkSyncing, 500);\n    } catch (e) {\n      update('disconnected');\n    }\n  }\n  update('loading');\n  checkConnected();\n  provider.on('connect', () => checkConnected());\n  provider.on('close', () => update('disconnected'));\n  return provider;\n};\nmodule.exports = (connections, targets, options) => {\n  // If window.ethereum and injected is a target in any priority, return ethereum provider\n  if (connections.injected.__isProvider && targets.map(t => t.type).indexOf('injected') > -1) {\n    delete connections.injected.__isProvider;\n    return monitor(connections.injected);\n  }\n  const provider = new EthereumProvider(new ConnectionManager(connections, targets, options));\n  provider.setMaxListeners(128);\n  return monitor(provider);\n};","map":{"version":3,"names":["EventEmitter","require","EthereumProvider","default","ConnectionManager","monitor","provider","update","status","emit","checkSyncing","send","e","checkConnected","inSetup","setTimeout","on","module","exports","connections","targets","options","injected","__isProvider","map","t","type","indexOf","setMaxListeners"],"sources":["C:/Users/SUMAN K/meta_transfer/node_modules/eth-provider/provider/index.js"],"sourcesContent":["const EventEmitter = require('events')\nconst EthereumProvider = require('ethereum-provider').default\nconst ConnectionManager = require('../ConnectionManager')\n\nconst monitor = provider => {\n  function update (status) {\n    provider.status = status\n    if (provider instanceof EventEmitter) provider.emit('status', status)\n  }\n\n  async function checkSyncing () {\n    try {\n      if (await provider.send('eth_syncing')) {\n        update('syncing')\n      }\n    } catch (e) {\n      // don't do anything if it can't be determined whether the node is syncing or not\n    }\n  }\n\n  async function checkConnected () {\n    if (provider.inSetup) return setTimeout(checkConnected, 1000)\n\n    try {\n      await provider.send('eth_chainId')\n      update('connected')\n\n      setTimeout(checkSyncing, 500)\n    } catch (e) {\n      update('disconnected')\n    }\n  }\n\n  update('loading')\n  checkConnected()\n  provider.on('connect', () => checkConnected())\n  provider.on('close', () => update('disconnected'))\n  return provider\n}\n\nmodule.exports = (connections, targets, options) => {\n  // If window.ethereum and injected is a target in any priority, return ethereum provider\n  if (connections.injected.__isProvider && targets.map(t => t.type).indexOf('injected') > -1) {\n    delete connections.injected.__isProvider\n    return monitor(connections.injected)\n  }\n  const provider = new EthereumProvider(new ConnectionManager(connections, targets, options))\n  provider.setMaxListeners(128)\n  return monitor(provider)\n}\n"],"mappings":"AAAA,MAAMA,YAAY,GAAGC,OAAO,CAAC,QAAQ,CAAC;AACtC,MAAMC,gBAAgB,GAAGD,OAAO,CAAC,mBAAmB,CAAC,CAACE,OAAO;AAC7D,MAAMC,iBAAiB,GAAGH,OAAO,CAAC,sBAAsB,CAAC;AAEzD,MAAMI,OAAO,GAAGC,QAAQ,IAAI;EAC1B,SAASC,MAAMA,CAAEC,MAAM,EAAE;IACvBF,QAAQ,CAACE,MAAM,GAAGA,MAAM;IACxB,IAAIF,QAAQ,YAAYN,YAAY,EAAEM,QAAQ,CAACG,IAAI,CAAC,QAAQ,EAAED,MAAM,CAAC;EACvE;EAEA,eAAeE,YAAYA,CAAA,EAAI;IAC7B,IAAI;MACF,IAAI,MAAMJ,QAAQ,CAACK,IAAI,CAAC,aAAa,CAAC,EAAE;QACtCJ,MAAM,CAAC,SAAS,CAAC;MACnB;IACF,CAAC,CAAC,OAAOK,CAAC,EAAE;MACV;IAAA;EAEJ;EAEA,eAAeC,cAAcA,CAAA,EAAI;IAC/B,IAAIP,QAAQ,CAACQ,OAAO,EAAE,OAAOC,UAAU,CAACF,cAAc,EAAE,IAAI,CAAC;IAE7D,IAAI;MACF,MAAMP,QAAQ,CAACK,IAAI,CAAC,aAAa,CAAC;MAClCJ,MAAM,CAAC,WAAW,CAAC;MAEnBQ,UAAU,CAACL,YAAY,EAAE,GAAG,CAAC;IAC/B,CAAC,CAAC,OAAOE,CAAC,EAAE;MACVL,MAAM,CAAC,cAAc,CAAC;IACxB;EACF;EAEAA,MAAM,CAAC,SAAS,CAAC;EACjBM,cAAc,CAAC,CAAC;EAChBP,QAAQ,CAACU,EAAE,CAAC,SAAS,EAAE,MAAMH,cAAc,CAAC,CAAC,CAAC;EAC9CP,QAAQ,CAACU,EAAE,CAAC,OAAO,EAAE,MAAMT,MAAM,CAAC,cAAc,CAAC,CAAC;EAClD,OAAOD,QAAQ;AACjB,CAAC;AAEDW,MAAM,CAACC,OAAO,GAAG,CAACC,WAAW,EAAEC,OAAO,EAAEC,OAAO,KAAK;EAClD;EACA,IAAIF,WAAW,CAACG,QAAQ,CAACC,YAAY,IAAIH,OAAO,CAACI,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACC,IAAI,CAAC,CAACC,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,EAAE;IAC1F,OAAOR,WAAW,CAACG,QAAQ,CAACC,YAAY;IACxC,OAAOlB,OAAO,CAACc,WAAW,CAACG,QAAQ,CAAC;EACtC;EACA,MAAMhB,QAAQ,GAAG,IAAIJ,gBAAgB,CAAC,IAAIE,iBAAiB,CAACe,WAAW,EAAEC,OAAO,EAAEC,OAAO,CAAC,CAAC;EAC3Ff,QAAQ,CAACsB,eAAe,CAAC,GAAG,CAAC;EAC7B,OAAOvB,OAAO,CAACC,QAAQ,CAAC;AAC1B,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}