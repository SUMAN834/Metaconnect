{"ast":null,"code":"const EventEmitter = require('events');\nconst parse = require('../parse');\nconst dev = process.env.NODE_ENV === 'development';\nlet WebSocket;\nclass WebSocketConnection extends EventEmitter {\n  constructor(_WebSocket, url, options) {\n    super();\n    this.socketListeners = [];\n    WebSocket = _WebSocket;\n    setTimeout(() => this.create(url, options), 0);\n  }\n  create(url, options) {\n    if (!WebSocket) return this.onError(new Error('No WebSocket transport available'));\n    try {\n      this.socket = new WebSocket(url, [], {\n        origin: options.origin\n      });\n    } catch (e) {\n      return this.onError(e);\n    }\n    this.addSocketListener('error', this.onError.bind(this));\n    this.addSocketListener('open', this.onOpen.bind(this));\n    this.addSocketListener('close', this.onClose.bind(this));\n  }\n  addSocketListener(event, handler) {\n    this.socket.addEventListener(event, handler);\n    this.socketListeners.push({\n      event,\n      handler\n    });\n  }\n  removeAllSocketListeners() {\n    this.socketListeners.forEach(({\n      event,\n      handler\n    }) => {\n      this.socket.removeEventListener(event, handler);\n    });\n    this.socketListeners = [];\n  }\n  onOpen() {\n    this.emit('connect');\n    this.addSocketListener('message', this.onMessage.bind(this));\n  }\n  onMessage(message) {\n    const data = typeof message.data === 'string' ? message.data : '';\n    parse(data, (err, payloads) => {\n      if (err) return; //\n      payloads.forEach(load => {\n        if (Array.isArray(load)) {\n          load.forEach(payload => this.emit('payload', payload));\n        } else {\n          this.emit('payload', load);\n        }\n      });\n    });\n  }\n  onError(err) {\n    if (this.listenerCount('error')) this.emit('error', err);\n  }\n  onClose(e) {\n    // onClose should only be called as a result of the socket's close event\n    // OR when close() is called manually and the socket either doesn't exist or is already in a closed state\n    const err = {\n      reason: e ? e.reason : 'unknown',\n      code: e ? e.code : 'unknown'\n    };\n    if (this.socket) {\n      this.removeAllSocketListeners();\n      this.socket = null;\n    }\n    this.closed = true;\n    if (dev) console.log(`Closing WebSocket connection, reason: ${err.reason} (code ${err.code})`);\n    this.emit('close');\n    this.removeAllListeners();\n  }\n  close() {\n    if (this.socket && WebSocket && this.socket.readyState !== WebSocket.CLOSED) {\n      this.removeAllSocketListeners();\n      this.addSocketListener('error', () => {});\n      this.addSocketListener('close', this.onClose.bind(this));\n      if (this.socket.terminate) {\n        this.socket.terminate();\n      } else {\n        this.socket.close();\n      }\n    } else {\n      this.onClose();\n    }\n  }\n  error(payload, message, code = -1) {\n    this.emit('payload', {\n      id: payload.id,\n      jsonrpc: payload.jsonrpc,\n      error: {\n        message,\n        code\n      }\n    });\n  }\n  send(payload) {\n    try {\n      if (this.socket && this.socket.readyState === this.socket.CONNECTING) {\n        setTimeout(_ => this.send(payload), 10);\n      } else if (!this.socket || this.socket.readyState > 1) {\n        this.connected = false;\n        this.error(payload, 'Not connected');\n      } else {\n        this.socket.send(JSON.stringify(payload));\n      }\n    } catch (e) {\n      if (dev) console.error('Error sending Websocket request', e);\n      this.error(payload, e.message);\n    }\n  }\n}\nmodule.exports = WebSocket => (url, cb) => new WebSocketConnection(WebSocket, url, cb);","map":{"version":3,"names":["EventEmitter","require","parse","dev","process","env","NODE_ENV","WebSocket","WebSocketConnection","constructor","_WebSocket","url","options","socketListeners","setTimeout","create","onError","Error","socket","origin","e","addSocketListener","bind","onOpen","onClose","event","handler","addEventListener","push","removeAllSocketListeners","forEach","removeEventListener","emit","onMessage","message","data","err","payloads","load","Array","isArray","payload","listenerCount","reason","code","closed","console","log","removeAllListeners","close","readyState","CLOSED","terminate","error","id","jsonrpc","send","CONNECTING","_","connected","JSON","stringify","module","exports","cb"],"sources":["C:/Users/SUMAN K/meta_transfer/node_modules/eth-provider/connections/ws.js"],"sourcesContent":["const EventEmitter = require('events')\nconst parse = require('../parse')\nconst dev = process.env.NODE_ENV === 'development'\n\nlet WebSocket\n\nclass WebSocketConnection extends EventEmitter {\n  constructor (_WebSocket, url, options) {\n    super()\n    this.socketListeners = []\n    WebSocket = _WebSocket\n    setTimeout(() => this.create(url, options), 0)\n  }\n\n  create (url, options) {\n    if (!WebSocket) return this.onError(new Error('No WebSocket transport available'))\n    try {\n      this.socket = new WebSocket(url, [], { origin: options.origin })\n    } catch (e) {\n      return this.onError(e)\n    }\n\n    this.addSocketListener('error', this.onError.bind(this))\n    this.addSocketListener('open', this.onOpen.bind(this))\n    this.addSocketListener('close', this.onClose.bind(this))\n  }\n\n  addSocketListener (event, handler) {\n    this.socket.addEventListener(event, handler)\n    this.socketListeners.push({ event, handler })\n  }\n\n  removeAllSocketListeners () {\n    this.socketListeners.forEach(({ event, handler }) => {\n      this.socket.removeEventListener(event, handler)\n    })\n    this.socketListeners = []\n  }\n\n  onOpen () {\n    this.emit('connect')\n    this.addSocketListener('message', this.onMessage.bind(this))\n  }\n\n  onMessage (message) {\n    const data = typeof message.data === 'string' ? message.data : ''\n    parse(data, (err, payloads) => {\n      if (err) return //\n      payloads.forEach(load => {\n        if (Array.isArray(load)) {\n          load.forEach(payload => this.emit('payload', payload))\n        } else {\n          this.emit('payload', load)\n        }\n      })\n    })\n  }\n\n  onError (err) {\n    if (this.listenerCount('error')) this.emit('error', err)\n  }\n\n  onClose (e) {\n    // onClose should only be called as a result of the socket's close event\n    // OR when close() is called manually and the socket either doesn't exist or is already in a closed state\n    const err = {\n      reason: e ? e.reason : 'unknown',\n      code: e ? e.code : 'unknown'\n    }\n\n    if (this.socket) {\n      this.removeAllSocketListeners()\n      this.socket = null\n    }\n\n    this.closed = true\n\n    if (dev) console.log(`Closing WebSocket connection, reason: ${err.reason} (code ${err.code})`)\n\n    this.emit('close')\n    this.removeAllListeners()\n  }\n\n  close () {\n    if (this.socket && WebSocket && this.socket.readyState !== WebSocket.CLOSED) {\n      this.removeAllSocketListeners()\n      this.addSocketListener('error', () => {})\n      this.addSocketListener('close', this.onClose.bind(this))\n      if (this.socket.terminate) {\n        this.socket.terminate()\n      } else {\n        this.socket.close()\n      }\n    } else {\n      this.onClose()\n    }\n  }\n\n  error (payload, message, code = -1) {\n    this.emit('payload', { id: payload.id, jsonrpc: payload.jsonrpc, error: { message, code } })\n  }\n\n  send (payload) {\n    try {\n      if (this.socket && this.socket.readyState === this.socket.CONNECTING) {\n        setTimeout(_ => this.send(payload), 10)\n      } else if (!this.socket || this.socket.readyState > 1) {\n        this.connected = false\n        this.error(payload, 'Not connected')\n      } else {\n        this.socket.send(JSON.stringify(payload))\n      }\n    } catch (e) {\n      if (dev) console.error('Error sending Websocket request', e)\n\n      this.error(payload, e.message)\n    }\n  }\n}\n\nmodule.exports = WebSocket => (url, cb) => new WebSocketConnection(WebSocket, url, cb)\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}