{"ast":null,"code":"/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { property } from 'lit/decorators.js';\nimport { RepeatWrapping, sRGBEncoding, TextureLoader } from 'three';\nimport { GLTFExporter } from 'three/examples/jsm/exporters/GLTFExporter.js';\nimport { $needsRender, $onModelLoad, $progressTracker, $renderer, $scene } from '../model-viewer-base.js';\nimport GLTFExporterMaterialsVariantsExtension from '../three-components/gltf-instance/VariantMaterialExporterPlugin';\nimport { $availableVariants, $materialFromPoint, $prepareVariantsForExport, $switchVariant, Model } from './scene-graph/model.js';\nimport { Texture as ModelViewerTexture } from './scene-graph/texture';\nexport const $currentGLTF = Symbol('currentGLTF');\nexport const $originalGltfJson = Symbol('originalGltfJson');\nexport const $model = Symbol('model');\nconst $getOnUpdateMethod = Symbol('getOnUpdateMethod');\nconst $textureLoader = Symbol('textureLoader');\n/**\n * SceneGraphMixin manages exposes a model API in order to support operations on\n * the <model-viewer> scene graph.\n */\nexport const SceneGraphMixin = ModelViewerElement => {\n  var _a, _b, _c, _d;\n  class SceneGraphModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this[_a] = undefined;\n      this[_b] = null;\n      this[_c] = new TextureLoader();\n      this[_d] = null;\n      this.variantName = null;\n      this.orientation = '0 0 0';\n      this.scale = '1 1 1';\n    }\n    // Scene-graph API:\n    /** @export */\n    get model() {\n      return this[$model];\n    }\n    get availableVariants() {\n      return this.model ? this.model[$availableVariants]() : [];\n    }\n    /**\n     * Returns a deep copy of the gltf JSON as loaded. It will not reflect\n     * changes to the scene-graph, nor will editing it have any effect.\n     */\n    get originalGltfJson() {\n      return this[$originalGltfJson];\n    }\n    [(_a = $model, _b = $currentGLTF, _c = $textureLoader, _d = $originalGltfJson, $getOnUpdateMethod)]() {\n      return () => {\n        this[$needsRender]();\n      };\n    }\n    async createTexture(uri, type = 'image/png') {\n      const currentGLTF = this[$currentGLTF];\n      const texture = await new Promise(resolve => this[$textureLoader].load(uri, resolve));\n      if (!currentGLTF || !texture) {\n        return null;\n      }\n      // Applies default settings.\n      texture.encoding = sRGBEncoding;\n      texture.wrapS = RepeatWrapping;\n      texture.wrapT = RepeatWrapping;\n      texture.flipY = false;\n      texture.userData.mimeType = type;\n      return new ModelViewerTexture(this[$getOnUpdateMethod](), texture);\n    }\n    async updated(changedProperties) {\n      super.updated(changedProperties);\n      if (changedProperties.has('variantName')) {\n        const updateVariantProgress = this[$progressTracker].beginActivity();\n        updateVariantProgress(0.1);\n        const model = this[$model];\n        const {\n          variantName\n        } = this;\n        if (model != null) {\n          await model[$switchVariant](variantName);\n          this[$needsRender]();\n          this.dispatchEvent(new CustomEvent('variant-applied'));\n        }\n        updateVariantProgress(1.0);\n      }\n      if (changedProperties.has('orientation') || changedProperties.has('scale')) {\n        if (!this.loaded) {\n          return;\n        }\n        const scene = this[$scene];\n        scene.applyTransform();\n        scene.updateBoundingBox();\n        scene.updateShadow();\n        this[$renderer].arRenderer.onUpdateScene();\n        this[$needsRender]();\n      }\n    }\n    [$onModelLoad]() {\n      super[$onModelLoad]();\n      const {\n        currentGLTF\n      } = this[$scene];\n      if (currentGLTF != null) {\n        const {\n          correlatedSceneGraph\n        } = currentGLTF;\n        if (correlatedSceneGraph != null && currentGLTF !== this[$currentGLTF]) {\n          this[$model] = new Model(correlatedSceneGraph, this[$getOnUpdateMethod]());\n          this[$originalGltfJson] = JSON.parse(JSON.stringify(correlatedSceneGraph.gltf));\n        }\n        // KHR_materials_variants extension spec:\n        // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_variants\n        if ('variants' in currentGLTF.userData) {\n          this.requestUpdate('variantName');\n        }\n      }\n      this[$currentGLTF] = currentGLTF;\n    }\n    /** @export */\n    async exportScene(options) {\n      const scene = this[$scene];\n      return new Promise(async (resolve, reject) => {\n        // Defaults\n        const opts = {\n          binary: true,\n          onlyVisible: true,\n          maxTextureSize: Infinity,\n          includeCustomExtensions: false,\n          forceIndices: false\n        };\n        Object.assign(opts, options);\n        // Not configurable\n        opts.animations = scene.animations;\n        opts.truncateDrawRange = true;\n        const shadow = scene.shadow;\n        let visible = false;\n        // Remove shadow from export\n        if (shadow != null) {\n          visible = shadow.visible;\n          shadow.visible = false;\n        }\n        await this[$model][$prepareVariantsForExport]();\n        const exporter = new GLTFExporter().register(writer => new GLTFExporterMaterialsVariantsExtension(writer));\n        exporter.parse(scene.model, gltf => {\n          return resolve(new Blob([opts.binary ? gltf : JSON.stringify(gltf)], {\n            type: opts.binary ? 'application/octet-stream' : 'application/json'\n          }));\n        }, () => {\n          return reject('glTF export failed');\n        }, opts);\n        if (shadow != null) {\n          shadow.visible = visible;\n        }\n      });\n    }\n    materialFromPoint(pixelX, pixelY) {\n      const scene = this[$scene];\n      const ndcCoords = scene.getNDC(pixelX, pixelY);\n      scene.raycaster.setFromCamera(ndcCoords, scene.getCamera());\n      return this[$model][$materialFromPoint](scene.raycaster);\n    }\n  }\n  __decorate([property({\n    type: String,\n    attribute: 'variant-name'\n  })], SceneGraphModelViewerElement.prototype, \"variantName\", void 0);\n  __decorate([property({\n    type: String,\n    attribute: 'orientation'\n  })], SceneGraphModelViewerElement.prototype, \"orientation\", void 0);\n  __decorate([property({\n    type: String,\n    attribute: 'scale'\n  })], SceneGraphModelViewerElement.prototype, \"scale\", void 0);\n  return SceneGraphModelViewerElement;\n};","map":{"version":3,"names":["property","RepeatWrapping","sRGBEncoding","TextureLoader","GLTFExporter","$needsRender","$onModelLoad","$progressTracker","$renderer","$scene","GLTFExporterMaterialsVariantsExtension","$availableVariants","$materialFromPoint","$prepareVariantsForExport","$switchVariant","Model","Texture","ModelViewerTexture","$currentGLTF","Symbol","$originalGltfJson","$model","$getOnUpdateMethod","$textureLoader","SceneGraphMixin","ModelViewerElement","SceneGraphModelViewerElement","constructor","_a","undefined","_b","_c","_d","variantName","orientation","scale","model","availableVariants","originalGltfJson","createTexture","uri","type","currentGLTF","texture","Promise","resolve","load","encoding","wrapS","wrapT","flipY","userData","mimeType","updated","changedProperties","has","updateVariantProgress","beginActivity","dispatchEvent","CustomEvent","loaded","scene","applyTransform","updateBoundingBox","updateShadow","arRenderer","onUpdateScene","correlatedSceneGraph","JSON","parse","stringify","gltf","requestUpdate","exportScene","options","reject","opts","binary","onlyVisible","maxTextureSize","Infinity","includeCustomExtensions","forceIndices","Object","assign","animations","truncateDrawRange","shadow","visible","exporter","register","writer","Blob","materialFromPoint","pixelX","pixelY","ndcCoords","getNDC","raycaster","setFromCamera","getCamera","__decorate","String","attribute"],"sources":["C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\@google\\model-viewer\\src\\features\\scene-graph.ts"],"sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {property} from 'lit/decorators.js';\nimport {RepeatWrapping, sRGBEncoding, Texture, TextureLoader} from 'three';\nimport {GLTFExporter, GLTFExporterOptions} from 'three/examples/jsm/exporters/GLTFExporter.js';\n\nimport ModelViewerElementBase, {$needsRender, $onModelLoad, $progressTracker, $renderer, $scene} from '../model-viewer-base.js';\nimport {GLTF} from '../three-components/gltf-instance/gltf-defaulted.js';\nimport {ModelViewerGLTFInstance} from '../three-components/gltf-instance/ModelViewerGLTFInstance.js';\nimport GLTFExporterMaterialsVariantsExtension from '../three-components/gltf-instance/VariantMaterialExporterPlugin';\nimport {Constructor} from '../utilities.js';\n\nimport {Image, PBRMetallicRoughness, Sampler, TextureInfo} from './scene-graph/api.js';\nimport {Material} from './scene-graph/material.js';\nimport {$availableVariants, $materialFromPoint, $prepareVariantsForExport, $switchVariant, Model} from './scene-graph/model.js';\nimport {Texture as ModelViewerTexture} from './scene-graph/texture';\n\n\n\nexport const $currentGLTF = Symbol('currentGLTF');\nexport const $originalGltfJson = Symbol('originalGltfJson');\nexport const $model = Symbol('model');\nconst $getOnUpdateMethod = Symbol('getOnUpdateMethod');\nconst $textureLoader = Symbol('textureLoader');\n\ninterface SceneExportOptions {\n  binary?: boolean, trs?: boolean, onlyVisible?: boolean,\n      maxTextureSize?: number, includeCustomExtensions?: boolean,\n      forceIndices?: boolean\n}\n\nexport interface SceneGraphInterface {\n  readonly model?: Model;\n  variantName: string|null;\n  readonly availableVariants: string[];\n  orientation: string;\n  scale: string;\n  readonly originalGltfJson: GLTF|null;\n  exportScene(options?: SceneExportOptions): Promise<Blob>;\n  createTexture(uri: string, type?: string): Promise<ModelViewerTexture|null>;\n  /**\n   * Intersects a ray with the scene and returns a list of materials who's\n   * objects were intersected.\n   * @param pixelX X coordinate of the mouse.\n   * @param pixelY Y coordinate of the mouse.\n   * @returns a material, if no intersection is made then null is returned.\n   */\n  materialFromPoint(pixelX: number, pixelY: number): Material|null;\n}\n\n/**\n * SceneGraphMixin manages exposes a model API in order to support operations on\n * the <model-viewer> scene graph.\n */\nexport const SceneGraphMixin = <T extends Constructor<ModelViewerElementBase>>(\n    ModelViewerElement: T): Constructor<SceneGraphInterface>&T => {\n  class SceneGraphModelViewerElement extends ModelViewerElement {\n    protected[$model]: Model|undefined = undefined;\n    protected[$currentGLTF]: ModelViewerGLTFInstance|null = null;\n    private[$textureLoader] = new TextureLoader();\n    private[$originalGltfJson]: GLTF|null = null;\n\n    @property({type: String, attribute: 'variant-name'})\n    variantName: string|null = null;\n\n    @property({type: String, attribute: 'orientation'})\n    orientation: string = '0 0 0';\n\n    @property({type: String, attribute: 'scale'}) scale: string = '1 1 1';\n\n    // Scene-graph API:\n    /** @export */\n    get model() {\n      return this[$model];\n    }\n\n    get availableVariants() {\n      return this.model ? this.model[$availableVariants]() : [] as string[];\n    }\n\n    /**\n     * Returns a deep copy of the gltf JSON as loaded. It will not reflect\n     * changes to the scene-graph, nor will editing it have any effect.\n     */\n    get originalGltfJson() {\n      return this[$originalGltfJson];\n    }\n\n    /**\n     * References to each element constructor. Supports instanceof checks; these\n     * classes are not directly constructable.\n     */\n    static Model: Constructor<Model>;\n    static Material: Constructor<Material>;\n    static PBRMetallicRoughness: Constructor<PBRMetallicRoughness>;\n    static Sampler: Constructor<Sampler>;\n    static TextureInfo: Constructor<TextureInfo>;\n    static Texture: Constructor<Texture>;\n    static Image: Constructor<Image>;\n\n    private[$getOnUpdateMethod]() {\n      return () => {\n        this[$needsRender]();\n      };\n    }\n\n    async createTexture(uri: string, type: string = 'image/png'):\n        Promise<ModelViewerTexture|null> {\n      const currentGLTF = this[$currentGLTF];\n      const texture: Texture = await new Promise<Texture>(\n          (resolve) => this[$textureLoader].load(uri, resolve));\n      if (!currentGLTF || !texture) {\n        return null;\n      }\n      // Applies default settings.\n      texture.encoding = sRGBEncoding;\n      texture.wrapS = RepeatWrapping;\n      texture.wrapT = RepeatWrapping;\n      texture.flipY = false;\n      texture.userData.mimeType = type;\n\n      return new ModelViewerTexture(this[$getOnUpdateMethod](), texture);\n    }\n\n    async updated(changedProperties: Map<string, any>) {\n      super.updated(changedProperties);\n\n      if (changedProperties.has('variantName')) {\n        const updateVariantProgress = this[$progressTracker].beginActivity();\n        updateVariantProgress(0.1);\n        const model = this[$model];\n        const {variantName} = this;\n\n        if (model != null) {\n          await model[$switchVariant](variantName!);\n          this[$needsRender]();\n          this.dispatchEvent(new CustomEvent('variant-applied'));\n        }\n        updateVariantProgress(1.0);\n      }\n\n      if (changedProperties.has('orientation') ||\n          changedProperties.has('scale')) {\n        if (!this.loaded) {\n          return;\n        }\n        const scene = this[$scene];\n        scene.applyTransform();\n        scene.updateBoundingBox();\n        scene.updateShadow();\n        this[$renderer].arRenderer.onUpdateScene();\n        this[$needsRender]();\n      }\n    }\n\n    [$onModelLoad]() {\n      super[$onModelLoad]();\n\n      const {currentGLTF} = this[$scene];\n\n      if (currentGLTF != null) {\n        const {correlatedSceneGraph} = currentGLTF;\n\n        if (correlatedSceneGraph != null &&\n            currentGLTF !== this[$currentGLTF]) {\n          this[$model] =\n              new Model(correlatedSceneGraph, this[$getOnUpdateMethod]());\n          this[$originalGltfJson] =\n              JSON.parse(JSON.stringify(correlatedSceneGraph.gltf));\n        }\n\n        // KHR_materials_variants extension spec:\n        // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_variants\n\n        if ('variants' in currentGLTF.userData) {\n          this.requestUpdate('variantName');\n        }\n      }\n\n      this[$currentGLTF] = currentGLTF;\n    }\n\n    /** @export */\n    async exportScene(options?: SceneExportOptions): Promise<Blob> {\n      const scene = this[$scene];\n      return new Promise<Blob>(async (resolve, reject) => {\n        // Defaults\n        const opts = {\n          binary: true,\n          onlyVisible: true,\n          maxTextureSize: Infinity,\n          includeCustomExtensions: false,\n          forceIndices: false\n        } as GLTFExporterOptions;\n\n        Object.assign(opts, options);\n        // Not configurable\n        opts.animations = scene.animations;\n        opts.truncateDrawRange = true;\n\n        const shadow = scene.shadow;\n        let visible = false;\n        // Remove shadow from export\n        if (shadow != null) {\n          visible = shadow.visible;\n          shadow.visible = false;\n        }\n\n        await this[$model]![$prepareVariantsForExport]();\n\n        const exporter =\n            (new GLTFExporter() as any)\n                .register(\n                    (writer: any) =>\n                        new GLTFExporterMaterialsVariantsExtension(writer));\n        exporter.parse(\n            scene.model,\n            (gltf: object) => {\n              return resolve(new Blob(\n                  [opts.binary ? gltf as Blob : JSON.stringify(gltf)], {\n                    type: opts.binary ? 'application/octet-stream' :\n                                        'application/json'\n                  }));\n            },\n            () => {\n              return reject('glTF export failed');\n            },\n            opts);\n\n        if (shadow != null) {\n          shadow.visible = visible;\n        }\n      });\n    }\n\n    materialFromPoint(pixelX: number, pixelY: number): Material|null {\n      const scene = this[$scene];\n      const ndcCoords = scene.getNDC(pixelX, pixelY);\n      scene.raycaster.setFromCamera(ndcCoords, scene.getCamera());\n\n      return this[$model]![$materialFromPoint](scene.raycaster);\n    }\n  }\n\n  return SceneGraphModelViewerElement;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}