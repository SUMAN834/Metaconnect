{"ast":null,"code":"import { _ as _classPrivateMethodInitSpec, a as _classPrivateMethodGet } from '../../../../dist/classPrivateMethodGet-ea199cc3.browser.esm.js';\nimport { _ as _classPrivateFieldInitSpec, b as _classPrivateFieldGet, a as _classPrivateFieldSet } from '../../../../dist/classPrivateFieldSet-a5db7c83.browser.esm.js';\nimport { _ as _defineProperty } from '../../../../dist/defineProperty-c8ecdc07.browser.esm.js';\nimport { utils, providers } from 'ethers';\nimport { w as walletIds } from '../../../../dist/walletIds-e41b240b.browser.esm.js';\nimport { g as getValidPublicRPCUrl } from '../../../../dist/url-bc88b2b6.browser.esm.js';\nimport { W as WagmiConnector } from '../../../../dist/WagmiConnector-2f14002d.browser.esm.js';\nimport { U as UserRejectedRequestError, S as SwitchChainError } from '../../../../dist/errors-d961f852.browser.esm.js';\nimport '@thirdweb-dev/chains';\nimport 'eventemitter3';\nconst chainsToRequest = new Set([1, 137, 10, 42161, 56]);\nconst NAMESPACE = \"eip155\";\nconst REQUESTED_CHAINS_KEY = \"wagmi.requestedChains\";\nconst ADD_ETH_CHAIN_METHOD = \"wallet_addEthereumChain\";\nconst LAST_USED_CHAIN_ID = \"last-used-chain-id\";\nvar _provider = /*#__PURE__*/new WeakMap();\nvar _initProviderPromise = /*#__PURE__*/new WeakMap();\nvar _storage = /*#__PURE__*/new WeakMap();\nvar _createProvider = /*#__PURE__*/new WeakSet();\nvar _initProvider = /*#__PURE__*/new WeakSet();\nvar _isChainsStale = /*#__PURE__*/new WeakSet();\nvar _removeListeners = /*#__PURE__*/new WeakSet();\nvar _setRequestedChainsIds = /*#__PURE__*/new WeakSet();\nvar _getRequestedChainsIds = /*#__PURE__*/new WeakSet();\nvar _getNamespaceChainsIds = /*#__PURE__*/new WeakSet();\nvar _getNamespaceMethods = /*#__PURE__*/new WeakSet();\nclass WalletConnectConnector extends WagmiConnector {\n  constructor(config) {\n    super({\n      ...config,\n      options: {\n        isNewChainsStale: true,\n        ...config.options\n      }\n    });\n    _classPrivateMethodInitSpec(this, _getNamespaceMethods);\n    _classPrivateMethodInitSpec(this, _getNamespaceChainsIds);\n    _classPrivateMethodInitSpec(this, _getRequestedChainsIds);\n    _classPrivateMethodInitSpec(this, _setRequestedChainsIds);\n    _classPrivateMethodInitSpec(this, _removeListeners);\n    /**\n     * Checks if the target chains match the chains that were\n     * initially requested by the connector for the WalletConnect session.\n     * If there is a mismatch, this means that the chains on the connector\n     * are considered stale, and need to be revalidated at a later point (via\n     * connection).\n     *\n     * There may be a scenario where a dapp adds a chain to the\n     * connector later on, however, this chain will not have been approved or rejected\n     * by the wallet. In this case, the chain is considered stale.\n     *\n     * There are exceptions however:\n     * -  If the wallet supports dynamic chain addition via `eth_addEthereumChain`,\n     *    then the chain is not considered stale.\n     * -  If the `isNewChainsStale` flag is falsy on the connector, then the chain is\n     *    not considered stale.\n     *\n     * For the above cases, chain validation occurs dynamically when the user\n     * attempts to switch chain.\n     *\n     * Also check that dapp supports at least 1 chain from previously approved session.\n     */\n    _classPrivateMethodInitSpec(this, _isChainsStale);\n    _classPrivateMethodInitSpec(this, _initProvider);\n    _classPrivateMethodInitSpec(this, _createProvider);\n    _defineProperty(this, \"id\", walletIds.walletConnect);\n    _defineProperty(this, \"name\", \"WalletConnect\");\n    _defineProperty(this, \"ready\", true);\n    _classPrivateFieldInitSpec(this, _provider, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _initProviderPromise, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _storage, {\n      writable: true,\n      value: void 0\n    });\n    _defineProperty(this, \"onAccountsChanged\", accounts => {\n      if (accounts.length === 0) {\n        this.emit(\"disconnect\");\n      } else {\n        if (accounts[0]) {\n          this.emit(\"change\", {\n            account: utils.getAddress(accounts[0])\n          });\n        }\n      }\n    });\n    _defineProperty(this, \"onChainChanged\", async chainId => {\n      const id = Number(chainId);\n      const unsupported = this.isChainUnsupported(id);\n      await _classPrivateFieldGet(this, _storage).setItem(LAST_USED_CHAIN_ID, String(chainId));\n      this.emit(\"change\", {\n        chain: {\n          id,\n          unsupported\n        }\n      });\n    });\n    _defineProperty(this, \"onDisconnect\", async () => {\n      await _classPrivateMethodGet(this, _setRequestedChainsIds, _setRequestedChainsIds2).call(this, []);\n      await _classPrivateFieldGet(this, _storage).removeItem(LAST_USED_CHAIN_ID);\n      this.emit(\"disconnect\");\n    });\n    _defineProperty(this, \"onDisplayUri\", uri => {\n      this.emit(\"message\", {\n        type: \"display_uri\",\n        data: uri\n      });\n    });\n    _defineProperty(this, \"onConnect\", () => {\n      this.emit(\"connect\", {\n        provider: _classPrivateFieldGet(this, _provider)\n      });\n    });\n    _classPrivateFieldSet(this, _storage, config.options.storage);\n    _classPrivateMethodGet(this, _createProvider, _createProvider2).call(this);\n    this.filteredChains = this.chains.length > 50 ? this.chains.filter(c => {\n      return chainsToRequest.has(c.chainId);\n    }) : this.chains;\n  }\n  async connect() {\n    let {\n      chainId: chainIdP,\n      pairingTopic\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    try {\n      let targetChainId = chainIdP;\n      if (!targetChainId) {\n        const lastUsedChainIdStr = await _classPrivateFieldGet(this, _storage).getItem(LAST_USED_CHAIN_ID);\n        const lastUsedChainId = lastUsedChainIdStr ? parseInt(lastUsedChainIdStr) : undefined;\n        if (lastUsedChainId && !this.isChainUnsupported(lastUsedChainId)) {\n          targetChainId = lastUsedChainId;\n        } else {\n          targetChainId = this.filteredChains[0]?.chainId;\n        }\n      }\n      if (!targetChainId) {\n        throw new Error(\"No chains found on connector.\");\n      }\n      const provider = await this.getProvider();\n      this.setupListeners();\n      const isChainsStale = await _classPrivateMethodGet(this, _isChainsStale, _isChainsStale2).call(this);\n\n      // If there is an active session with stale chains, disconnect the current session.\n      if (provider.session && isChainsStale) {\n        await provider.disconnect();\n      }\n\n      // If there no active session, or the chains are stale, connect.\n      if (!provider.session || isChainsStale) {\n        const optionalChains = this.filteredChains.filter(chain => chain.chainId !== targetChainId).map(optionalChain => optionalChain.chainId);\n        this.emit(\"message\", {\n          type: \"connecting\"\n        });\n        await provider.connect({\n          pairingTopic,\n          chains: [targetChainId],\n          optionalChains: optionalChains.length > 0 ? optionalChains : [targetChainId]\n        });\n        await _classPrivateMethodGet(this, _setRequestedChainsIds, _setRequestedChainsIds2).call(this, this.filteredChains.map(_ref => {\n          let {\n            chainId\n          } = _ref;\n          return chainId;\n        }));\n      }\n\n      // If session exists and chains are authorized, enable provider for required chain\n      const accounts = await provider.enable();\n      if (!accounts[0]) {\n        throw new Error(\"No accounts found on provider.\");\n      }\n      const account = utils.getAddress(accounts[0]);\n      const id = await this.getChainId();\n      const unsupported = this.isChainUnsupported(id);\n      return {\n        account,\n        chain: {\n          id,\n          unsupported\n        },\n        provider: new providers.Web3Provider(provider)\n      };\n    } catch (error) {\n      if (/user rejected/i.test(error?.message)) {\n        throw new UserRejectedRequestError(error);\n      }\n      throw error;\n    }\n  }\n  async disconnect() {\n    const cleanup = () => {\n      if (typeof localStorage === \"undefined\") {\n        return;\n      }\n      for (const key in localStorage) {\n        if (key.startsWith(\"wc@2\")) {\n          localStorage.removeItem(key);\n        }\n      }\n    };\n    cleanup();\n    const provider = await this.getProvider();\n    const disconnectProvider = async () => {\n      try {\n        await provider.disconnect();\n      } catch (error) {\n        if (!/No matching key/i.test(error.message)) {\n          throw error;\n        }\n      } finally {\n        _classPrivateMethodGet(this, _removeListeners, _removeListeners2).call(this);\n        await _classPrivateMethodGet(this, _setRequestedChainsIds, _setRequestedChainsIds2).call(this, []);\n        cleanup();\n      }\n    };\n    disconnectProvider();\n  }\n  async getAccount() {\n    const {\n      accounts\n    } = await this.getProvider();\n    if (!accounts[0]) {\n      throw new Error(\"No accounts found on provider.\");\n    }\n    return utils.getAddress(accounts[0]);\n  }\n  async getChainId() {\n    const {\n      chainId\n    } = await this.getProvider();\n    return chainId;\n  }\n  async getProvider() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!_classPrivateFieldGet(this, _provider)) {\n      await _classPrivateMethodGet(this, _createProvider, _createProvider2).call(this);\n    }\n    if (chainId) {\n      await this.switchChain(chainId);\n    }\n    if (!_classPrivateFieldGet(this, _provider)) {\n      throw new Error(\"No provider found.\");\n    }\n    return _classPrivateFieldGet(this, _provider);\n  }\n  async getSigner() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const [provider, account] = await Promise.all([this.getProvider({\n      chainId\n    }), this.getAccount()]);\n    return new providers.Web3Provider(provider, chainId).getSigner(account);\n  }\n  async isAuthorized() {\n    try {\n      const [account, provider] = await Promise.all([this.getAccount(), this.getProvider()]);\n      const isChainsStale = await _classPrivateMethodGet(this, _isChainsStale, _isChainsStale2).call(this);\n\n      // If an account does not exist on the session, then the connector is unauthorized.\n      if (!account) {\n        return false;\n      }\n\n      // If the chains are stale on the session, then the connector is unauthorized.\n      if (isChainsStale && provider.session) {\n        try {\n          await provider.disconnect();\n        } catch {} // eslint-disable-line no-empty\n        return false;\n      }\n      return true;\n    } catch {\n      return false;\n    }\n  }\n  async switchChain(chainId) {\n    const chain = this.chains.find(chain_ => chain_.chainId === chainId);\n    if (!chain) {\n      throw new SwitchChainError(`Chain with ID: ${chainId}, not found on connector.`);\n    }\n    try {\n      const provider = await this.getProvider();\n      const namespaceChains = _classPrivateMethodGet(this, _getNamespaceChainsIds, _getNamespaceChainsIds2).call(this);\n      const namespaceMethods = _classPrivateMethodGet(this, _getNamespaceMethods, _getNamespaceMethods2).call(this);\n      const isChainApproved = namespaceChains.includes(chainId);\n      if (!isChainApproved && namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {\n        const firstExplorer = chain.explorers && chain.explorers[0];\n        const blockExplorerUrls = firstExplorer ? {\n          blockExplorerUrls: [firstExplorer.url]\n        } : {};\n        await provider.request({\n          method: ADD_ETH_CHAIN_METHOD,\n          params: [{\n            chainId: utils.hexValue(chain.chainId),\n            chainName: chain.name,\n            nativeCurrency: chain.nativeCurrency,\n            rpcUrls: getValidPublicRPCUrl(chain),\n            // no clientId on purpose\n            ...blockExplorerUrls\n          }]\n        });\n        const requestedChains = await _classPrivateMethodGet(this, _getRequestedChainsIds, _getRequestedChainsIds2).call(this);\n        requestedChains.push(chainId);\n        await _classPrivateMethodGet(this, _setRequestedChainsIds, _setRequestedChainsIds2).call(this, requestedChains);\n      }\n      await provider.request({\n        method: \"wallet_switchEthereumChain\",\n        params: [{\n          chainId: utils.hexValue(chainId)\n        }]\n      });\n      return chain;\n    } catch (error) {\n      const message = typeof error === \"string\" ? error : error?.message;\n      if (/user rejected request/i.test(message)) {\n        throw new UserRejectedRequestError(error);\n      }\n      throw new SwitchChainError(error);\n    }\n  }\n  async setupListeners() {\n    if (!_classPrivateFieldGet(this, _provider)) {\n      return;\n    }\n    _classPrivateMethodGet(this, _removeListeners, _removeListeners2).call(this);\n    _classPrivateFieldGet(this, _provider).on(\"accountsChanged\", this.onAccountsChanged);\n    _classPrivateFieldGet(this, _provider).on(\"chainChanged\", this.onChainChanged);\n    _classPrivateFieldGet(this, _provider).on(\"disconnect\", this.onDisconnect);\n    _classPrivateFieldGet(this, _provider).on(\"session_delete\", this.onDisconnect);\n    _classPrivateFieldGet(this, _provider).on(\"display_uri\", this.onDisplayUri);\n    _classPrivateFieldGet(this, _provider).on(\"connect\", this.onConnect);\n  }\n}\nasync function _createProvider2() {\n  if (!_classPrivateFieldGet(this, _initProviderPromise) && \"object\" !== \"undefined\") {\n    _classPrivateFieldSet(this, _initProviderPromise, _classPrivateMethodGet(this, _initProvider, _initProvider2).call(this));\n  }\n  return _classPrivateFieldGet(this, _initProviderPromise);\n}\nasync function _initProvider2() {\n  const {\n    default: EthereumProvider,\n    OPTIONAL_EVENTS,\n    OPTIONAL_METHODS\n  } = await import('@walletconnect/ethereum-provider');\n  const [defaultChain, ...optionalChains] = this.filteredChains.map(_ref2 => {\n    let {\n      chainId\n    } = _ref2;\n    return chainId;\n  });\n  if (defaultChain) {\n    // EthereumProvider populates & deduplicates required methods and events internally\n    _classPrivateFieldSet(this, _provider, await EthereumProvider.init({\n      showQrModal: this.options.qrcode !== false,\n      projectId: this.options.projectId,\n      optionalMethods: OPTIONAL_METHODS,\n      optionalEvents: OPTIONAL_EVENTS,\n      chains: [defaultChain],\n      optionalChains: optionalChains,\n      metadata: {\n        name: this.options.dappMetadata.name,\n        description: this.options.dappMetadata.description || \"\",\n        url: this.options.dappMetadata.url,\n        icons: [this.options.dappMetadata.logoUrl || \"\"]\n      },\n      rpcMap: Object.fromEntries(this.filteredChains.map(chain => [chain.chainId, chain.rpc[0] || \"\" // TODO: handle chain.rpc being empty array\n      ])),\n\n      qrModalOptions: this.options.qrModalOptions\n    }));\n  }\n}\nasync function _isChainsStale2() {\n  const namespaceMethods = _classPrivateMethodGet(this, _getNamespaceMethods, _getNamespaceMethods2).call(this);\n  if (namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {\n    return false;\n  }\n  if (!this.options.isNewChainsStale) {\n    return false;\n  }\n  const requestedChains = await _classPrivateMethodGet(this, _getRequestedChainsIds, _getRequestedChainsIds2).call(this);\n  const connectorChains = this.filteredChains.map(_ref3 => {\n    let {\n      chainId\n    } = _ref3;\n    return chainId;\n  });\n  const namespaceChains = _classPrivateMethodGet(this, _getNamespaceChainsIds, _getNamespaceChainsIds2).call(this);\n  if (namespaceChains.length && !namespaceChains.some(id => connectorChains.includes(id))) {\n    return false;\n  }\n  return !connectorChains.every(id => requestedChains.includes(id));\n}\nfunction _removeListeners2() {\n  if (!_classPrivateFieldGet(this, _provider)) {\n    return;\n  }\n  _classPrivateFieldGet(this, _provider).removeListener(\"accountsChanged\", this.onAccountsChanged);\n  _classPrivateFieldGet(this, _provider).removeListener(\"chainChanged\", this.onChainChanged);\n  _classPrivateFieldGet(this, _provider).removeListener(\"disconnect\", this.onDisconnect);\n  _classPrivateFieldGet(this, _provider).removeListener(\"session_delete\", this.onDisconnect);\n  _classPrivateFieldGet(this, _provider).removeListener(\"display_uri\", this.onDisplayUri);\n  _classPrivateFieldGet(this, _provider).removeListener(\"connect\", this.onConnect);\n}\nasync function _setRequestedChainsIds2(chains) {\n  await _classPrivateFieldGet(this, _storage).setItem(REQUESTED_CHAINS_KEY, JSON.stringify(chains));\n}\nasync function _getRequestedChainsIds2() {\n  const data = await _classPrivateFieldGet(this, _storage).getItem(REQUESTED_CHAINS_KEY);\n  return data ? JSON.parse(data) : [];\n}\nfunction _getNamespaceChainsIds2() {\n  if (!_classPrivateFieldGet(this, _provider)) {\n    return [];\n  }\n  const chainIds = _classPrivateFieldGet(this, _provider).session?.namespaces[NAMESPACE]?.chains?.map(chain => parseInt(chain.split(\":\")[1] || \"\"));\n  return chainIds ?? [];\n}\nfunction _getNamespaceMethods2() {\n  if (!_classPrivateFieldGet(this, _provider)) {\n    return [];\n  }\n  const methods = _classPrivateFieldGet(this, _provider).session?.namespaces[NAMESPACE]?.methods;\n  return methods ?? [];\n}\nexport { WalletConnectConnector };","map":{"version":3,"names":["_","_classPrivateMethodInitSpec","a","_classPrivateMethodGet","_classPrivateFieldInitSpec","b","_classPrivateFieldGet","_classPrivateFieldSet","_defineProperty","utils","providers","w","walletIds","g","getValidPublicRPCUrl","W","WagmiConnector","U","UserRejectedRequestError","S","SwitchChainError","chainsToRequest","Set","NAMESPACE","REQUESTED_CHAINS_KEY","ADD_ETH_CHAIN_METHOD","LAST_USED_CHAIN_ID","_provider","WeakMap","_initProviderPromise","_storage","_createProvider","WeakSet","_initProvider","_isChainsStale","_removeListeners","_setRequestedChainsIds","_getRequestedChainsIds","_getNamespaceChainsIds","_getNamespaceMethods","WalletConnectConnector","constructor","config","options","isNewChainsStale","walletConnect","writable","value","accounts","length","emit","account","getAddress","chainId","id","Number","unsupported","isChainUnsupported","setItem","String","chain","_setRequestedChainsIds2","call","removeItem","uri","type","data","provider","storage","_createProvider2","filteredChains","chains","filter","c","has","connect","chainIdP","pairingTopic","arguments","undefined","targetChainId","lastUsedChainIdStr","getItem","lastUsedChainId","parseInt","Error","getProvider","setupListeners","isChainsStale","_isChainsStale2","session","disconnect","optionalChains","map","optionalChain","_ref","enable","getChainId","Web3Provider","error","test","message","cleanup","localStorage","key","startsWith","disconnectProvider","_removeListeners2","getAccount","switchChain","getSigner","Promise","all","isAuthorized","find","chain_","namespaceChains","_getNamespaceChainsIds2","namespaceMethods","_getNamespaceMethods2","isChainApproved","includes","firstExplorer","explorers","blockExplorerUrls","url","request","method","params","hexValue","chainName","name","nativeCurrency","rpcUrls","requestedChains","_getRequestedChainsIds2","push","on","onAccountsChanged","onChainChanged","onDisconnect","onDisplayUri","onConnect","_initProvider2","default","EthereumProvider","OPTIONAL_EVENTS","OPTIONAL_METHODS","defaultChain","_ref2","init","showQrModal","qrcode","projectId","optionalMethods","optionalEvents","metadata","dappMetadata","description","icons","logoUrl","rpcMap","Object","fromEntries","rpc","qrModalOptions","connectorChains","_ref3","some","every","removeListener","JSON","stringify","parse","chainIds","namespaces","split","methods"],"sources":["C:/Users/SUMAN K/meta_transfer/node_modules/@thirdweb-dev/wallets/evm/connectors/wallet-connect/dist/thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm.js"],"sourcesContent":["import { _ as _classPrivateMethodInitSpec, a as _classPrivateMethodGet } from '../../../../dist/classPrivateMethodGet-ea199cc3.browser.esm.js';\nimport { _ as _classPrivateFieldInitSpec, b as _classPrivateFieldGet, a as _classPrivateFieldSet } from '../../../../dist/classPrivateFieldSet-a5db7c83.browser.esm.js';\nimport { _ as _defineProperty } from '../../../../dist/defineProperty-c8ecdc07.browser.esm.js';\nimport { utils, providers } from 'ethers';\nimport { w as walletIds } from '../../../../dist/walletIds-e41b240b.browser.esm.js';\nimport { g as getValidPublicRPCUrl } from '../../../../dist/url-bc88b2b6.browser.esm.js';\nimport { W as WagmiConnector } from '../../../../dist/WagmiConnector-2f14002d.browser.esm.js';\nimport { U as UserRejectedRequestError, S as SwitchChainError } from '../../../../dist/errors-d961f852.browser.esm.js';\nimport '@thirdweb-dev/chains';\nimport 'eventemitter3';\n\nconst chainsToRequest = new Set([1, 137, 10, 42161, 56]);\nconst NAMESPACE = \"eip155\";\nconst REQUESTED_CHAINS_KEY = \"wagmi.requestedChains\";\nconst ADD_ETH_CHAIN_METHOD = \"wallet_addEthereumChain\";\nconst LAST_USED_CHAIN_ID = \"last-used-chain-id\";\nvar _provider = /*#__PURE__*/new WeakMap();\nvar _initProviderPromise = /*#__PURE__*/new WeakMap();\nvar _storage = /*#__PURE__*/new WeakMap();\nvar _createProvider = /*#__PURE__*/new WeakSet();\nvar _initProvider = /*#__PURE__*/new WeakSet();\nvar _isChainsStale = /*#__PURE__*/new WeakSet();\nvar _removeListeners = /*#__PURE__*/new WeakSet();\nvar _setRequestedChainsIds = /*#__PURE__*/new WeakSet();\nvar _getRequestedChainsIds = /*#__PURE__*/new WeakSet();\nvar _getNamespaceChainsIds = /*#__PURE__*/new WeakSet();\nvar _getNamespaceMethods = /*#__PURE__*/new WeakSet();\nclass WalletConnectConnector extends WagmiConnector {\n  constructor(config) {\n    super({\n      ...config,\n      options: {\n        isNewChainsStale: true,\n        ...config.options\n      }\n    });\n    _classPrivateMethodInitSpec(this, _getNamespaceMethods);\n    _classPrivateMethodInitSpec(this, _getNamespaceChainsIds);\n    _classPrivateMethodInitSpec(this, _getRequestedChainsIds);\n    _classPrivateMethodInitSpec(this, _setRequestedChainsIds);\n    _classPrivateMethodInitSpec(this, _removeListeners);\n    /**\n     * Checks if the target chains match the chains that were\n     * initially requested by the connector for the WalletConnect session.\n     * If there is a mismatch, this means that the chains on the connector\n     * are considered stale, and need to be revalidated at a later point (via\n     * connection).\n     *\n     * There may be a scenario where a dapp adds a chain to the\n     * connector later on, however, this chain will not have been approved or rejected\n     * by the wallet. In this case, the chain is considered stale.\n     *\n     * There are exceptions however:\n     * -  If the wallet supports dynamic chain addition via `eth_addEthereumChain`,\n     *    then the chain is not considered stale.\n     * -  If the `isNewChainsStale` flag is falsy on the connector, then the chain is\n     *    not considered stale.\n     *\n     * For the above cases, chain validation occurs dynamically when the user\n     * attempts to switch chain.\n     *\n     * Also check that dapp supports at least 1 chain from previously approved session.\n     */\n    _classPrivateMethodInitSpec(this, _isChainsStale);\n    _classPrivateMethodInitSpec(this, _initProvider);\n    _classPrivateMethodInitSpec(this, _createProvider);\n    _defineProperty(this, \"id\", walletIds.walletConnect);\n    _defineProperty(this, \"name\", \"WalletConnect\");\n    _defineProperty(this, \"ready\", true);\n    _classPrivateFieldInitSpec(this, _provider, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _initProviderPromise, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _storage, {\n      writable: true,\n      value: void 0\n    });\n    _defineProperty(this, \"onAccountsChanged\", accounts => {\n      if (accounts.length === 0) {\n        this.emit(\"disconnect\");\n      } else {\n        if (accounts[0]) {\n          this.emit(\"change\", {\n            account: utils.getAddress(accounts[0])\n          });\n        }\n      }\n    });\n    _defineProperty(this, \"onChainChanged\", async chainId => {\n      const id = Number(chainId);\n      const unsupported = this.isChainUnsupported(id);\n      await _classPrivateFieldGet(this, _storage).setItem(LAST_USED_CHAIN_ID, String(chainId));\n      this.emit(\"change\", {\n        chain: {\n          id,\n          unsupported\n        }\n      });\n    });\n    _defineProperty(this, \"onDisconnect\", async () => {\n      await _classPrivateMethodGet(this, _setRequestedChainsIds, _setRequestedChainsIds2).call(this, []);\n      await _classPrivateFieldGet(this, _storage).removeItem(LAST_USED_CHAIN_ID);\n      this.emit(\"disconnect\");\n    });\n    _defineProperty(this, \"onDisplayUri\", uri => {\n      this.emit(\"message\", {\n        type: \"display_uri\",\n        data: uri\n      });\n    });\n    _defineProperty(this, \"onConnect\", () => {\n      this.emit(\"connect\", {\n        provider: _classPrivateFieldGet(this, _provider)\n      });\n    });\n    _classPrivateFieldSet(this, _storage, config.options.storage);\n    _classPrivateMethodGet(this, _createProvider, _createProvider2).call(this);\n    this.filteredChains = this.chains.length > 50 ? this.chains.filter(c => {\n      return chainsToRequest.has(c.chainId);\n    }) : this.chains;\n  }\n  async connect() {\n    let {\n      chainId: chainIdP,\n      pairingTopic\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    try {\n      let targetChainId = chainIdP;\n      if (!targetChainId) {\n        const lastUsedChainIdStr = await _classPrivateFieldGet(this, _storage).getItem(LAST_USED_CHAIN_ID);\n        const lastUsedChainId = lastUsedChainIdStr ? parseInt(lastUsedChainIdStr) : undefined;\n        if (lastUsedChainId && !this.isChainUnsupported(lastUsedChainId)) {\n          targetChainId = lastUsedChainId;\n        } else {\n          targetChainId = this.filteredChains[0]?.chainId;\n        }\n      }\n      if (!targetChainId) {\n        throw new Error(\"No chains found on connector.\");\n      }\n      const provider = await this.getProvider();\n      this.setupListeners();\n      const isChainsStale = await _classPrivateMethodGet(this, _isChainsStale, _isChainsStale2).call(this);\n\n      // If there is an active session with stale chains, disconnect the current session.\n      if (provider.session && isChainsStale) {\n        await provider.disconnect();\n      }\n\n      // If there no active session, or the chains are stale, connect.\n      if (!provider.session || isChainsStale) {\n        const optionalChains = this.filteredChains.filter(chain => chain.chainId !== targetChainId).map(optionalChain => optionalChain.chainId);\n        this.emit(\"message\", {\n          type: \"connecting\"\n        });\n        await provider.connect({\n          pairingTopic,\n          chains: [targetChainId],\n          optionalChains: optionalChains.length > 0 ? optionalChains : [targetChainId]\n        });\n        await _classPrivateMethodGet(this, _setRequestedChainsIds, _setRequestedChainsIds2).call(this, this.filteredChains.map(_ref => {\n          let {\n            chainId\n          } = _ref;\n          return chainId;\n        }));\n      }\n\n      // If session exists and chains are authorized, enable provider for required chain\n      const accounts = await provider.enable();\n      if (!accounts[0]) {\n        throw new Error(\"No accounts found on provider.\");\n      }\n      const account = utils.getAddress(accounts[0]);\n      const id = await this.getChainId();\n      const unsupported = this.isChainUnsupported(id);\n      return {\n        account,\n        chain: {\n          id,\n          unsupported\n        },\n        provider: new providers.Web3Provider(provider)\n      };\n    } catch (error) {\n      if (/user rejected/i.test(error?.message)) {\n        throw new UserRejectedRequestError(error);\n      }\n      throw error;\n    }\n  }\n  async disconnect() {\n    const cleanup = () => {\n      if (typeof localStorage === \"undefined\") {\n        return;\n      }\n      for (const key in localStorage) {\n        if (key.startsWith(\"wc@2\")) {\n          localStorage.removeItem(key);\n        }\n      }\n    };\n    cleanup();\n    const provider = await this.getProvider();\n    const disconnectProvider = async () => {\n      try {\n        await provider.disconnect();\n      } catch (error) {\n        if (!/No matching key/i.test(error.message)) {\n          throw error;\n        }\n      } finally {\n        _classPrivateMethodGet(this, _removeListeners, _removeListeners2).call(this);\n        await _classPrivateMethodGet(this, _setRequestedChainsIds, _setRequestedChainsIds2).call(this, []);\n        cleanup();\n      }\n    };\n    disconnectProvider();\n  }\n  async getAccount() {\n    const {\n      accounts\n    } = await this.getProvider();\n    if (!accounts[0]) {\n      throw new Error(\"No accounts found on provider.\");\n    }\n    return utils.getAddress(accounts[0]);\n  }\n  async getChainId() {\n    const {\n      chainId\n    } = await this.getProvider();\n    return chainId;\n  }\n  async getProvider() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!_classPrivateFieldGet(this, _provider)) {\n      await _classPrivateMethodGet(this, _createProvider, _createProvider2).call(this);\n    }\n    if (chainId) {\n      await this.switchChain(chainId);\n    }\n    if (!_classPrivateFieldGet(this, _provider)) {\n      throw new Error(\"No provider found.\");\n    }\n    return _classPrivateFieldGet(this, _provider);\n  }\n  async getSigner() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const [provider, account] = await Promise.all([this.getProvider({\n      chainId\n    }), this.getAccount()]);\n    return new providers.Web3Provider(provider, chainId).getSigner(account);\n  }\n  async isAuthorized() {\n    try {\n      const [account, provider] = await Promise.all([this.getAccount(), this.getProvider()]);\n      const isChainsStale = await _classPrivateMethodGet(this, _isChainsStale, _isChainsStale2).call(this);\n\n      // If an account does not exist on the session, then the connector is unauthorized.\n      if (!account) {\n        return false;\n      }\n\n      // If the chains are stale on the session, then the connector is unauthorized.\n      if (isChainsStale && provider.session) {\n        try {\n          await provider.disconnect();\n        } catch {} // eslint-disable-line no-empty\n        return false;\n      }\n      return true;\n    } catch {\n      return false;\n    }\n  }\n  async switchChain(chainId) {\n    const chain = this.chains.find(chain_ => chain_.chainId === chainId);\n    if (!chain) {\n      throw new SwitchChainError(`Chain with ID: ${chainId}, not found on connector.`);\n    }\n    try {\n      const provider = await this.getProvider();\n      const namespaceChains = _classPrivateMethodGet(this, _getNamespaceChainsIds, _getNamespaceChainsIds2).call(this);\n      const namespaceMethods = _classPrivateMethodGet(this, _getNamespaceMethods, _getNamespaceMethods2).call(this);\n      const isChainApproved = namespaceChains.includes(chainId);\n      if (!isChainApproved && namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {\n        const firstExplorer = chain.explorers && chain.explorers[0];\n        const blockExplorerUrls = firstExplorer ? {\n          blockExplorerUrls: [firstExplorer.url]\n        } : {};\n        await provider.request({\n          method: ADD_ETH_CHAIN_METHOD,\n          params: [{\n            chainId: utils.hexValue(chain.chainId),\n            chainName: chain.name,\n            nativeCurrency: chain.nativeCurrency,\n            rpcUrls: getValidPublicRPCUrl(chain),\n            // no clientId on purpose\n            ...blockExplorerUrls\n          }]\n        });\n        const requestedChains = await _classPrivateMethodGet(this, _getRequestedChainsIds, _getRequestedChainsIds2).call(this);\n        requestedChains.push(chainId);\n        await _classPrivateMethodGet(this, _setRequestedChainsIds, _setRequestedChainsIds2).call(this, requestedChains);\n      }\n      await provider.request({\n        method: \"wallet_switchEthereumChain\",\n        params: [{\n          chainId: utils.hexValue(chainId)\n        }]\n      });\n      return chain;\n    } catch (error) {\n      const message = typeof error === \"string\" ? error : error?.message;\n      if (/user rejected request/i.test(message)) {\n        throw new UserRejectedRequestError(error);\n      }\n      throw new SwitchChainError(error);\n    }\n  }\n  async setupListeners() {\n    if (!_classPrivateFieldGet(this, _provider)) {\n      return;\n    }\n    _classPrivateMethodGet(this, _removeListeners, _removeListeners2).call(this);\n    _classPrivateFieldGet(this, _provider).on(\"accountsChanged\", this.onAccountsChanged);\n    _classPrivateFieldGet(this, _provider).on(\"chainChanged\", this.onChainChanged);\n    _classPrivateFieldGet(this, _provider).on(\"disconnect\", this.onDisconnect);\n    _classPrivateFieldGet(this, _provider).on(\"session_delete\", this.onDisconnect);\n    _classPrivateFieldGet(this, _provider).on(\"display_uri\", this.onDisplayUri);\n    _classPrivateFieldGet(this, _provider).on(\"connect\", this.onConnect);\n  }\n}\nasync function _createProvider2() {\n  if (!_classPrivateFieldGet(this, _initProviderPromise) && \"object\" !== \"undefined\") {\n    _classPrivateFieldSet(this, _initProviderPromise, _classPrivateMethodGet(this, _initProvider, _initProvider2).call(this));\n  }\n  return _classPrivateFieldGet(this, _initProviderPromise);\n}\nasync function _initProvider2() {\n  const {\n    default: EthereumProvider,\n    OPTIONAL_EVENTS,\n    OPTIONAL_METHODS\n  } = await import('@walletconnect/ethereum-provider');\n  const [defaultChain, ...optionalChains] = this.filteredChains.map(_ref2 => {\n    let {\n      chainId\n    } = _ref2;\n    return chainId;\n  });\n  if (defaultChain) {\n    // EthereumProvider populates & deduplicates required methods and events internally\n    _classPrivateFieldSet(this, _provider, await EthereumProvider.init({\n      showQrModal: this.options.qrcode !== false,\n      projectId: this.options.projectId,\n      optionalMethods: OPTIONAL_METHODS,\n      optionalEvents: OPTIONAL_EVENTS,\n      chains: [defaultChain],\n      optionalChains: optionalChains,\n      metadata: {\n        name: this.options.dappMetadata.name,\n        description: this.options.dappMetadata.description || \"\",\n        url: this.options.dappMetadata.url,\n        icons: [this.options.dappMetadata.logoUrl || \"\"]\n      },\n      rpcMap: Object.fromEntries(this.filteredChains.map(chain => [chain.chainId, chain.rpc[0] || \"\" // TODO: handle chain.rpc being empty array\n      ])),\n\n      qrModalOptions: this.options.qrModalOptions\n    }));\n  }\n}\nasync function _isChainsStale2() {\n  const namespaceMethods = _classPrivateMethodGet(this, _getNamespaceMethods, _getNamespaceMethods2).call(this);\n  if (namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {\n    return false;\n  }\n  if (!this.options.isNewChainsStale) {\n    return false;\n  }\n  const requestedChains = await _classPrivateMethodGet(this, _getRequestedChainsIds, _getRequestedChainsIds2).call(this);\n  const connectorChains = this.filteredChains.map(_ref3 => {\n    let {\n      chainId\n    } = _ref3;\n    return chainId;\n  });\n  const namespaceChains = _classPrivateMethodGet(this, _getNamespaceChainsIds, _getNamespaceChainsIds2).call(this);\n  if (namespaceChains.length && !namespaceChains.some(id => connectorChains.includes(id))) {\n    return false;\n  }\n  return !connectorChains.every(id => requestedChains.includes(id));\n}\nfunction _removeListeners2() {\n  if (!_classPrivateFieldGet(this, _provider)) {\n    return;\n  }\n  _classPrivateFieldGet(this, _provider).removeListener(\"accountsChanged\", this.onAccountsChanged);\n  _classPrivateFieldGet(this, _provider).removeListener(\"chainChanged\", this.onChainChanged);\n  _classPrivateFieldGet(this, _provider).removeListener(\"disconnect\", this.onDisconnect);\n  _classPrivateFieldGet(this, _provider).removeListener(\"session_delete\", this.onDisconnect);\n  _classPrivateFieldGet(this, _provider).removeListener(\"display_uri\", this.onDisplayUri);\n  _classPrivateFieldGet(this, _provider).removeListener(\"connect\", this.onConnect);\n}\nasync function _setRequestedChainsIds2(chains) {\n  await _classPrivateFieldGet(this, _storage).setItem(REQUESTED_CHAINS_KEY, JSON.stringify(chains));\n}\nasync function _getRequestedChainsIds2() {\n  const data = await _classPrivateFieldGet(this, _storage).getItem(REQUESTED_CHAINS_KEY);\n  return data ? JSON.parse(data) : [];\n}\nfunction _getNamespaceChainsIds2() {\n  if (!_classPrivateFieldGet(this, _provider)) {\n    return [];\n  }\n  const chainIds = _classPrivateFieldGet(this, _provider).session?.namespaces[NAMESPACE]?.chains?.map(chain => parseInt(chain.split(\":\")[1] || \"\"));\n  return chainIds ?? [];\n}\nfunction _getNamespaceMethods2() {\n  if (!_classPrivateFieldGet(this, _provider)) {\n    return [];\n  }\n  const methods = _classPrivateFieldGet(this, _provider).session?.namespaces[NAMESPACE]?.methods;\n  return methods ?? [];\n}\n\nexport { WalletConnectConnector };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}