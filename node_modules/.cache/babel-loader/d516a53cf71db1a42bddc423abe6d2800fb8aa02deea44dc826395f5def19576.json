{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Web3Provider = exports.Provider = void 0;\nconst ethers_1 = require(\"ethers\");\nvar Formatter = ethers_1.providers.Formatter;\nconst web_1 = require(\"@ethersproject/web\");\nconst typechain_1 = require(\"../typechain\");\nconst types_1 = require(\"./types\");\nconst utils_1 = require(\"./utils\");\nconst signer_1 = require(\"./signer\");\nlet defaultFormatter = null;\nclass Provider extends ethers_1.ethers.providers.JsonRpcProvider {\n  constructor(url, network) {\n    super(url, network);\n    this.pollingInterval = 500;\n    const blockTag = this.formatter.blockTag.bind(this.formatter);\n    this.formatter.blockTag = tag => {\n      if (tag == 'committed' || tag == 'finalized') {\n        return tag;\n      }\n      return blockTag(tag);\n    };\n    this.contractAddresses = {};\n    this.formatter.transaction = utils_1.parseTransaction;\n  }\n  async getTransactionReceipt(transactionHash) {\n    await this.getNetwork();\n    transactionHash = await transactionHash;\n    const params = {\n      transactionHash: this.formatter.hash(transactionHash, true)\n    };\n    return (0, web_1.poll)(async () => {\n      const result = await this.perform('getTransactionReceipt', params);\n      if (result == null) {\n        if (this._emitted['t:' + transactionHash] == null) {\n          return null;\n        }\n        return undefined;\n      }\n      if (result.blockNumber == null && result.status != null && ethers_1.BigNumber.from(result.status).isZero()) {\n        // transaction is rejected in the state-keeper\n        return {\n          ...this.formatter.receipt({\n            ...result,\n            confirmations: 1,\n            blockNumber: 0,\n            blockHash: ethers_1.ethers.constants.HashZero\n          }),\n          blockNumber: null,\n          blockHash: null,\n          l1BatchNumber: null,\n          l1BatchTxIndex: null\n        };\n      }\n      if (result.blockHash == null) {\n        // receipt is not ready\n        return undefined;\n      } else {\n        const receipt = this.formatter.receipt(result);\n        if (receipt.blockNumber == null) {\n          receipt.confirmations = 0;\n        } else if (receipt.confirmations == null) {\n          const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n          // Add the confirmations using the fast block number (pessimistic)\n          let confirmations = blockNumber - receipt.blockNumber + 1;\n          if (confirmations <= 0) {\n            confirmations = 1;\n          }\n          receipt.confirmations = confirmations;\n        }\n        return receipt;\n      }\n    }, {\n      oncePoll: this\n    });\n  }\n  async getBlock(blockHashOrBlockTag) {\n    return this._getBlock(blockHashOrBlockTag, false);\n  }\n  async getBlockWithTransactions(blockHashOrBlockTag) {\n    return this._getBlock(blockHashOrBlockTag, true);\n  }\n  static getFormatter() {\n    if (defaultFormatter == null) {\n      defaultFormatter = new Formatter();\n      const number = defaultFormatter.number.bind(defaultFormatter);\n      const boolean = defaultFormatter.boolean.bind(defaultFormatter);\n      const hash = defaultFormatter.hash.bind(defaultFormatter);\n      const address = defaultFormatter.address.bind(defaultFormatter);\n      defaultFormatter.formats.receiptLog.l1BatchNumber = Formatter.allowNull(number);\n      defaultFormatter.formats.l2Tol1Log = {\n        blockNumber: number,\n        blockHash: hash,\n        l1BatchNumber: Formatter.allowNull(number),\n        transactionIndex: number,\n        shardId: number,\n        isService: boolean,\n        sender: address,\n        key: hash,\n        value: hash,\n        transactionHash: hash,\n        logIndex: number\n      };\n      defaultFormatter.formats.receipt.l1BatchNumber = Formatter.allowNull(number);\n      defaultFormatter.formats.receipt.l1BatchTxIndex = Formatter.allowNull(number);\n      defaultFormatter.formats.receipt.l2ToL1Logs = Formatter.arrayOf(value => Formatter.check(defaultFormatter.formats.l2Tol1Log, value));\n      defaultFormatter.formats.block.l1BatchNumber = Formatter.allowNull(number);\n      defaultFormatter.formats.block.l1BatchTimestamp = Formatter.allowNull(number);\n      defaultFormatter.formats.blockWithTransactions.l1BatchNumber = Formatter.allowNull(number);\n      defaultFormatter.formats.blockWithTransactions.l1BatchTimestamp = Formatter.allowNull(number);\n      defaultFormatter.formats.transaction.l1BatchNumber = Formatter.allowNull(number);\n      defaultFormatter.formats.transaction.l1BatchTxIndex = Formatter.allowNull(number);\n      defaultFormatter.formats.filterLog.l1BatchNumber = Formatter.allowNull(number);\n    }\n    return defaultFormatter;\n  }\n  async getBalance(address, blockTag, tokenAddress) {\n    const tag = this.formatter.blockTag(blockTag);\n    if (tokenAddress == null || (0, utils_1.isETH)(tokenAddress)) {\n      // requesting ETH balance\n      return await super.getBalance(address, tag);\n    } else {\n      try {\n        let token = typechain_1.IERC20MetadataFactory.connect(tokenAddress, this);\n        return await token.balanceOf(address, {\n          blockTag: tag\n        });\n      } catch {\n        return ethers_1.BigNumber.from(0);\n      }\n    }\n  }\n  async l2TokenAddress(token) {\n    if (token == utils_1.ETH_ADDRESS) {\n      return utils_1.ETH_ADDRESS;\n    } else {\n      const erc20BridgeAddress = (await this.getDefaultBridgeAddresses()).erc20L2;\n      const erc20Bridge = typechain_1.IL2BridgeFactory.connect(erc20BridgeAddress, this);\n      return await erc20Bridge.l2TokenAddress(token);\n    }\n  }\n  async l1TokenAddress(token) {\n    if (token == utils_1.ETH_ADDRESS) {\n      return utils_1.ETH_ADDRESS;\n    } else {\n      const erc20BridgeAddress = (await this.getDefaultBridgeAddresses()).erc20L2;\n      const erc20Bridge = typechain_1.IL2BridgeFactory.connect(erc20BridgeAddress, this);\n      return await erc20Bridge.l1TokenAddress(token);\n    }\n  }\n  // This function is used when formatting requests for\n  // eth_call and eth_estimateGas. We override it here\n  // because we have extra stuff to serialize (customData).\n  // This function is for internal use only.\n  static hexlifyTransaction(transaction, allowExtra) {\n    var _a;\n    const result = ethers_1.ethers.providers.JsonRpcProvider.hexlifyTransaction(transaction, {\n      ...allowExtra,\n      customData: true,\n      from: true\n    });\n    if (transaction.customData == null) {\n      return result;\n    }\n    result.eip712Meta = {\n      gasPerPubdata: ethers_1.utils.hexValue((_a = transaction.customData.gasPerPubdata) !== null && _a !== void 0 ? _a : 0)\n    };\n    transaction.type = utils_1.EIP712_TX_TYPE;\n    if (transaction.customData.factoryDeps) {\n      // @ts-ignore\n      result.eip712Meta.factoryDeps = transaction.customData.factoryDeps.map(dep =>\n      // TODO (SMA-1605): we arraify instead of hexlifying because server expects Vec<u8>.\n      //  We should change deserialization there.\n      Array.from(ethers_1.utils.arrayify(dep)));\n    }\n    if (transaction.customData.paymasterParams) {\n      // @ts-ignore\n      result.eip712Meta.paymasterParams = {\n        paymaster: ethers_1.utils.hexlify(transaction.customData.paymasterParams.paymaster),\n        paymasterInput: Array.from(ethers_1.utils.arrayify(transaction.customData.paymasterParams.paymasterInput))\n      };\n    }\n    return result;\n  }\n  async estimateGas(transaction) {\n    await this.getNetwork();\n    const params = await ethers_1.utils.resolveProperties({\n      transaction: this._getTransactionRequest(transaction)\n    });\n    if (transaction.customData != null) {\n      // @ts-ignore\n      params.transaction.customData = transaction.customData;\n    }\n    const result = await this.perform('estimateGas', params);\n    try {\n      return ethers_1.BigNumber.from(result);\n    } catch (error) {\n      throw new Error(`bad result from backend (estimateGas): ${result}`);\n    }\n  }\n  async estimateGasL1(transaction) {\n    await this.getNetwork();\n    const params = await ethers_1.utils.resolveProperties({\n      transaction: this._getTransactionRequest(transaction)\n    });\n    if (transaction.customData != null) {\n      // @ts-ignore\n      params.transaction.customData = transaction.customData;\n    }\n    const result = await this.send('zks_estimateGasL1ToL2', [Provider.hexlifyTransaction(params.transaction, {\n      from: true\n    })]);\n    try {\n      return ethers_1.BigNumber.from(result);\n    } catch (error) {\n      throw new Error(`bad result from backend (zks_estimateGasL1ToL2): ${result}`);\n    }\n  }\n  async getGasPrice(token) {\n    const params = token ? [token] : [];\n    const price = await this.send('eth_gasPrice', params);\n    return ethers_1.BigNumber.from(price);\n  }\n  async getMessageProof(blockNumber, sender, messageHash, logIndex) {\n    return await this.send('zks_getL2ToL1MsgProof', [ethers_1.BigNumber.from(blockNumber).toNumber(), sender, ethers_1.ethers.utils.hexlify(messageHash), logIndex]);\n  }\n  async getLogProof(txHash, index) {\n    return await this.send('zks_getL2ToL1LogProof', [ethers_1.ethers.utils.hexlify(txHash), index]);\n  }\n  async getL1BatchBlockRange(l1BatchNumber) {\n    const range = await this.send('zks_getL1BatchBlockRange', [l1BatchNumber]);\n    if (range == null) {\n      return null;\n    }\n    return [parseInt(range[0], 16), parseInt(range[1], 16)];\n  }\n  async getMainContractAddress() {\n    if (!this.contractAddresses.mainContract) {\n      this.contractAddresses.mainContract = await this.send('zks_getMainContract', []);\n    }\n    return this.contractAddresses.mainContract;\n  }\n  async getTestnetPaymasterAddress() {\n    // Unlike contract's addresses, the testnet paymaster is not cached, since it can be trivially changed\n    // on the fly by the server and should not be relied to be constant\n    return await this.send('zks_getTestnetPaymaster', []);\n  }\n  async getDefaultBridgeAddresses() {\n    if (!this.contractAddresses.erc20BridgeL1) {\n      let addresses = await this.send('zks_getBridgeContracts', []);\n      this.contractAddresses.erc20BridgeL1 = addresses.l1Erc20DefaultBridge;\n      this.contractAddresses.erc20BridgeL2 = addresses.l2Erc20DefaultBridge;\n    }\n    return {\n      erc20L1: this.contractAddresses.erc20BridgeL1,\n      erc20L2: this.contractAddresses.erc20BridgeL2\n    };\n  }\n  async getConfirmedTokens(start = 0, limit = 255) {\n    const tokens = await this.send('zks_getConfirmedTokens', [start, limit]);\n    return tokens.map(token => ({\n      address: token.l2Address,\n      ...token\n    }));\n  }\n  async getTokenPrice(token) {\n    return await this.send('zks_getTokenPrice', [token]);\n  }\n  async getAllAccountBalances(address) {\n    let balances = await this.send('zks_getAllAccountBalances', [address]);\n    for (let token in balances) {\n      balances[token] = ethers_1.BigNumber.from(balances[token]);\n    }\n    return balances;\n  }\n  async l1ChainId() {\n    const res = await this.send('zks_L1ChainId', []);\n    return ethers_1.BigNumber.from(res).toNumber();\n  }\n  async getL1BatchNumber() {\n    const number = await this.send('zks_L1BatchNumber', []);\n    return ethers_1.BigNumber.from(number).toNumber();\n  }\n  async getBlockDetails(number) {\n    return await this.send('zks_getBlockDetails', [number]);\n  }\n  async getTransactionDetails(txHash) {\n    return await this.send('zks_getTransactionDetails', [txHash]);\n  }\n  async getWithdrawTx(transaction) {\n    var _a, _b, _c;\n    var _d;\n    const {\n      ...tx\n    } = transaction;\n    if (tx.to == null && tx.from == null) {\n      throw new Error('withdrawal target address is undefined');\n    }\n    (_a = tx.to) !== null && _a !== void 0 ? _a : tx.to = tx.from;\n    (_b = tx.overrides) !== null && _b !== void 0 ? _b : tx.overrides = {};\n    (_c = (_d = tx.overrides).from) !== null && _c !== void 0 ? _c : _d.from = tx.from;\n    if ((0, utils_1.isETH)(tx.token)) {\n      if (!tx.overrides.value) {\n        tx.overrides.value = tx.amount;\n      }\n      const passedValue = ethers_1.BigNumber.from(tx.overrides.value);\n      if (!passedValue.eq(tx.amount)) {\n        // To avoid users shooting themselves into the foot, we will always use the amount to withdraw\n        // as the value\n        throw new Error('The tx.value is not equal to the value withdrawn');\n      }\n      const ethL2Token = typechain_1.IEthTokenFactory.connect(utils_1.L2_ETH_TOKEN_ADDRESS, this);\n      return ethL2Token.populateTransaction.withdraw(tx.to, tx.overrides);\n    }\n    if (tx.bridgeAddress == null) {\n      const bridges = await this.getDefaultBridgeAddresses();\n      tx.bridgeAddress = bridges.erc20L2;\n    }\n    const bridge = typechain_1.IL2BridgeFactory.connect(tx.bridgeAddress, this);\n    return bridge.populateTransaction.withdraw(tx.to, tx.token, tx.amount, tx.overrides);\n  }\n  async estimateGasWithdraw(transaction) {\n    const withdrawTx = await this.getWithdrawTx(transaction);\n    return await this.estimateGas(withdrawTx);\n  }\n  async getTransferTx(transaction) {\n    var _a, _b;\n    var _c;\n    const {\n      ...tx\n    } = transaction;\n    (_a = tx.overrides) !== null && _a !== void 0 ? _a : tx.overrides = {};\n    (_b = (_c = tx.overrides).from) !== null && _b !== void 0 ? _b : _c.from = tx.from;\n    if (tx.token == null || tx.token == utils_1.ETH_ADDRESS) {\n      return {\n        ...(await ethers_1.ethers.utils.resolveProperties(tx.overrides)),\n        to: tx.to,\n        value: tx.amount\n      };\n    } else {\n      const token = typechain_1.IERC20MetadataFactory.connect(tx.token, this);\n      return await token.populateTransaction.transfer(tx.to, tx.amount, tx.overrides);\n    }\n  }\n  async estimateGasTransfer(transaction) {\n    const transferTx = await this.getTransferTx(transaction);\n    return await this.estimateGas(transferTx);\n  }\n  static getDefaultProvider() {\n    // TODO (SMA-1606): Add different urls for different networks.\n    return new Provider(process.env.ZKSYNC_WEB3_API_URL || 'http://localhost:3050');\n  }\n  async newFilter(filter) {\n    filter = await filter;\n    const id = await this.send('eth_newFilter', [this._prepareFilter(filter)]);\n    return ethers_1.BigNumber.from(id);\n  }\n  async newBlockFilter() {\n    const id = await this.send('eth_newBlockFilter', []);\n    return ethers_1.BigNumber.from(id);\n  }\n  async newPendingTransactionsFilter() {\n    const id = await this.send('eth_newPendingTransactionFilter', []);\n    return ethers_1.BigNumber.from(id);\n  }\n  async getFilterChanges(idx) {\n    const logs = await this.send('eth_getFilterChanges', [idx.toHexString()]);\n    return typeof logs[0] === 'string' ? logs : this._parseLogs(logs);\n  }\n  async getLogs(filter = {}) {\n    filter = await filter;\n    const logs = await this.send('eth_getLogs', [this._prepareFilter(filter)]);\n    return this._parseLogs(logs);\n  }\n  _parseLogs(logs) {\n    return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n  }\n  _prepareFilter(filter) {\n    return {\n      ...filter,\n      fromBlock: filter.fromBlock == null ? null : this.formatter.blockTag(filter.fromBlock),\n      toBlock: filter.fromBlock == null ? null : this.formatter.blockTag(filter.toBlock)\n    };\n  }\n  _wrapTransaction(tx, hash) {\n    const response = super._wrapTransaction(tx, hash);\n    response.waitFinalize = async () => {\n      const receipt = await response.wait();\n      while (true) {\n        const block = await this.getBlock('finalized');\n        if (receipt.blockNumber <= block.number) {\n          return await this.getTransactionReceipt(receipt.transactionHash);\n        } else {\n          await (0, utils_1.sleep)(this.pollingInterval);\n        }\n      }\n    };\n    return response;\n  }\n  // This is inefficient. Status should probably be indicated in the transaction receipt.\n  async getTransactionStatus(txHash) {\n    const tx = await this.getTransaction(txHash);\n    if (tx == null) {\n      return types_1.TransactionStatus.NotFound;\n    }\n    if (tx.blockNumber == null) {\n      return types_1.TransactionStatus.Processing;\n    }\n    const verifiedBlock = await this.getBlock('finalized');\n    if (tx.blockNumber <= verifiedBlock.number) {\n      return types_1.TransactionStatus.Finalized;\n    }\n    return types_1.TransactionStatus.Committed;\n  }\n  async getTransaction(hash) {\n    hash = await hash;\n    const tx = await super.getTransaction(hash);\n    return tx ? this._wrapTransaction(tx, hash) : null;\n  }\n  async sendTransaction(transaction) {\n    return await super.sendTransaction(transaction);\n  }\n  async getL2TransactionFromPriorityOp(l1TxResponse) {\n    const receipt = await l1TxResponse.wait();\n    const l2Hash = (0, utils_1.getL2HashFromPriorityOp)(receipt, await this.getMainContractAddress());\n    let status = null;\n    do {\n      status = await this.getTransactionStatus(l2Hash);\n      await (0, utils_1.sleep)(this.pollingInterval);\n    } while (status == types_1.TransactionStatus.NotFound);\n    return await this.getTransaction(l2Hash);\n  }\n  async getPriorityOpResponse(l1TxResponse) {\n    const l2Response = {\n      ...l1TxResponse\n    };\n    l2Response.waitL1Commit = l2Response.wait;\n    l2Response.wait = async () => {\n      const l2Tx = await this.getL2TransactionFromPriorityOp(l1TxResponse);\n      return await l2Tx.wait();\n    };\n    l2Response.waitFinalize = async () => {\n      const l2Tx = await this.getL2TransactionFromPriorityOp(l1TxResponse);\n      return await l2Tx.waitFinalize();\n    };\n    return l2Response;\n  }\n  async getContractAccountInfo(address) {\n    const deployerContract = new ethers_1.Contract(utils_1.CONTRACT_DEPLOYER_ADDRESS, utils_1.CONTRACT_DEPLOYER, this);\n    const data = await deployerContract.getAccountInfo(address);\n    return {\n      supportedAAVersion: data.supportedAAVersion,\n      nonceOrdering: data.nonceOrdering\n    };\n  }\n  // TODO (EVM-3): support refundRecipient for fee estimation\n  async estimateL1ToL2Execute(transaction) {\n    var _a, _b;\n    (_a = transaction.gasPerPubdataByte) !== null && _a !== void 0 ? _a : transaction.gasPerPubdataByte = utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT;\n    // If the `from` address is not provided, we use a random address, because\n    // due to storage slot aggregation, the gas estimation will depend on the address\n    // and so estimation for the zero address may be smaller than for the sender.\n    (_b = transaction.caller) !== null && _b !== void 0 ? _b : transaction.caller = ethers_1.ethers.Wallet.createRandom().address;\n    const customData = {\n      gasPerPubdataByte: transaction.gasPerPubdataByte\n    };\n    if (transaction.factoryDeps) {\n      Object.assign(customData, {\n        factoryDeps: transaction.factoryDeps\n      });\n    }\n    const fee = await this.estimateGasL1({\n      from: transaction.caller,\n      data: transaction.calldata,\n      to: transaction.contractAddress,\n      value: transaction.l2Value,\n      customData\n    });\n    return fee;\n  }\n}\nexports.Provider = Provider;\nclass Web3Provider extends Provider {\n  constructor(provider, network) {\n    if (provider == null) {\n      throw new Error('missing provider');\n    }\n    if (!provider.request) {\n      throw new Error('provider must implement eip-1193');\n    }\n    let path = provider.host || provider.path || (provider.isMetaMask ? 'metamask' : 'eip-1193:');\n    super(path, network);\n    this.provider = provider;\n  }\n  async send(method, params) {\n    params !== null && params !== void 0 ? params : params = [];\n    // Metamask complains about eth_sign (and on some versions hangs)\n    if (method == 'eth_sign' && (this.provider.isMetaMask || this.provider.isStatus)) {\n      // https://github.com/ethereum/go-ethereum/wiki/Management-APIs#personal_sign\n      method = 'personal_sign';\n      params = [params[1], params[0]];\n    }\n    return await this.provider.request({\n      method,\n      params\n    });\n  }\n  getSigner(addressOrIndex) {\n    return signer_1.Signer.from(super.getSigner(addressOrIndex));\n  }\n  async estimateGas(transaction) {\n    const gas = await super.estimateGas(transaction);\n    const metamaskMinimum = ethers_1.BigNumber.from(21000);\n    const isEIP712 = transaction.customData != null || transaction.type == utils_1.EIP712_TX_TYPE;\n    return gas.gt(metamaskMinimum) || isEIP712 ? gas : metamaskMinimum;\n  }\n}\nexports.Web3Provider = Web3Provider;","map":{"version":3,"names":["Object","defineProperty","exports","value","Web3Provider","Provider","ethers_1","require","Formatter","providers","web_1","typechain_1","types_1","utils_1","signer_1","defaultFormatter","ethers","JsonRpcProvider","constructor","url","network","pollingInterval","blockTag","formatter","bind","tag","contractAddresses","transaction","parseTransaction","getTransactionReceipt","transactionHash","getNetwork","params","hash","poll","result","perform","_emitted","undefined","blockNumber","status","BigNumber","from","isZero","receipt","confirmations","blockHash","constants","HashZero","l1BatchNumber","l1BatchTxIndex","_getInternalBlockNumber","oncePoll","getBlock","blockHashOrBlockTag","_getBlock","getBlockWithTransactions","getFormatter","number","boolean","address","formats","receiptLog","allowNull","l2Tol1Log","transactionIndex","shardId","isService","sender","key","logIndex","l2ToL1Logs","arrayOf","check","block","l1BatchTimestamp","blockWithTransactions","filterLog","getBalance","tokenAddress","isETH","token","IERC20MetadataFactory","connect","balanceOf","l2TokenAddress","ETH_ADDRESS","erc20BridgeAddress","getDefaultBridgeAddresses","erc20L2","erc20Bridge","IL2BridgeFactory","l1TokenAddress","hexlifyTransaction","allowExtra","_a","customData","eip712Meta","gasPerPubdata","utils","hexValue","type","EIP712_TX_TYPE","factoryDeps","map","dep","Array","arrayify","paymasterParams","paymaster","hexlify","paymasterInput","estimateGas","resolveProperties","_getTransactionRequest","error","Error","estimateGasL1","send","getGasPrice","price","getMessageProof","messageHash","toNumber","getLogProof","txHash","index","getL1BatchBlockRange","range","parseInt","getMainContractAddress","mainContract","getTestnetPaymasterAddress","erc20BridgeL1","addresses","l1Erc20DefaultBridge","erc20BridgeL2","l2Erc20DefaultBridge","erc20L1","getConfirmedTokens","start","limit","tokens","l2Address","getTokenPrice","getAllAccountBalances","balances","l1ChainId","res","getL1BatchNumber","getBlockDetails","getTransactionDetails","getWithdrawTx","_b","_c","_d","tx","to","overrides","amount","passedValue","eq","ethL2Token","IEthTokenFactory","L2_ETH_TOKEN_ADDRESS","populateTransaction","withdraw","bridgeAddress","bridges","bridge","estimateGasWithdraw","withdrawTx","getTransferTx","transfer","estimateGasTransfer","transferTx","getDefaultProvider","process","env","ZKSYNC_WEB3_API_URL","newFilter","filter","id","_prepareFilter","newBlockFilter","newPendingTransactionsFilter","getFilterChanges","idx","logs","toHexString","_parseLogs","getLogs","fromBlock","toBlock","_wrapTransaction","response","waitFinalize","wait","sleep","getTransactionStatus","getTransaction","TransactionStatus","NotFound","Processing","verifiedBlock","Finalized","Committed","sendTransaction","getL2TransactionFromPriorityOp","l1TxResponse","l2Hash","getL2HashFromPriorityOp","getPriorityOpResponse","l2Response","waitL1Commit","l2Tx","getContractAccountInfo","deployerContract","Contract","CONTRACT_DEPLOYER_ADDRESS","CONTRACT_DEPLOYER","data","getAccountInfo","supportedAAVersion","nonceOrdering","estimateL1ToL2Execute","gasPerPubdataByte","REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT","caller","Wallet","createRandom","assign","fee","calldata","contractAddress","l2Value","provider","request","path","host","isMetaMask","method","isStatus","getSigner","addressOrIndex","Signer","gas","metamaskMinimum","isEIP712","gt"],"sources":["C:/Users/SUMAN K/meta_transfer/node_modules/zksync-web3/build/src/provider.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Web3Provider = exports.Provider = void 0;\nconst ethers_1 = require(\"ethers\");\nvar Formatter = ethers_1.providers.Formatter;\nconst web_1 = require(\"@ethersproject/web\");\nconst typechain_1 = require(\"../typechain\");\nconst types_1 = require(\"./types\");\nconst utils_1 = require(\"./utils\");\nconst signer_1 = require(\"./signer\");\nlet defaultFormatter = null;\nclass Provider extends ethers_1.ethers.providers.JsonRpcProvider {\n    constructor(url, network) {\n        super(url, network);\n        this.pollingInterval = 500;\n        const blockTag = this.formatter.blockTag.bind(this.formatter);\n        this.formatter.blockTag = (tag) => {\n            if (tag == 'committed' || tag == 'finalized') {\n                return tag;\n            }\n            return blockTag(tag);\n        };\n        this.contractAddresses = {};\n        this.formatter.transaction = utils_1.parseTransaction;\n    }\n    async getTransactionReceipt(transactionHash) {\n        await this.getNetwork();\n        transactionHash = await transactionHash;\n        const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n        return (0, web_1.poll)(async () => {\n            const result = await this.perform('getTransactionReceipt', params);\n            if (result == null) {\n                if (this._emitted['t:' + transactionHash] == null) {\n                    return null;\n                }\n                return undefined;\n            }\n            if (result.blockNumber == null && result.status != null && ethers_1.BigNumber.from(result.status).isZero()) {\n                // transaction is rejected in the state-keeper\n                return {\n                    ...this.formatter.receipt({\n                        ...result,\n                        confirmations: 1,\n                        blockNumber: 0,\n                        blockHash: ethers_1.ethers.constants.HashZero\n                    }),\n                    blockNumber: null,\n                    blockHash: null,\n                    l1BatchNumber: null,\n                    l1BatchTxIndex: null\n                };\n            }\n            if (result.blockHash == null) {\n                // receipt is not ready\n                return undefined;\n            }\n            else {\n                const receipt = this.formatter.receipt(result);\n                if (receipt.blockNumber == null) {\n                    receipt.confirmations = 0;\n                }\n                else if (receipt.confirmations == null) {\n                    const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                    // Add the confirmations using the fast block number (pessimistic)\n                    let confirmations = blockNumber - receipt.blockNumber + 1;\n                    if (confirmations <= 0) {\n                        confirmations = 1;\n                    }\n                    receipt.confirmations = confirmations;\n                }\n                return receipt;\n            }\n        }, { oncePoll: this });\n    }\n    async getBlock(blockHashOrBlockTag) {\n        return this._getBlock(blockHashOrBlockTag, false);\n    }\n    async getBlockWithTransactions(blockHashOrBlockTag) {\n        return this._getBlock(blockHashOrBlockTag, true);\n    }\n    static getFormatter() {\n        if (defaultFormatter == null) {\n            defaultFormatter = new Formatter();\n            const number = defaultFormatter.number.bind(defaultFormatter);\n            const boolean = defaultFormatter.boolean.bind(defaultFormatter);\n            const hash = defaultFormatter.hash.bind(defaultFormatter);\n            const address = defaultFormatter.address.bind(defaultFormatter);\n            defaultFormatter.formats.receiptLog.l1BatchNumber = Formatter.allowNull(number);\n            defaultFormatter.formats.l2Tol1Log = {\n                blockNumber: number,\n                blockHash: hash,\n                l1BatchNumber: Formatter.allowNull(number),\n                transactionIndex: number,\n                shardId: number,\n                isService: boolean,\n                sender: address,\n                key: hash,\n                value: hash,\n                transactionHash: hash,\n                logIndex: number\n            };\n            defaultFormatter.formats.receipt.l1BatchNumber = Formatter.allowNull(number);\n            defaultFormatter.formats.receipt.l1BatchTxIndex = Formatter.allowNull(number);\n            defaultFormatter.formats.receipt.l2ToL1Logs = Formatter.arrayOf((value) => Formatter.check(defaultFormatter.formats.l2Tol1Log, value));\n            defaultFormatter.formats.block.l1BatchNumber = Formatter.allowNull(number);\n            defaultFormatter.formats.block.l1BatchTimestamp = Formatter.allowNull(number);\n            defaultFormatter.formats.blockWithTransactions.l1BatchNumber = Formatter.allowNull(number);\n            defaultFormatter.formats.blockWithTransactions.l1BatchTimestamp = Formatter.allowNull(number);\n            defaultFormatter.formats.transaction.l1BatchNumber = Formatter.allowNull(number);\n            defaultFormatter.formats.transaction.l1BatchTxIndex = Formatter.allowNull(number);\n            defaultFormatter.formats.filterLog.l1BatchNumber = Formatter.allowNull(number);\n        }\n        return defaultFormatter;\n    }\n    async getBalance(address, blockTag, tokenAddress) {\n        const tag = this.formatter.blockTag(blockTag);\n        if (tokenAddress == null || (0, utils_1.isETH)(tokenAddress)) {\n            // requesting ETH balance\n            return await super.getBalance(address, tag);\n        }\n        else {\n            try {\n                let token = typechain_1.IERC20MetadataFactory.connect(tokenAddress, this);\n                return await token.balanceOf(address, { blockTag: tag });\n            }\n            catch {\n                return ethers_1.BigNumber.from(0);\n            }\n        }\n    }\n    async l2TokenAddress(token) {\n        if (token == utils_1.ETH_ADDRESS) {\n            return utils_1.ETH_ADDRESS;\n        }\n        else {\n            const erc20BridgeAddress = (await this.getDefaultBridgeAddresses()).erc20L2;\n            const erc20Bridge = typechain_1.IL2BridgeFactory.connect(erc20BridgeAddress, this);\n            return await erc20Bridge.l2TokenAddress(token);\n        }\n    }\n    async l1TokenAddress(token) {\n        if (token == utils_1.ETH_ADDRESS) {\n            return utils_1.ETH_ADDRESS;\n        }\n        else {\n            const erc20BridgeAddress = (await this.getDefaultBridgeAddresses()).erc20L2;\n            const erc20Bridge = typechain_1.IL2BridgeFactory.connect(erc20BridgeAddress, this);\n            return await erc20Bridge.l1TokenAddress(token);\n        }\n    }\n    // This function is used when formatting requests for\n    // eth_call and eth_estimateGas. We override it here\n    // because we have extra stuff to serialize (customData).\n    // This function is for internal use only.\n    static hexlifyTransaction(transaction, allowExtra) {\n        var _a;\n        const result = ethers_1.ethers.providers.JsonRpcProvider.hexlifyTransaction(transaction, {\n            ...allowExtra,\n            customData: true,\n            from: true\n        });\n        if (transaction.customData == null) {\n            return result;\n        }\n        result.eip712Meta = {\n            gasPerPubdata: ethers_1.utils.hexValue((_a = transaction.customData.gasPerPubdata) !== null && _a !== void 0 ? _a : 0)\n        };\n        transaction.type = utils_1.EIP712_TX_TYPE;\n        if (transaction.customData.factoryDeps) {\n            // @ts-ignore\n            result.eip712Meta.factoryDeps = transaction.customData.factoryDeps.map((dep) => \n            // TODO (SMA-1605): we arraify instead of hexlifying because server expects Vec<u8>.\n            //  We should change deserialization there.\n            Array.from(ethers_1.utils.arrayify(dep)));\n        }\n        if (transaction.customData.paymasterParams) {\n            // @ts-ignore\n            result.eip712Meta.paymasterParams = {\n                paymaster: ethers_1.utils.hexlify(transaction.customData.paymasterParams.paymaster),\n                paymasterInput: Array.from(ethers_1.utils.arrayify(transaction.customData.paymasterParams.paymasterInput))\n            };\n        }\n        return result;\n    }\n    async estimateGas(transaction) {\n        await this.getNetwork();\n        const params = await ethers_1.utils.resolveProperties({\n            transaction: this._getTransactionRequest(transaction)\n        });\n        if (transaction.customData != null) {\n            // @ts-ignore\n            params.transaction.customData = transaction.customData;\n        }\n        const result = await this.perform('estimateGas', params);\n        try {\n            return ethers_1.BigNumber.from(result);\n        }\n        catch (error) {\n            throw new Error(`bad result from backend (estimateGas): ${result}`);\n        }\n    }\n    async estimateGasL1(transaction) {\n        await this.getNetwork();\n        const params = await ethers_1.utils.resolveProperties({\n            transaction: this._getTransactionRequest(transaction)\n        });\n        if (transaction.customData != null) {\n            // @ts-ignore\n            params.transaction.customData = transaction.customData;\n        }\n        const result = await this.send('zks_estimateGasL1ToL2', [\n            Provider.hexlifyTransaction(params.transaction, { from: true })\n        ]);\n        try {\n            return ethers_1.BigNumber.from(result);\n        }\n        catch (error) {\n            throw new Error(`bad result from backend (zks_estimateGasL1ToL2): ${result}`);\n        }\n    }\n    async getGasPrice(token) {\n        const params = token ? [token] : [];\n        const price = await this.send('eth_gasPrice', params);\n        return ethers_1.BigNumber.from(price);\n    }\n    async getMessageProof(blockNumber, sender, messageHash, logIndex) {\n        return await this.send('zks_getL2ToL1MsgProof', [\n            ethers_1.BigNumber.from(blockNumber).toNumber(),\n            sender,\n            ethers_1.ethers.utils.hexlify(messageHash),\n            logIndex\n        ]);\n    }\n    async getLogProof(txHash, index) {\n        return await this.send('zks_getL2ToL1LogProof', [ethers_1.ethers.utils.hexlify(txHash), index]);\n    }\n    async getL1BatchBlockRange(l1BatchNumber) {\n        const range = await this.send('zks_getL1BatchBlockRange', [l1BatchNumber]);\n        if (range == null) {\n            return null;\n        }\n        return [parseInt(range[0], 16), parseInt(range[1], 16)];\n    }\n    async getMainContractAddress() {\n        if (!this.contractAddresses.mainContract) {\n            this.contractAddresses.mainContract = await this.send('zks_getMainContract', []);\n        }\n        return this.contractAddresses.mainContract;\n    }\n    async getTestnetPaymasterAddress() {\n        // Unlike contract's addresses, the testnet paymaster is not cached, since it can be trivially changed\n        // on the fly by the server and should not be relied to be constant\n        return await this.send('zks_getTestnetPaymaster', []);\n    }\n    async getDefaultBridgeAddresses() {\n        if (!this.contractAddresses.erc20BridgeL1) {\n            let addresses = await this.send('zks_getBridgeContracts', []);\n            this.contractAddresses.erc20BridgeL1 = addresses.l1Erc20DefaultBridge;\n            this.contractAddresses.erc20BridgeL2 = addresses.l2Erc20DefaultBridge;\n        }\n        return {\n            erc20L1: this.contractAddresses.erc20BridgeL1,\n            erc20L2: this.contractAddresses.erc20BridgeL2\n        };\n    }\n    async getConfirmedTokens(start = 0, limit = 255) {\n        const tokens = await this.send('zks_getConfirmedTokens', [start, limit]);\n        return tokens.map((token) => ({ address: token.l2Address, ...token }));\n    }\n    async getTokenPrice(token) {\n        return await this.send('zks_getTokenPrice', [token]);\n    }\n    async getAllAccountBalances(address) {\n        let balances = await this.send('zks_getAllAccountBalances', [address]);\n        for (let token in balances) {\n            balances[token] = ethers_1.BigNumber.from(balances[token]);\n        }\n        return balances;\n    }\n    async l1ChainId() {\n        const res = await this.send('zks_L1ChainId', []);\n        return ethers_1.BigNumber.from(res).toNumber();\n    }\n    async getL1BatchNumber() {\n        const number = await this.send('zks_L1BatchNumber', []);\n        return ethers_1.BigNumber.from(number).toNumber();\n    }\n    async getBlockDetails(number) {\n        return await this.send('zks_getBlockDetails', [number]);\n    }\n    async getTransactionDetails(txHash) {\n        return await this.send('zks_getTransactionDetails', [txHash]);\n    }\n    async getWithdrawTx(transaction) {\n        var _a, _b, _c;\n        var _d;\n        const { ...tx } = transaction;\n        if (tx.to == null && tx.from == null) {\n            throw new Error('withdrawal target address is undefined');\n        }\n        (_a = tx.to) !== null && _a !== void 0 ? _a : (tx.to = tx.from);\n        (_b = tx.overrides) !== null && _b !== void 0 ? _b : (tx.overrides = {});\n        (_c = (_d = tx.overrides).from) !== null && _c !== void 0 ? _c : (_d.from = tx.from);\n        if ((0, utils_1.isETH)(tx.token)) {\n            if (!tx.overrides.value) {\n                tx.overrides.value = tx.amount;\n            }\n            const passedValue = ethers_1.BigNumber.from(tx.overrides.value);\n            if (!passedValue.eq(tx.amount)) {\n                // To avoid users shooting themselves into the foot, we will always use the amount to withdraw\n                // as the value\n                throw new Error('The tx.value is not equal to the value withdrawn');\n            }\n            const ethL2Token = typechain_1.IEthTokenFactory.connect(utils_1.L2_ETH_TOKEN_ADDRESS, this);\n            return ethL2Token.populateTransaction.withdraw(tx.to, tx.overrides);\n        }\n        if (tx.bridgeAddress == null) {\n            const bridges = await this.getDefaultBridgeAddresses();\n            tx.bridgeAddress = bridges.erc20L2;\n        }\n        const bridge = typechain_1.IL2BridgeFactory.connect(tx.bridgeAddress, this);\n        return bridge.populateTransaction.withdraw(tx.to, tx.token, tx.amount, tx.overrides);\n    }\n    async estimateGasWithdraw(transaction) {\n        const withdrawTx = await this.getWithdrawTx(transaction);\n        return await this.estimateGas(withdrawTx);\n    }\n    async getTransferTx(transaction) {\n        var _a, _b;\n        var _c;\n        const { ...tx } = transaction;\n        (_a = tx.overrides) !== null && _a !== void 0 ? _a : (tx.overrides = {});\n        (_b = (_c = tx.overrides).from) !== null && _b !== void 0 ? _b : (_c.from = tx.from);\n        if (tx.token == null || tx.token == utils_1.ETH_ADDRESS) {\n            return {\n                ...(await ethers_1.ethers.utils.resolveProperties(tx.overrides)),\n                to: tx.to,\n                value: tx.amount\n            };\n        }\n        else {\n            const token = typechain_1.IERC20MetadataFactory.connect(tx.token, this);\n            return await token.populateTransaction.transfer(tx.to, tx.amount, tx.overrides);\n        }\n    }\n    async estimateGasTransfer(transaction) {\n        const transferTx = await this.getTransferTx(transaction);\n        return await this.estimateGas(transferTx);\n    }\n    static getDefaultProvider() {\n        // TODO (SMA-1606): Add different urls for different networks.\n        return new Provider(process.env.ZKSYNC_WEB3_API_URL || 'http://localhost:3050');\n    }\n    async newFilter(filter) {\n        filter = await filter;\n        const id = await this.send('eth_newFilter', [this._prepareFilter(filter)]);\n        return ethers_1.BigNumber.from(id);\n    }\n    async newBlockFilter() {\n        const id = await this.send('eth_newBlockFilter', []);\n        return ethers_1.BigNumber.from(id);\n    }\n    async newPendingTransactionsFilter() {\n        const id = await this.send('eth_newPendingTransactionFilter', []);\n        return ethers_1.BigNumber.from(id);\n    }\n    async getFilterChanges(idx) {\n        const logs = await this.send('eth_getFilterChanges', [idx.toHexString()]);\n        return typeof logs[0] === 'string' ? logs : this._parseLogs(logs);\n    }\n    async getLogs(filter = {}) {\n        filter = await filter;\n        const logs = await this.send('eth_getLogs', [this._prepareFilter(filter)]);\n        return this._parseLogs(logs);\n    }\n    _parseLogs(logs) {\n        return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n    }\n    _prepareFilter(filter) {\n        return {\n            ...filter,\n            fromBlock: filter.fromBlock == null ? null : this.formatter.blockTag(filter.fromBlock),\n            toBlock: filter.fromBlock == null ? null : this.formatter.blockTag(filter.toBlock)\n        };\n    }\n    _wrapTransaction(tx, hash) {\n        const response = super._wrapTransaction(tx, hash);\n        response.waitFinalize = async () => {\n            const receipt = await response.wait();\n            while (true) {\n                const block = await this.getBlock('finalized');\n                if (receipt.blockNumber <= block.number) {\n                    return await this.getTransactionReceipt(receipt.transactionHash);\n                }\n                else {\n                    await (0, utils_1.sleep)(this.pollingInterval);\n                }\n            }\n        };\n        return response;\n    }\n    // This is inefficient. Status should probably be indicated in the transaction receipt.\n    async getTransactionStatus(txHash) {\n        const tx = await this.getTransaction(txHash);\n        if (tx == null) {\n            return types_1.TransactionStatus.NotFound;\n        }\n        if (tx.blockNumber == null) {\n            return types_1.TransactionStatus.Processing;\n        }\n        const verifiedBlock = await this.getBlock('finalized');\n        if (tx.blockNumber <= verifiedBlock.number) {\n            return types_1.TransactionStatus.Finalized;\n        }\n        return types_1.TransactionStatus.Committed;\n    }\n    async getTransaction(hash) {\n        hash = await hash;\n        const tx = await super.getTransaction(hash);\n        return tx ? this._wrapTransaction(tx, hash) : null;\n    }\n    async sendTransaction(transaction) {\n        return (await super.sendTransaction(transaction));\n    }\n    async getL2TransactionFromPriorityOp(l1TxResponse) {\n        const receipt = await l1TxResponse.wait();\n        const l2Hash = (0, utils_1.getL2HashFromPriorityOp)(receipt, await this.getMainContractAddress());\n        let status = null;\n        do {\n            status = await this.getTransactionStatus(l2Hash);\n            await (0, utils_1.sleep)(this.pollingInterval);\n        } while (status == types_1.TransactionStatus.NotFound);\n        return await this.getTransaction(l2Hash);\n    }\n    async getPriorityOpResponse(l1TxResponse) {\n        const l2Response = { ...l1TxResponse };\n        l2Response.waitL1Commit = l2Response.wait;\n        l2Response.wait = async () => {\n            const l2Tx = await this.getL2TransactionFromPriorityOp(l1TxResponse);\n            return await l2Tx.wait();\n        };\n        l2Response.waitFinalize = async () => {\n            const l2Tx = await this.getL2TransactionFromPriorityOp(l1TxResponse);\n            return await l2Tx.waitFinalize();\n        };\n        return l2Response;\n    }\n    async getContractAccountInfo(address) {\n        const deployerContract = new ethers_1.Contract(utils_1.CONTRACT_DEPLOYER_ADDRESS, utils_1.CONTRACT_DEPLOYER, this);\n        const data = await deployerContract.getAccountInfo(address);\n        return {\n            supportedAAVersion: data.supportedAAVersion,\n            nonceOrdering: data.nonceOrdering\n        };\n    }\n    // TODO (EVM-3): support refundRecipient for fee estimation\n    async estimateL1ToL2Execute(transaction) {\n        var _a, _b;\n        (_a = transaction.gasPerPubdataByte) !== null && _a !== void 0 ? _a : (transaction.gasPerPubdataByte = utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT);\n        // If the `from` address is not provided, we use a random address, because\n        // due to storage slot aggregation, the gas estimation will depend on the address\n        // and so estimation for the zero address may be smaller than for the sender.\n        (_b = transaction.caller) !== null && _b !== void 0 ? _b : (transaction.caller = ethers_1.ethers.Wallet.createRandom().address);\n        const customData = {\n            gasPerPubdataByte: transaction.gasPerPubdataByte\n        };\n        if (transaction.factoryDeps) {\n            Object.assign(customData, { factoryDeps: transaction.factoryDeps });\n        }\n        const fee = await this.estimateGasL1({\n            from: transaction.caller,\n            data: transaction.calldata,\n            to: transaction.contractAddress,\n            value: transaction.l2Value,\n            customData\n        });\n        return fee;\n    }\n}\nexports.Provider = Provider;\nclass Web3Provider extends Provider {\n    constructor(provider, network) {\n        if (provider == null) {\n            throw new Error('missing provider');\n        }\n        if (!provider.request) {\n            throw new Error('provider must implement eip-1193');\n        }\n        let path = provider.host || provider.path || (provider.isMetaMask ? 'metamask' : 'eip-1193:');\n        super(path, network);\n        this.provider = provider;\n    }\n    async send(method, params) {\n        params !== null && params !== void 0 ? params : (params = []);\n        // Metamask complains about eth_sign (and on some versions hangs)\n        if (method == 'eth_sign' && (this.provider.isMetaMask || this.provider.isStatus)) {\n            // https://github.com/ethereum/go-ethereum/wiki/Management-APIs#personal_sign\n            method = 'personal_sign';\n            params = [params[1], params[0]];\n        }\n        return await this.provider.request({ method, params });\n    }\n    getSigner(addressOrIndex) {\n        return signer_1.Signer.from(super.getSigner(addressOrIndex));\n    }\n    async estimateGas(transaction) {\n        const gas = await super.estimateGas(transaction);\n        const metamaskMinimum = ethers_1.BigNumber.from(21000);\n        const isEIP712 = transaction.customData != null || transaction.type == utils_1.EIP712_TX_TYPE;\n        return gas.gt(metamaskMinimum) || isEIP712 ? gas : metamaskMinimum;\n    }\n}\nexports.Web3Provider = Web3Provider;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}