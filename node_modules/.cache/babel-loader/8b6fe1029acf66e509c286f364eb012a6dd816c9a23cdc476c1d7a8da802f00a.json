{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.estimateDefaultBridgeDepositL2Gas = exports.isTypedDataSignatureCorrect = exports.isMessageSignatureCorrect = exports.getERC20BridgeCalldata = exports.undoL1ToL2Alias = exports.applyL1ToL2Alias = exports.getL2HashFromPriorityOp = exports.parseTransaction = exports.hashBytecode = exports.serialize = exports.checkBaseCost = exports.createAddress = exports.create2Address = exports.getDeployedContracts = exports.getHashedL2ToL1Msg = exports.layer1TxDefaults = exports.sleep = exports.isETH = exports.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT = exports.DEFAULT_GAS_PER_PUBDATA_LIMIT = exports.MAX_BYTECODE_LEN_BYTES = exports.PRIORITY_OPERATION_L2_TX_TYPE = exports.EIP712_TX_TYPE = exports.EIP1271_MAGIC_VALUE = exports.L1_TO_L2_ALIAS_OFFSET = exports.L2_ETH_TOKEN_ADDRESS = exports.L1_MESSENGER_ADDRESS = exports.CONTRACT_DEPLOYER_ADDRESS = exports.BOOTLOADER_FORMAL_ADDRESS = exports.L2_BRIDGE_ABI = exports.L1_BRIDGE_ABI = exports.IERC1271 = exports.IERC20 = exports.L1_MESSENGER = exports.CONTRACT_DEPLOYER = exports.ZKSYNC_MAIN_ABI = exports.ETH_ADDRESS = void 0;\nconst ethers_1 = require(\"ethers\");\nconst types_1 = require(\"./types\");\nconst signer_1 = require(\"./signer\");\nconst typechain_1 = require(\"../typechain\");\nconst utils_1 = require(\"ethers/lib/utils\");\n__exportStar(require(\"./paymaster-utils\"), exports);\nexports.ETH_ADDRESS = '0x0000000000000000000000000000000000000000';\nexports.ZKSYNC_MAIN_ABI = new ethers_1.utils.Interface(require('../../abi/IZkSync.json').abi);\nexports.CONTRACT_DEPLOYER = new ethers_1.utils.Interface(require('../../abi/ContractDeployer.json').abi);\nexports.L1_MESSENGER = new ethers_1.utils.Interface(require('../../abi/IL1Messenger.json').abi);\nexports.IERC20 = new ethers_1.utils.Interface(require('../../abi/IERC20.json').abi);\nexports.IERC1271 = new ethers_1.utils.Interface(require('../../abi/IERC1271.json').abi);\nexports.L1_BRIDGE_ABI = new ethers_1.utils.Interface(require('../../abi/IL1Bridge.json').abi);\nexports.L2_BRIDGE_ABI = new ethers_1.utils.Interface(require('../../abi/IL2Bridge.json').abi);\nexports.BOOTLOADER_FORMAL_ADDRESS = '0x0000000000000000000000000000000000008001';\nexports.CONTRACT_DEPLOYER_ADDRESS = '0x0000000000000000000000000000000000008006';\nexports.L1_MESSENGER_ADDRESS = '0x0000000000000000000000000000000000008008';\nexports.L2_ETH_TOKEN_ADDRESS = '0x000000000000000000000000000000000000800a';\nexports.L1_TO_L2_ALIAS_OFFSET = '0x1111000000000000000000000000000000001111';\nexports.EIP1271_MAGIC_VALUE = '0x1626ba7e';\nexports.EIP712_TX_TYPE = 0x71;\nexports.PRIORITY_OPERATION_L2_TX_TYPE = 0xff;\nexports.MAX_BYTECODE_LEN_BYTES = ((1 << 16) - 1) * 32;\n// The large L2 gas per pubdata to sign. This gas is enough to ensure that\n// any reasonable limit will be accepted. Note, that the operator is NOT required to\n// use the honest value of gas per pubdata and it can use any value up to the one signed by the user.\n// In the future releases, we will provide a way to estimate the current gasPerPubdata.\nexports.DEFAULT_GAS_PER_PUBDATA_LIMIT = 50000;\n// It is possible to provide practically any gasPerPubdataByte for L1->L2 transactions, since\n// the cost per gas will be adjusted respectively. We will use 800 as an relatively optimal value for now.\nexports.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT = 800;\nfunction isETH(token) {\n  return token.toLowerCase() == exports.ETH_ADDRESS || token.toLowerCase() == exports.L2_ETH_TOKEN_ADDRESS;\n}\nexports.isETH = isETH;\nfunction sleep(millis) {\n  return new Promise(resolve => setTimeout(resolve, millis));\n}\nexports.sleep = sleep;\nfunction layer1TxDefaults() {\n  return {\n    queueType: types_1.PriorityQueueType.Deque,\n    opTree: types_1.PriorityOpTree.Full\n  };\n}\nexports.layer1TxDefaults = layer1TxDefaults;\nfunction getHashedL2ToL1Msg(sender, msg, txNumberInBlock) {\n  const encodedMsg = new Uint8Array([0, 1, ...ethers_1.ethers.utils.zeroPad(ethers_1.ethers.utils.hexlify(txNumberInBlock), 2), ...ethers_1.ethers.utils.arrayify(exports.L1_MESSENGER_ADDRESS), ...ethers_1.ethers.utils.zeroPad(sender, 32), ...ethers_1.ethers.utils.arrayify(ethers_1.ethers.utils.keccak256(msg))]);\n  return ethers_1.ethers.utils.keccak256(encodedMsg);\n}\nexports.getHashedL2ToL1Msg = getHashedL2ToL1Msg;\nfunction getDeployedContracts(receipt) {\n  const addressBytesLen = 40;\n  const deployedContracts = receipt.logs.filter(log => log.topics[0] == ethers_1.utils.id('ContractDeployed(address,bytes32,address)') && log.address == exports.CONTRACT_DEPLOYER_ADDRESS)\n  // Take the last topic (deployed contract address as U256) and extract address from it (U160).\n  .map(log => {\n    const sender = `0x${log.topics[1].slice(log.topics[1].length - addressBytesLen)}`;\n    const bytesCodehash = log.topics[2];\n    const address = `0x${log.topics[3].slice(log.topics[3].length - addressBytesLen)}`;\n    return {\n      sender: ethers_1.utils.getAddress(sender),\n      bytecodeHash: bytesCodehash,\n      deployedAddress: ethers_1.utils.getAddress(address)\n    };\n  });\n  return deployedContracts;\n}\nexports.getDeployedContracts = getDeployedContracts;\nfunction create2Address(sender, bytecodeHash, salt, input) {\n  const prefix = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes('zksyncCreate2'));\n  const inputHash = ethers_1.ethers.utils.keccak256(input);\n  const addressBytes = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.concat([prefix, ethers_1.ethers.utils.zeroPad(sender, 32), salt, bytecodeHash, inputHash])).slice(26);\n  return ethers_1.ethers.utils.getAddress(addressBytes);\n}\nexports.create2Address = create2Address;\nfunction createAddress(sender, senderNonce) {\n  const prefix = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes('zksyncCreate'));\n  const addressBytes = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.concat([prefix, ethers_1.ethers.utils.zeroPad(sender, 32), ethers_1.ethers.utils.zeroPad(ethers_1.ethers.utils.hexlify(senderNonce), 32)])).slice(26);\n  return ethers_1.ethers.utils.getAddress(addressBytes);\n}\nexports.createAddress = createAddress;\nasync function checkBaseCost(baseCost, value) {\n  if (baseCost.gt(await value)) {\n    throw new Error(`The base cost of performing the priority operation is higher than the provided value parameter ` + `for the transaction: baseCost: ${baseCost}, provided value: ${value}`);\n  }\n}\nexports.checkBaseCost = checkBaseCost;\nfunction serialize(transaction, signature) {\n  var _a;\n  if (transaction.customData == null && transaction.type != exports.EIP712_TX_TYPE) {\n    return ethers_1.utils.serializeTransaction(transaction, signature);\n  }\n  if (!transaction.chainId) {\n    throw Error(\"Transaction chainId isn't set\");\n  }\n  function formatNumber(value, name) {\n    const result = ethers_1.utils.stripZeros(ethers_1.BigNumber.from(value).toHexString());\n    if (result.length > 32) {\n      throw new Error('invalid length for ' + name);\n    }\n    return result;\n  }\n  if (!transaction.from) {\n    throw new Error('Explicitly providing `from` field is reqiured for EIP712 transactions');\n  }\n  const from = transaction.from;\n  const meta = transaction.customData;\n  let maxFeePerGas = transaction.maxFeePerGas || transaction.gasPrice || 0;\n  let maxPriorityFeePerGas = transaction.maxPriorityFeePerGas || maxFeePerGas;\n  const fields = [formatNumber(transaction.nonce || 0, 'nonce'), formatNumber(maxPriorityFeePerGas, 'maxPriorityFeePerGas'), formatNumber(maxFeePerGas, 'maxFeePerGas'), formatNumber(transaction.gasLimit || 0, 'gasLimit'), transaction.to != null ? ethers_1.utils.getAddress(transaction.to) : '0x', formatNumber(transaction.value || 0, 'value'), transaction.data || '0x'];\n  if (signature) {\n    const sig = ethers_1.utils.splitSignature(signature);\n    fields.push(formatNumber(sig.recoveryParam, 'recoveryParam'));\n    fields.push(ethers_1.utils.stripZeros(sig.r));\n    fields.push(ethers_1.utils.stripZeros(sig.s));\n  } else {\n    fields.push(formatNumber(transaction.chainId, 'chainId'));\n    fields.push('0x');\n    fields.push('0x');\n  }\n  fields.push(formatNumber(transaction.chainId, 'chainId'));\n  fields.push(ethers_1.utils.getAddress(from));\n  // Add meta\n  fields.push(formatNumber(meta.gasPerPubdata || exports.DEFAULT_GAS_PER_PUBDATA_LIMIT, 'gasPerPubdata'));\n  fields.push(((_a = meta.factoryDeps) !== null && _a !== void 0 ? _a : []).map(dep => ethers_1.utils.hexlify(dep)));\n  if (meta.customSignature && ethers_1.ethers.utils.arrayify(meta.customSignature).length == 0) {\n    throw new Error('Empty signatures are not supported');\n  }\n  fields.push(meta.customSignature || '0x');\n  if (meta.paymasterParams) {\n    fields.push([meta.paymasterParams.paymaster, ethers_1.ethers.utils.hexlify(meta.paymasterParams.paymasterInput)]);\n  } else {\n    fields.push([]);\n  }\n  return ethers_1.utils.hexConcat([[exports.EIP712_TX_TYPE], ethers_1.utils.RLP.encode(fields)]);\n}\nexports.serialize = serialize;\nfunction hashBytecode(bytecode) {\n  // For getting the consistent length we first convert the bytecode to UInt8Array\n  const bytecodeAsArray = ethers_1.ethers.utils.arrayify(bytecode);\n  if (bytecodeAsArray.length % 32 != 0) {\n    throw new Error('The bytecode length in bytes must be divisible by 32');\n  }\n  if (bytecodeAsArray.length > exports.MAX_BYTECODE_LEN_BYTES) {\n    throw new Error(`Bytecode can not be longer than ${exports.MAX_BYTECODE_LEN_BYTES} bytes`);\n  }\n  const hashStr = ethers_1.ethers.utils.sha256(bytecodeAsArray);\n  const hash = ethers_1.ethers.utils.arrayify(hashStr);\n  // Note that the length of the bytecode\n  // should be provided in 32-byte words.\n  const bytecodeLengthInWords = bytecodeAsArray.length / 32;\n  if (bytecodeLengthInWords % 2 == 0) {\n    throw new Error('Bytecode length in 32-byte words must be odd');\n  }\n  const bytecodeLength = ethers_1.ethers.utils.arrayify(bytecodeLengthInWords);\n  // The bytecode should always take the first 2 bytes of the bytecode hash,\n  // so we pad it from the left in case the length is smaller than 2 bytes.\n  const bytecodeLengthPadded = ethers_1.ethers.utils.zeroPad(bytecodeLength, 2);\n  const codeHashVersion = new Uint8Array([1, 0]);\n  hash.set(codeHashVersion, 0);\n  hash.set(bytecodeLengthPadded, 2);\n  return hash;\n}\nexports.hashBytecode = hashBytecode;\nfunction parseTransaction(payload) {\n  function handleAddress(value) {\n    if (value === '0x') {\n      return null;\n    }\n    return ethers_1.utils.getAddress(value);\n  }\n  function handleNumber(value) {\n    if (value === '0x') {\n      return ethers_1.BigNumber.from(0);\n    }\n    return ethers_1.BigNumber.from(value);\n  }\n  function arrayToPaymasterParams(arr) {\n    if (arr.length == 0) {\n      return undefined;\n    }\n    if (arr.length != 2) {\n      throw new Error(`Invalid paymaster parameters, expected to have length of 2, found ${arr.length}`);\n    }\n    return {\n      paymaster: ethers_1.utils.getAddress(arr[0]),\n      paymasterInput: ethers_1.utils.arrayify(arr[1])\n    };\n  }\n  const bytes = ethers_1.utils.arrayify(payload);\n  if (bytes[0] != exports.EIP712_TX_TYPE) {\n    return ethers_1.utils.parseTransaction(bytes);\n  }\n  const raw = ethers_1.utils.RLP.decode(bytes.slice(1));\n  const transaction = {\n    type: exports.EIP712_TX_TYPE,\n    nonce: handleNumber(raw[0]).toNumber(),\n    maxPriorityFeePerGas: handleNumber(raw[1]),\n    maxFeePerGas: handleNumber(raw[2]),\n    gasLimit: handleNumber(raw[3]),\n    to: handleAddress(raw[4]),\n    value: handleNumber(raw[5]),\n    data: raw[6],\n    chainId: handleNumber(raw[10]),\n    from: handleAddress(raw[11]),\n    customData: {\n      gasPerPubdata: handleNumber(raw[12]),\n      factoryDeps: raw[13],\n      customSignature: raw[14],\n      paymasterParams: arrayToPaymasterParams(raw[15])\n    }\n  };\n  const ethSignature = {\n    v: handleNumber(raw[7]).toNumber(),\n    r: raw[8],\n    s: raw[9]\n  };\n  if ((ethers_1.utils.hexlify(ethSignature.r) == '0x' || ethers_1.utils.hexlify(ethSignature.s) == '0x') && !transaction.customData.customSignature) {\n    return transaction;\n  }\n  if (ethSignature.v !== 0 && ethSignature.v !== 1 && !transaction.customData.customSignature) {\n    throw new Error('Failed to parse signature');\n  }\n  if (!transaction.customData.customSignature) {\n    transaction.v = ethSignature.v;\n    transaction.s = ethSignature.s;\n    transaction.r = ethSignature.r;\n  }\n  transaction.hash = eip712TxHash(transaction, ethSignature);\n  return transaction;\n}\nexports.parseTransaction = parseTransaction;\nfunction getSignature(transaction, ethSignature) {\n  var _a;\n  if (((_a = transaction === null || transaction === void 0 ? void 0 : transaction.customData) === null || _a === void 0 ? void 0 : _a.customSignature) && transaction.customData.customSignature.length) {\n    return ethers_1.ethers.utils.arrayify(transaction.customData.customSignature);\n  }\n  if (!ethSignature) {\n    throw new Error('No signature provided');\n  }\n  const r = ethers_1.ethers.utils.zeroPad(ethers_1.ethers.utils.arrayify(ethSignature.r), 32);\n  const s = ethers_1.ethers.utils.zeroPad(ethers_1.ethers.utils.arrayify(ethSignature.s), 32);\n  const v = ethSignature.v;\n  return new Uint8Array([...r, ...s, v]);\n}\nfunction eip712TxHash(transaction, ethSignature) {\n  const signedDigest = signer_1.EIP712Signer.getSignedDigest(transaction);\n  const hashedSignature = ethers_1.ethers.utils.keccak256(getSignature(transaction, ethSignature));\n  return ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.hexConcat([signedDigest, hashedSignature]));\n}\nfunction getL2HashFromPriorityOp(txReceipt, zkSyncAddress) {\n  let txHash = null;\n  for (const log of txReceipt.logs) {\n    if (log.address.toLowerCase() != zkSyncAddress.toLowerCase()) {\n      continue;\n    }\n    try {\n      const priorityQueueLog = exports.ZKSYNC_MAIN_ABI.parseLog(log);\n      if (priorityQueueLog && priorityQueueLog.args.txHash != null) {\n        txHash = priorityQueueLog.args.txHash;\n      }\n    } catch {}\n  }\n  if (!txHash) {\n    throw new Error('Failed to parse tx logs');\n  }\n  return txHash;\n}\nexports.getL2HashFromPriorityOp = getL2HashFromPriorityOp;\nconst ADDRESS_MODULO = ethers_1.BigNumber.from(2).pow(160);\nfunction applyL1ToL2Alias(address) {\n  return ethers_1.ethers.utils.hexlify(ethers_1.ethers.BigNumber.from(address).add(exports.L1_TO_L2_ALIAS_OFFSET).mod(ADDRESS_MODULO));\n}\nexports.applyL1ToL2Alias = applyL1ToL2Alias;\nfunction undoL1ToL2Alias(address) {\n  let result = ethers_1.ethers.BigNumber.from(address).sub(exports.L1_TO_L2_ALIAS_OFFSET);\n  if (result.lt(ethers_1.BigNumber.from(0))) {\n    result = result.add(ADDRESS_MODULO);\n  }\n  return ethers_1.ethers.utils.hexlify(result);\n}\nexports.undoL1ToL2Alias = undoL1ToL2Alias;\n/// Getters data used to correctly initialize the L1 token counterpart on L2\nasync function getERC20GettersData(l1TokenAddress, provider) {\n  const token = typechain_1.IERC20MetadataFactory.connect(l1TokenAddress, provider);\n  const name = await token.name();\n  const symbol = await token.symbol();\n  const decimals = await token.decimals();\n  const coder = new utils_1.AbiCoder();\n  const nameBytes = coder.encode(['string'], [name]);\n  const symbolBytes = coder.encode(['string'], [symbol]);\n  const decimalsBytes = coder.encode(['uint256'], [decimals]);\n  return coder.encode(['bytes', 'bytes', 'bytes'], [nameBytes, symbolBytes, decimalsBytes]);\n}\n/// The method that returns the calldata that will be sent by an L1 ERC20 bridge to its L2 counterpart\n/// during bridging of a token.\nasync function getERC20BridgeCalldata(l1TokenAddress, l1Sender, l2Receiver, amount, provider) {\n  const gettersData = await getERC20GettersData(l1TokenAddress, provider);\n  return exports.L2_BRIDGE_ABI.encodeFunctionData('finalizeDeposit', [l1Sender, l2Receiver, l1TokenAddress, amount, gettersData]);\n}\nexports.getERC20BridgeCalldata = getERC20BridgeCalldata;\n// The method with similar functionality is already available in ethers.js,\n// the only difference is that we provide additional `try { } catch { }`\n// for error-resilience.\n//\n// It will also pave the road for allowing future EIP-1271 signature verification, by\n// letting our SDK have functionality to verify signatures.\nfunction isECDSASignatureCorrect(address, msgHash, signature) {\n  try {\n    return address == ethers_1.ethers.utils.recoverAddress(msgHash, signature);\n  } catch {\n    // In case ECDSA signature verification has thrown an error,\n    // we simply consider the signature as incorrect.\n    return false;\n  }\n}\nasync function isEIP1271SignatureCorrect(provider, address, msgHash, signature) {\n  const accountContract = new ethers_1.ethers.Contract(address, exports.IERC1271, provider);\n  // This line may throw an exception if the contract does not implement the EIP1271 correctly.\n  // But it may also throw an exception in case the internet connection is lost.\n  // It is the caller's responsibility to handle the exception.\n  const result = await accountContract.isValidSignature(msgHash, signature);\n  return result == exports.EIP1271_MAGIC_VALUE;\n}\nasync function isSignatureCorrect(provider, address, msgHash, signature) {\n  let isContractAccount = false;\n  const code = await provider.getCode(address);\n  isContractAccount = ethers_1.ethers.utils.arrayify(code).length != 0;\n  if (!isContractAccount) {\n    return isECDSASignatureCorrect(address, msgHash, signature);\n  } else {\n    return await isEIP1271SignatureCorrect(provider, address, msgHash, signature);\n  }\n}\n// Returns `true` or `false` depending on whether or not the account abstraction's\n// signature is correct. Note, that while currently it does not do any `async` actions.\n// in the future it will. That's why the `Promise<boolean>` is returned.\nasync function isMessageSignatureCorrect(provider, address, message, signature) {\n  const msgHash = ethers_1.ethers.utils.hashMessage(message);\n  return await isSignatureCorrect(provider, address, msgHash, signature);\n}\nexports.isMessageSignatureCorrect = isMessageSignatureCorrect;\n// Returns `true` or `false` depending on whether or not the account abstraction's\n// EIP712 signature is correct. Note, that while currently it does not do any `async` actions.\n// in the future it will. That's why the `Promise<boolean>` is returned.\nasync function isTypedDataSignatureCorrect(provider, address, domain, types, value, signature) {\n  const msgHash = ethers_1.ethers.utils._TypedDataEncoder.hash(domain, types, value);\n  return await isSignatureCorrect(provider, address, msgHash, signature);\n}\nexports.isTypedDataSignatureCorrect = isTypedDataSignatureCorrect;\nasync function estimateDefaultBridgeDepositL2Gas(providerL1, providerL2, token, amount, to, from, gasPerPubdataByte) {\n  // If the `from` address is not provided, we use a random address, because\n  // due to storage slot aggregation, the gas estimation will depend on the address\n  // and so estimation for the zero address may be smaller than for the sender.\n  from !== null && from !== void 0 ? from : from = ethers_1.ethers.Wallet.createRandom().address;\n  if (token == exports.ETH_ADDRESS) {\n    return await providerL2.estimateL1ToL2Execute({\n      contractAddress: to,\n      gasPerPubdataByte: gasPerPubdataByte,\n      caller: from,\n      calldata: '0x',\n      l2Value: amount\n    });\n  } else {\n    const l1ERC20BridgeAddresses = (await providerL2.getDefaultBridgeAddresses()).erc20L1;\n    const erc20BridgeAddress = (await providerL2.getDefaultBridgeAddresses()).erc20L2;\n    const calldata = await getERC20BridgeCalldata(token, from, to, amount, providerL1);\n    return await providerL2.estimateL1ToL2Execute({\n      caller: applyL1ToL2Alias(l1ERC20BridgeAddresses),\n      contractAddress: erc20BridgeAddress,\n      gasPerPubdataByte: gasPerPubdataByte,\n      calldata: calldata\n    });\n  }\n}\nexports.estimateDefaultBridgeDepositL2Gas = estimateDefaultBridgeDepositL2Gas;","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__exportStar","exports","p","prototype","hasOwnProperty","call","value","estimateDefaultBridgeDepositL2Gas","isTypedDataSignatureCorrect","isMessageSignatureCorrect","getERC20BridgeCalldata","undoL1ToL2Alias","applyL1ToL2Alias","getL2HashFromPriorityOp","parseTransaction","hashBytecode","serialize","checkBaseCost","createAddress","create2Address","getDeployedContracts","getHashedL2ToL1Msg","layer1TxDefaults","sleep","isETH","REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT","DEFAULT_GAS_PER_PUBDATA_LIMIT","MAX_BYTECODE_LEN_BYTES","PRIORITY_OPERATION_L2_TX_TYPE","EIP712_TX_TYPE","EIP1271_MAGIC_VALUE","L1_TO_L2_ALIAS_OFFSET","L2_ETH_TOKEN_ADDRESS","L1_MESSENGER_ADDRESS","CONTRACT_DEPLOYER_ADDRESS","BOOTLOADER_FORMAL_ADDRESS","L2_BRIDGE_ABI","L1_BRIDGE_ABI","IERC1271","IERC20","L1_MESSENGER","CONTRACT_DEPLOYER","ZKSYNC_MAIN_ABI","ETH_ADDRESS","ethers_1","require","types_1","signer_1","typechain_1","utils_1","utils","Interface","abi","token","toLowerCase","millis","Promise","resolve","setTimeout","queueType","PriorityQueueType","Deque","opTree","PriorityOpTree","Full","sender","msg","txNumberInBlock","encodedMsg","Uint8Array","ethers","zeroPad","hexlify","arrayify","keccak256","receipt","addressBytesLen","deployedContracts","logs","filter","log","topics","id","address","map","slice","length","bytesCodehash","getAddress","bytecodeHash","deployedAddress","salt","input","prefix","toUtf8Bytes","inputHash","addressBytes","concat","senderNonce","baseCost","gt","Error","transaction","signature","_a","customData","type","serializeTransaction","chainId","formatNumber","name","result","stripZeros","BigNumber","from","toHexString","meta","maxFeePerGas","gasPrice","maxPriorityFeePerGas","fields","nonce","gasLimit","to","data","sig","splitSignature","push","recoveryParam","r","s","gasPerPubdata","factoryDeps","dep","customSignature","paymasterParams","paymaster","paymasterInput","hexConcat","RLP","encode","bytecode","bytecodeAsArray","hashStr","sha256","hash","bytecodeLengthInWords","bytecodeLength","bytecodeLengthPadded","codeHashVersion","set","payload","handleAddress","handleNumber","arrayToPaymasterParams","arr","bytes","raw","decode","toNumber","ethSignature","v","eip712TxHash","getSignature","signedDigest","EIP712Signer","getSignedDigest","hashedSignature","txReceipt","zkSyncAddress","txHash","priorityQueueLog","parseLog","args","ADDRESS_MODULO","pow","add","mod","sub","lt","getERC20GettersData","l1TokenAddress","provider","IERC20MetadataFactory","connect","symbol","decimals","coder","AbiCoder","nameBytes","symbolBytes","decimalsBytes","l1Sender","l2Receiver","amount","gettersData","encodeFunctionData","isECDSASignatureCorrect","msgHash","recoverAddress","isEIP1271SignatureCorrect","accountContract","Contract","isValidSignature","isSignatureCorrect","isContractAccount","code","getCode","message","hashMessage","domain","types","_TypedDataEncoder","providerL1","providerL2","gasPerPubdataByte","Wallet","createRandom","estimateL1ToL2Execute","contractAddress","caller","calldata","l2Value","l1ERC20BridgeAddresses","getDefaultBridgeAddresses","erc20L1","erc20BridgeAddress","erc20L2"],"sources":["C:/Users/SUMAN K/meta_transfer/node_modules/zksync-web3/build/src/utils.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.estimateDefaultBridgeDepositL2Gas = exports.isTypedDataSignatureCorrect = exports.isMessageSignatureCorrect = exports.getERC20BridgeCalldata = exports.undoL1ToL2Alias = exports.applyL1ToL2Alias = exports.getL2HashFromPriorityOp = exports.parseTransaction = exports.hashBytecode = exports.serialize = exports.checkBaseCost = exports.createAddress = exports.create2Address = exports.getDeployedContracts = exports.getHashedL2ToL1Msg = exports.layer1TxDefaults = exports.sleep = exports.isETH = exports.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT = exports.DEFAULT_GAS_PER_PUBDATA_LIMIT = exports.MAX_BYTECODE_LEN_BYTES = exports.PRIORITY_OPERATION_L2_TX_TYPE = exports.EIP712_TX_TYPE = exports.EIP1271_MAGIC_VALUE = exports.L1_TO_L2_ALIAS_OFFSET = exports.L2_ETH_TOKEN_ADDRESS = exports.L1_MESSENGER_ADDRESS = exports.CONTRACT_DEPLOYER_ADDRESS = exports.BOOTLOADER_FORMAL_ADDRESS = exports.L2_BRIDGE_ABI = exports.L1_BRIDGE_ABI = exports.IERC1271 = exports.IERC20 = exports.L1_MESSENGER = exports.CONTRACT_DEPLOYER = exports.ZKSYNC_MAIN_ABI = exports.ETH_ADDRESS = void 0;\nconst ethers_1 = require(\"ethers\");\nconst types_1 = require(\"./types\");\nconst signer_1 = require(\"./signer\");\nconst typechain_1 = require(\"../typechain\");\nconst utils_1 = require(\"ethers/lib/utils\");\n__exportStar(require(\"./paymaster-utils\"), exports);\nexports.ETH_ADDRESS = '0x0000000000000000000000000000000000000000';\nexports.ZKSYNC_MAIN_ABI = new ethers_1.utils.Interface(require('../../abi/IZkSync.json').abi);\nexports.CONTRACT_DEPLOYER = new ethers_1.utils.Interface(require('../../abi/ContractDeployer.json').abi);\nexports.L1_MESSENGER = new ethers_1.utils.Interface(require('../../abi/IL1Messenger.json').abi);\nexports.IERC20 = new ethers_1.utils.Interface(require('../../abi/IERC20.json').abi);\nexports.IERC1271 = new ethers_1.utils.Interface(require('../../abi/IERC1271.json').abi);\nexports.L1_BRIDGE_ABI = new ethers_1.utils.Interface(require('../../abi/IL1Bridge.json').abi);\nexports.L2_BRIDGE_ABI = new ethers_1.utils.Interface(require('../../abi/IL2Bridge.json').abi);\nexports.BOOTLOADER_FORMAL_ADDRESS = '0x0000000000000000000000000000000000008001';\nexports.CONTRACT_DEPLOYER_ADDRESS = '0x0000000000000000000000000000000000008006';\nexports.L1_MESSENGER_ADDRESS = '0x0000000000000000000000000000000000008008';\nexports.L2_ETH_TOKEN_ADDRESS = '0x000000000000000000000000000000000000800a';\nexports.L1_TO_L2_ALIAS_OFFSET = '0x1111000000000000000000000000000000001111';\nexports.EIP1271_MAGIC_VALUE = '0x1626ba7e';\nexports.EIP712_TX_TYPE = 0x71;\nexports.PRIORITY_OPERATION_L2_TX_TYPE = 0xff;\nexports.MAX_BYTECODE_LEN_BYTES = ((1 << 16) - 1) * 32;\n// The large L2 gas per pubdata to sign. This gas is enough to ensure that\n// any reasonable limit will be accepted. Note, that the operator is NOT required to\n// use the honest value of gas per pubdata and it can use any value up to the one signed by the user.\n// In the future releases, we will provide a way to estimate the current gasPerPubdata.\nexports.DEFAULT_GAS_PER_PUBDATA_LIMIT = 50000;\n// It is possible to provide practically any gasPerPubdataByte for L1->L2 transactions, since\n// the cost per gas will be adjusted respectively. We will use 800 as an relatively optimal value for now.\nexports.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT = 800;\nfunction isETH(token) {\n    return token.toLowerCase() == exports.ETH_ADDRESS || token.toLowerCase() == exports.L2_ETH_TOKEN_ADDRESS;\n}\nexports.isETH = isETH;\nfunction sleep(millis) {\n    return new Promise((resolve) => setTimeout(resolve, millis));\n}\nexports.sleep = sleep;\nfunction layer1TxDefaults() {\n    return {\n        queueType: types_1.PriorityQueueType.Deque,\n        opTree: types_1.PriorityOpTree.Full\n    };\n}\nexports.layer1TxDefaults = layer1TxDefaults;\nfunction getHashedL2ToL1Msg(sender, msg, txNumberInBlock) {\n    const encodedMsg = new Uint8Array([\n        0,\n        1,\n        ...ethers_1.ethers.utils.zeroPad(ethers_1.ethers.utils.hexlify(txNumberInBlock), 2),\n        ...ethers_1.ethers.utils.arrayify(exports.L1_MESSENGER_ADDRESS),\n        ...ethers_1.ethers.utils.zeroPad(sender, 32),\n        ...ethers_1.ethers.utils.arrayify(ethers_1.ethers.utils.keccak256(msg))\n    ]);\n    return ethers_1.ethers.utils.keccak256(encodedMsg);\n}\nexports.getHashedL2ToL1Msg = getHashedL2ToL1Msg;\nfunction getDeployedContracts(receipt) {\n    const addressBytesLen = 40;\n    const deployedContracts = receipt.logs\n        .filter((log) => log.topics[0] == ethers_1.utils.id('ContractDeployed(address,bytes32,address)') &&\n        log.address == exports.CONTRACT_DEPLOYER_ADDRESS)\n        // Take the last topic (deployed contract address as U256) and extract address from it (U160).\n        .map((log) => {\n        const sender = `0x${log.topics[1].slice(log.topics[1].length - addressBytesLen)}`;\n        const bytesCodehash = log.topics[2];\n        const address = `0x${log.topics[3].slice(log.topics[3].length - addressBytesLen)}`;\n        return {\n            sender: ethers_1.utils.getAddress(sender),\n            bytecodeHash: bytesCodehash,\n            deployedAddress: ethers_1.utils.getAddress(address)\n        };\n    });\n    return deployedContracts;\n}\nexports.getDeployedContracts = getDeployedContracts;\nfunction create2Address(sender, bytecodeHash, salt, input) {\n    const prefix = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes('zksyncCreate2'));\n    const inputHash = ethers_1.ethers.utils.keccak256(input);\n    const addressBytes = ethers_1.ethers.utils\n        .keccak256(ethers_1.ethers.utils.concat([prefix, ethers_1.ethers.utils.zeroPad(sender, 32), salt, bytecodeHash, inputHash]))\n        .slice(26);\n    return ethers_1.ethers.utils.getAddress(addressBytes);\n}\nexports.create2Address = create2Address;\nfunction createAddress(sender, senderNonce) {\n    const prefix = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes('zksyncCreate'));\n    const addressBytes = ethers_1.ethers.utils\n        .keccak256(ethers_1.ethers.utils.concat([\n        prefix,\n        ethers_1.ethers.utils.zeroPad(sender, 32),\n        ethers_1.ethers.utils.zeroPad(ethers_1.ethers.utils.hexlify(senderNonce), 32)\n    ]))\n        .slice(26);\n    return ethers_1.ethers.utils.getAddress(addressBytes);\n}\nexports.createAddress = createAddress;\nasync function checkBaseCost(baseCost, value) {\n    if (baseCost.gt(await value)) {\n        throw new Error(`The base cost of performing the priority operation is higher than the provided value parameter ` +\n            `for the transaction: baseCost: ${baseCost}, provided value: ${value}`);\n    }\n}\nexports.checkBaseCost = checkBaseCost;\nfunction serialize(transaction, signature) {\n    var _a;\n    if (transaction.customData == null && transaction.type != exports.EIP712_TX_TYPE) {\n        return ethers_1.utils.serializeTransaction(transaction, signature);\n    }\n    if (!transaction.chainId) {\n        throw Error(\"Transaction chainId isn't set\");\n    }\n    function formatNumber(value, name) {\n        const result = ethers_1.utils.stripZeros(ethers_1.BigNumber.from(value).toHexString());\n        if (result.length > 32) {\n            throw new Error('invalid length for ' + name);\n        }\n        return result;\n    }\n    if (!transaction.from) {\n        throw new Error('Explicitly providing `from` field is reqiured for EIP712 transactions');\n    }\n    const from = transaction.from;\n    const meta = transaction.customData;\n    let maxFeePerGas = transaction.maxFeePerGas || transaction.gasPrice || 0;\n    let maxPriorityFeePerGas = transaction.maxPriorityFeePerGas || maxFeePerGas;\n    const fields = [\n        formatNumber(transaction.nonce || 0, 'nonce'),\n        formatNumber(maxPriorityFeePerGas, 'maxPriorityFeePerGas'),\n        formatNumber(maxFeePerGas, 'maxFeePerGas'),\n        formatNumber(transaction.gasLimit || 0, 'gasLimit'),\n        transaction.to != null ? ethers_1.utils.getAddress(transaction.to) : '0x',\n        formatNumber(transaction.value || 0, 'value'),\n        transaction.data || '0x'\n    ];\n    if (signature) {\n        const sig = ethers_1.utils.splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, 'recoveryParam'));\n        fields.push(ethers_1.utils.stripZeros(sig.r));\n        fields.push(ethers_1.utils.stripZeros(sig.s));\n    }\n    else {\n        fields.push(formatNumber(transaction.chainId, 'chainId'));\n        fields.push('0x');\n        fields.push('0x');\n    }\n    fields.push(formatNumber(transaction.chainId, 'chainId'));\n    fields.push(ethers_1.utils.getAddress(from));\n    // Add meta\n    fields.push(formatNumber(meta.gasPerPubdata || exports.DEFAULT_GAS_PER_PUBDATA_LIMIT, 'gasPerPubdata'));\n    fields.push(((_a = meta.factoryDeps) !== null && _a !== void 0 ? _a : []).map((dep) => ethers_1.utils.hexlify(dep)));\n    if (meta.customSignature && ethers_1.ethers.utils.arrayify(meta.customSignature).length == 0) {\n        throw new Error('Empty signatures are not supported');\n    }\n    fields.push(meta.customSignature || '0x');\n    if (meta.paymasterParams) {\n        fields.push([meta.paymasterParams.paymaster, ethers_1.ethers.utils.hexlify(meta.paymasterParams.paymasterInput)]);\n    }\n    else {\n        fields.push([]);\n    }\n    return ethers_1.utils.hexConcat([[exports.EIP712_TX_TYPE], ethers_1.utils.RLP.encode(fields)]);\n}\nexports.serialize = serialize;\nfunction hashBytecode(bytecode) {\n    // For getting the consistent length we first convert the bytecode to UInt8Array\n    const bytecodeAsArray = ethers_1.ethers.utils.arrayify(bytecode);\n    if (bytecodeAsArray.length % 32 != 0) {\n        throw new Error('The bytecode length in bytes must be divisible by 32');\n    }\n    if (bytecodeAsArray.length > exports.MAX_BYTECODE_LEN_BYTES) {\n        throw new Error(`Bytecode can not be longer than ${exports.MAX_BYTECODE_LEN_BYTES} bytes`);\n    }\n    const hashStr = ethers_1.ethers.utils.sha256(bytecodeAsArray);\n    const hash = ethers_1.ethers.utils.arrayify(hashStr);\n    // Note that the length of the bytecode\n    // should be provided in 32-byte words.\n    const bytecodeLengthInWords = bytecodeAsArray.length / 32;\n    if (bytecodeLengthInWords % 2 == 0) {\n        throw new Error('Bytecode length in 32-byte words must be odd');\n    }\n    const bytecodeLength = ethers_1.ethers.utils.arrayify(bytecodeLengthInWords);\n    // The bytecode should always take the first 2 bytes of the bytecode hash,\n    // so we pad it from the left in case the length is smaller than 2 bytes.\n    const bytecodeLengthPadded = ethers_1.ethers.utils.zeroPad(bytecodeLength, 2);\n    const codeHashVersion = new Uint8Array([1, 0]);\n    hash.set(codeHashVersion, 0);\n    hash.set(bytecodeLengthPadded, 2);\n    return hash;\n}\nexports.hashBytecode = hashBytecode;\nfunction parseTransaction(payload) {\n    function handleAddress(value) {\n        if (value === '0x') {\n            return null;\n        }\n        return ethers_1.utils.getAddress(value);\n    }\n    function handleNumber(value) {\n        if (value === '0x') {\n            return ethers_1.BigNumber.from(0);\n        }\n        return ethers_1.BigNumber.from(value);\n    }\n    function arrayToPaymasterParams(arr) {\n        if (arr.length == 0) {\n            return undefined;\n        }\n        if (arr.length != 2) {\n            throw new Error(`Invalid paymaster parameters, expected to have length of 2, found ${arr.length}`);\n        }\n        return {\n            paymaster: ethers_1.utils.getAddress(arr[0]),\n            paymasterInput: ethers_1.utils.arrayify(arr[1])\n        };\n    }\n    const bytes = ethers_1.utils.arrayify(payload);\n    if (bytes[0] != exports.EIP712_TX_TYPE) {\n        return ethers_1.utils.parseTransaction(bytes);\n    }\n    const raw = ethers_1.utils.RLP.decode(bytes.slice(1));\n    const transaction = {\n        type: exports.EIP712_TX_TYPE,\n        nonce: handleNumber(raw[0]).toNumber(),\n        maxPriorityFeePerGas: handleNumber(raw[1]),\n        maxFeePerGas: handleNumber(raw[2]),\n        gasLimit: handleNumber(raw[3]),\n        to: handleAddress(raw[4]),\n        value: handleNumber(raw[5]),\n        data: raw[6],\n        chainId: handleNumber(raw[10]),\n        from: handleAddress(raw[11]),\n        customData: {\n            gasPerPubdata: handleNumber(raw[12]),\n            factoryDeps: raw[13],\n            customSignature: raw[14],\n            paymasterParams: arrayToPaymasterParams(raw[15])\n        }\n    };\n    const ethSignature = {\n        v: handleNumber(raw[7]).toNumber(),\n        r: raw[8],\n        s: raw[9]\n    };\n    if ((ethers_1.utils.hexlify(ethSignature.r) == '0x' || ethers_1.utils.hexlify(ethSignature.s) == '0x') &&\n        !transaction.customData.customSignature) {\n        return transaction;\n    }\n    if (ethSignature.v !== 0 && ethSignature.v !== 1 && !transaction.customData.customSignature) {\n        throw new Error('Failed to parse signature');\n    }\n    if (!transaction.customData.customSignature) {\n        transaction.v = ethSignature.v;\n        transaction.s = ethSignature.s;\n        transaction.r = ethSignature.r;\n    }\n    transaction.hash = eip712TxHash(transaction, ethSignature);\n    return transaction;\n}\nexports.parseTransaction = parseTransaction;\nfunction getSignature(transaction, ethSignature) {\n    var _a;\n    if (((_a = transaction === null || transaction === void 0 ? void 0 : transaction.customData) === null || _a === void 0 ? void 0 : _a.customSignature) && transaction.customData.customSignature.length) {\n        return ethers_1.ethers.utils.arrayify(transaction.customData.customSignature);\n    }\n    if (!ethSignature) {\n        throw new Error('No signature provided');\n    }\n    const r = ethers_1.ethers.utils.zeroPad(ethers_1.ethers.utils.arrayify(ethSignature.r), 32);\n    const s = ethers_1.ethers.utils.zeroPad(ethers_1.ethers.utils.arrayify(ethSignature.s), 32);\n    const v = ethSignature.v;\n    return new Uint8Array([...r, ...s, v]);\n}\nfunction eip712TxHash(transaction, ethSignature) {\n    const signedDigest = signer_1.EIP712Signer.getSignedDigest(transaction);\n    const hashedSignature = ethers_1.ethers.utils.keccak256(getSignature(transaction, ethSignature));\n    return ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.hexConcat([signedDigest, hashedSignature]));\n}\nfunction getL2HashFromPriorityOp(txReceipt, zkSyncAddress) {\n    let txHash = null;\n    for (const log of txReceipt.logs) {\n        if (log.address.toLowerCase() != zkSyncAddress.toLowerCase()) {\n            continue;\n        }\n        try {\n            const priorityQueueLog = exports.ZKSYNC_MAIN_ABI.parseLog(log);\n            if (priorityQueueLog && priorityQueueLog.args.txHash != null) {\n                txHash = priorityQueueLog.args.txHash;\n            }\n        }\n        catch { }\n    }\n    if (!txHash) {\n        throw new Error('Failed to parse tx logs');\n    }\n    return txHash;\n}\nexports.getL2HashFromPriorityOp = getL2HashFromPriorityOp;\nconst ADDRESS_MODULO = ethers_1.BigNumber.from(2).pow(160);\nfunction applyL1ToL2Alias(address) {\n    return ethers_1.ethers.utils.hexlify(ethers_1.ethers.BigNumber.from(address).add(exports.L1_TO_L2_ALIAS_OFFSET).mod(ADDRESS_MODULO));\n}\nexports.applyL1ToL2Alias = applyL1ToL2Alias;\nfunction undoL1ToL2Alias(address) {\n    let result = ethers_1.ethers.BigNumber.from(address).sub(exports.L1_TO_L2_ALIAS_OFFSET);\n    if (result.lt(ethers_1.BigNumber.from(0))) {\n        result = result.add(ADDRESS_MODULO);\n    }\n    return ethers_1.ethers.utils.hexlify(result);\n}\nexports.undoL1ToL2Alias = undoL1ToL2Alias;\n/// Getters data used to correctly initialize the L1 token counterpart on L2\nasync function getERC20GettersData(l1TokenAddress, provider) {\n    const token = typechain_1.IERC20MetadataFactory.connect(l1TokenAddress, provider);\n    const name = await token.name();\n    const symbol = await token.symbol();\n    const decimals = await token.decimals();\n    const coder = new utils_1.AbiCoder();\n    const nameBytes = coder.encode(['string'], [name]);\n    const symbolBytes = coder.encode(['string'], [symbol]);\n    const decimalsBytes = coder.encode(['uint256'], [decimals]);\n    return coder.encode(['bytes', 'bytes', 'bytes'], [nameBytes, symbolBytes, decimalsBytes]);\n}\n/// The method that returns the calldata that will be sent by an L1 ERC20 bridge to its L2 counterpart\n/// during bridging of a token.\nasync function getERC20BridgeCalldata(l1TokenAddress, l1Sender, l2Receiver, amount, provider) {\n    const gettersData = await getERC20GettersData(l1TokenAddress, provider);\n    return exports.L2_BRIDGE_ABI.encodeFunctionData('finalizeDeposit', [\n        l1Sender,\n        l2Receiver,\n        l1TokenAddress,\n        amount,\n        gettersData\n    ]);\n}\nexports.getERC20BridgeCalldata = getERC20BridgeCalldata;\n// The method with similar functionality is already available in ethers.js,\n// the only difference is that we provide additional `try { } catch { }`\n// for error-resilience.\n//\n// It will also pave the road for allowing future EIP-1271 signature verification, by\n// letting our SDK have functionality to verify signatures.\nfunction isECDSASignatureCorrect(address, msgHash, signature) {\n    try {\n        return address == ethers_1.ethers.utils.recoverAddress(msgHash, signature);\n    }\n    catch {\n        // In case ECDSA signature verification has thrown an error,\n        // we simply consider the signature as incorrect.\n        return false;\n    }\n}\nasync function isEIP1271SignatureCorrect(provider, address, msgHash, signature) {\n    const accountContract = new ethers_1.ethers.Contract(address, exports.IERC1271, provider);\n    // This line may throw an exception if the contract does not implement the EIP1271 correctly.\n    // But it may also throw an exception in case the internet connection is lost.\n    // It is the caller's responsibility to handle the exception.\n    const result = await accountContract.isValidSignature(msgHash, signature);\n    return result == exports.EIP1271_MAGIC_VALUE;\n}\nasync function isSignatureCorrect(provider, address, msgHash, signature) {\n    let isContractAccount = false;\n    const code = await provider.getCode(address);\n    isContractAccount = ethers_1.ethers.utils.arrayify(code).length != 0;\n    if (!isContractAccount) {\n        return isECDSASignatureCorrect(address, msgHash, signature);\n    }\n    else {\n        return await isEIP1271SignatureCorrect(provider, address, msgHash, signature);\n    }\n}\n// Returns `true` or `false` depending on whether or not the account abstraction's\n// signature is correct. Note, that while currently it does not do any `async` actions.\n// in the future it will. That's why the `Promise<boolean>` is returned.\nasync function isMessageSignatureCorrect(provider, address, message, signature) {\n    const msgHash = ethers_1.ethers.utils.hashMessage(message);\n    return await isSignatureCorrect(provider, address, msgHash, signature);\n}\nexports.isMessageSignatureCorrect = isMessageSignatureCorrect;\n// Returns `true` or `false` depending on whether or not the account abstraction's\n// EIP712 signature is correct. Note, that while currently it does not do any `async` actions.\n// in the future it will. That's why the `Promise<boolean>` is returned.\nasync function isTypedDataSignatureCorrect(provider, address, domain, types, value, signature) {\n    const msgHash = ethers_1.ethers.utils._TypedDataEncoder.hash(domain, types, value);\n    return await isSignatureCorrect(provider, address, msgHash, signature);\n}\nexports.isTypedDataSignatureCorrect = isTypedDataSignatureCorrect;\nasync function estimateDefaultBridgeDepositL2Gas(providerL1, providerL2, token, amount, to, from, gasPerPubdataByte) {\n    // If the `from` address is not provided, we use a random address, because\n    // due to storage slot aggregation, the gas estimation will depend on the address\n    // and so estimation for the zero address may be smaller than for the sender.\n    from !== null && from !== void 0 ? from : (from = ethers_1.ethers.Wallet.createRandom().address);\n    if (token == exports.ETH_ADDRESS) {\n        return await providerL2.estimateL1ToL2Execute({\n            contractAddress: to,\n            gasPerPubdataByte: gasPerPubdataByte,\n            caller: from,\n            calldata: '0x',\n            l2Value: amount\n        });\n    }\n    else {\n        const l1ERC20BridgeAddresses = (await providerL2.getDefaultBridgeAddresses()).erc20L1;\n        const erc20BridgeAddress = (await providerL2.getDefaultBridgeAddresses()).erc20L2;\n        const calldata = await getERC20BridgeCalldata(token, from, to, amount, providerL1);\n        return await providerL2.estimateL1ToL2Execute({\n            caller: applyL1ToL2Alias(l1ERC20BridgeAddresses),\n            contractAddress: erc20BridgeAddress,\n            gasPerPubdataByte: gasPerPubdataByte,\n            calldata: calldata\n        });\n    }\n}\nexports.estimateDefaultBridgeDepositL2Gas = estimateDefaultBridgeDepositL2Gas;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}