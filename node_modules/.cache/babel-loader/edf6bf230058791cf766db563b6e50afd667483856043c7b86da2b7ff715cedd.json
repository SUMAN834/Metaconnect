{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst events_1 = __importDefault(require(\"events\"));\nconst payload_1 = require(\"./payload\");\nclass Provider extends events_1.default {\n  constructor(connection) {\n    super();\n    this.promises = {};\n    this.attemptedSubscriptions = new Set();\n    this.subscriptions = [];\n    this.checkConnectionRunning = false;\n    this.nextId = 1;\n    this.connected = false;\n    this.accounts = [];\n    this.selectedAddress = undefined;\n    this.coinbase = undefined;\n    this.enable = this.enable.bind(this);\n    this.doSend = this.doSend.bind(this);\n    this.send = this.send.bind(this);\n    this.sendBatch = this.sendBatch.bind(this);\n    this.subscribe = this.subscribe.bind(this);\n    this.unsubscribe = this.unsubscribe.bind(this);\n    this.resumeSubscriptions = this.resumeSubscriptions.bind(this);\n    this.sendAsync = this.sendAsync.bind(this);\n    this.sendAsyncBatch = this.sendAsyncBatch.bind(this);\n    this.isConnected = this.isConnected.bind(this);\n    this.close = this.close.bind(this);\n    this.request = this.request.bind(this);\n    this.connection = connection;\n    this.on('connect', this.resumeSubscriptions);\n    this.connection.on('connect', () => this.checkConnection(1000));\n    this.connection.on('close', () => {\n      this.connected = false;\n      this.attemptedSubscriptions.clear();\n      this.emit('close');\n      this.emit('disconnect');\n    });\n    this.connection.on('payload', payload => {\n      const {\n        id,\n        method,\n        error,\n        result\n      } = payload;\n      if (typeof id !== 'undefined') {\n        if (this.promises[id]) {\n          // Fulfill promise\n          const requestMethod = this.promises[id].method;\n          if (requestMethod && ['eth_accounts', 'eth_requestAccounts'].includes(requestMethod)) {\n            const accounts = result || [];\n            this.accounts = accounts;\n            this.selectedAddress = accounts[0];\n            this.coinbase = accounts[0];\n          }\n          payload.error ? this.promises[id].reject(error) : this.promises[id].resolve(result);\n          delete this.promises[id];\n        }\n      } else if (method && method.indexOf('_subscription') > -1) {\n        // Emit subscription result\n        // Events: connect, disconnect, chainChanged, chainsChanged, accountsChanged, assetsChanged, message\n        this.emit(payload.params.subscription, payload.params.result);\n        this.emit(method, payload.params); // Older EIP-1193\n        this.emit('message', {\n          type: payload.method,\n          data: {\n            subscription: payload.params.subscription,\n            result: payload.params.result\n          }\n        });\n        this.emit('data', payload); // Backwards Compatibility\n      }\n    });\n\n    this.on('newListener', event => {\n      if (Object.keys(this.eventHandlers).includes(event)) {\n        if (!this.attemptedSubscription(event) && this.connected) {\n          this.startSubscription(event);\n          if (event === 'networkChanged') {\n            console.warn('The networkChanged event is being deprecated, use chainChanged instead');\n          }\n        }\n      }\n    });\n    this.eventHandlers = {\n      networkChanged: netId => {\n        this.networkVersion = typeof netId === 'string' ? parseInt(netId) : netId;\n        this.emit('networkChanged', this.networkVersion);\n      },\n      chainChanged: chainId => {\n        this.providerChainId = chainId;\n        if (!this.manualChainId) {\n          this.emit('chainChanged', chainId);\n        }\n      },\n      chainsChanged: chains => {\n        this.emit('chainsChanged', chains);\n      },\n      accountsChanged: accounts => {\n        this.selectedAddress = accounts[0];\n        this.emit('accountsChanged', accounts);\n      },\n      assetsChanged: assets => {\n        this.emit('assetsChanged', assets);\n      }\n    };\n  }\n  get chainId() {\n    return this.manualChainId || this.providerChainId;\n  }\n  async checkConnection(retryTimeout = 4000) {\n    if (this.checkConnectionRunning || this.connected) return;\n    clearTimeout(this.checkConnectionTimer);\n    this.checkConnectionTimer = undefined;\n    this.checkConnectionRunning = true;\n    try {\n      this.networkVersion = await this.doSend('net_version', [], undefined, false);\n      this.providerChainId = await this.doSend('eth_chainId', [], undefined, false);\n      this.connected = true;\n    } catch (e) {\n      this.checkConnectionTimer = setTimeout(() => this.checkConnection(), retryTimeout);\n      this.connected = false;\n    } finally {\n      this.checkConnectionRunning = false;\n      if (this.connected) {\n        this.emit('connect', {\n          chainId: this.providerChainId\n        });\n      }\n    }\n  }\n  attemptedSubscription(event) {\n    return this.attemptedSubscriptions.has(event);\n  }\n  setSubscriptionAttempted(event) {\n    this.attemptedSubscriptions.add(event);\n  }\n  async startSubscription(event) {\n    console.debug(`starting subscription for ${event} events`);\n    this.setSubscriptionAttempted(event);\n    try {\n      const eventId = await this.subscribe('eth_subscribe', event);\n      this.on(eventId, this.eventHandlers[event]);\n    } catch (e) {\n      console.warn(`Unable to subscribe to ${event}`, e);\n    }\n  }\n  resumeSubscriptions() {\n    Object.keys(this.eventHandlers).forEach(event => {\n      if (this.listenerCount(event) && !this.attemptedSubscription(event)) this.startSubscription(event);\n    });\n  }\n  async enable() {\n    const accounts = await this.doSend('eth_accounts');\n    if (accounts.length > 0) {\n      this.accounts = accounts;\n      this.selectedAddress = accounts[0];\n      this.coinbase = accounts[0];\n      this.emit('enable');\n      return accounts;\n    } else {\n      const err = new Error('User Denied Full Provider');\n      err.code = '4001';\n      throw err;\n    }\n  }\n  doSend(rawPayload, rawParams = [], targetChain = this.manualChainId, waitForConnection = true) {\n    const sendFn = (resolve, reject) => {\n      const method = typeof rawPayload === 'object' ? rawPayload.method : rawPayload;\n      const params = typeof rawPayload === 'object' ? rawPayload.params : rawParams;\n      const chainTarget = typeof rawPayload === 'object' && rawPayload.chainId || targetChain;\n      if (!method) {\n        return reject(new Error('Method is not a valid string.'));\n      }\n      try {\n        const payload = (0, payload_1.create)(method, params, this.nextId++, chainTarget);\n        this.promises[payload.id] = {\n          resolve: result => resolve(result),\n          reject,\n          method: payload.method\n        };\n        this.connection.send(payload);\n      } catch (e) {\n        reject(e);\n      }\n    };\n    if (this.connected || !waitForConnection) {\n      return new Promise(sendFn);\n    }\n    return new Promise((resolve, reject) => {\n      const resolveSend = () => {\n        clearTimeout(disconnectTimer);\n        return resolve(new Promise(sendFn));\n      };\n      const disconnectTimer = setTimeout(() => {\n        this.off('connect', resolveSend);\n        reject(new Error('Not connected'));\n      }, 5000);\n      this.once('connect', resolveSend);\n    });\n  }\n  async send(methodOrPayload, callbackOrArgs) {\n    if (typeof methodOrPayload === 'string' && (!callbackOrArgs || Array.isArray(callbackOrArgs))) {\n      const params = callbackOrArgs;\n      return this.doSend(methodOrPayload, params);\n    }\n    if (methodOrPayload && typeof methodOrPayload === 'object' && typeof callbackOrArgs === 'function') {\n      // a callback was passed to send(), forward everything to sendAsync()\n      const cb = callbackOrArgs;\n      return this.sendAsync(methodOrPayload, cb);\n    }\n    return this.request(methodOrPayload);\n  }\n  sendBatch(requests) {\n    return Promise.all(requests.map(payload => {\n      return this.doSend(payload.method, payload.params);\n    }));\n  }\n  async subscribe(type, method, params = []) {\n    const id = await this.doSend(type, [method, ...params]);\n    this.subscriptions.push(id);\n    return id;\n  }\n  async unsubscribe(type, id) {\n    const success = await this.doSend(type, [id]);\n    if (success) {\n      this.subscriptions = this.subscriptions.filter(_id => _id !== id); // Remove subscription\n      this.removeAllListeners(id); // Remove listeners\n      return success;\n    }\n  }\n  async sendAsync(rawPayload, cb) {\n    if (!cb || typeof cb !== 'function') return new Error('Invalid or undefined callback provided to sendAsync');\n    if (!rawPayload) return cb(new Error('Invalid Payload'));\n    // sendAsync can be called with an array for batch requests used by web3.js 0.x\n    // this is not part of EIP-1193's backwards compatibility but we still want to support it\n    if (Array.isArray(rawPayload)) {\n      const payloads = rawPayload.map(p => ({\n        ...p,\n        jsonrpc: '2.0'\n      }));\n      const callback = cb;\n      return this.sendAsyncBatch(payloads, callback);\n    } else {\n      const payload = {\n        ...rawPayload,\n        jsonrpc: '2.0'\n      };\n      const callback = cb;\n      try {\n        const result = await this.doSend(payload.method, payload.params);\n        callback(null, {\n          id: payload.id,\n          jsonrpc: payload.jsonrpc,\n          result\n        });\n      } catch (e) {\n        callback(e);\n      }\n    }\n  }\n  async sendAsyncBatch(payloads, cb) {\n    try {\n      const results = await this.sendBatch(payloads);\n      const result = results.map((entry, index) => {\n        return {\n          id: payloads[index].id,\n          jsonrpc: payloads[index].jsonrpc,\n          result: entry\n        };\n      });\n      cb(null, result);\n    } catch (e) {\n      cb(e);\n    }\n  }\n  isConnected() {\n    return this.connected;\n  }\n  close() {\n    if (this.connection && this.connection.close) this.connection.close();\n    this.off('connect', this.resumeSubscriptions);\n    this.connected = false;\n    const error = new Error('Provider closed, subscription lost, please subscribe again.');\n    this.subscriptions.forEach(id => this.emit(id, error)); // Send Error objects to any open subscriptions\n    this.subscriptions = []; // Clear subscriptions\n    this.manualChainId = undefined;\n    this.providerChainId = undefined;\n    this.networkVersion = undefined;\n    this.selectedAddress = undefined;\n    this.coinbase = undefined;\n  }\n  async request(payload) {\n    return this.doSend(payload.method, payload.params, payload.chainId);\n  }\n  setChain(chainId) {\n    if (typeof chainId === 'number') chainId = '0x' + chainId.toString(16);\n    const chainChanged = chainId !== this.chainId;\n    this.manualChainId = chainId;\n    if (chainChanged) {\n      this.emit('chainChanged', this.chainId);\n    }\n  }\n}\nexports.default = Provider;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","events_1","require","payload_1","Provider","default","constructor","connection","promises","attemptedSubscriptions","Set","subscriptions","checkConnectionRunning","nextId","connected","accounts","selectedAddress","undefined","coinbase","enable","bind","doSend","send","sendBatch","subscribe","unsubscribe","resumeSubscriptions","sendAsync","sendAsyncBatch","isConnected","close","request","on","checkConnection","clear","emit","payload","id","method","error","result","requestMethod","includes","reject","resolve","indexOf","params","subscription","type","data","event","keys","eventHandlers","attemptedSubscription","startSubscription","console","warn","networkChanged","netId","networkVersion","parseInt","chainChanged","chainId","providerChainId","manualChainId","chainsChanged","chains","accountsChanged","assetsChanged","assets","retryTimeout","clearTimeout","checkConnectionTimer","e","setTimeout","has","setSubscriptionAttempted","add","debug","eventId","forEach","listenerCount","length","err","Error","code","rawPayload","rawParams","targetChain","waitForConnection","sendFn","chainTarget","create","Promise","resolveSend","disconnectTimer","off","once","methodOrPayload","callbackOrArgs","Array","isArray","cb","requests","all","map","push","success","filter","_id","removeAllListeners","payloads","p","jsonrpc","callback","results","entry","index","setChain","toString"],"sources":["C:/Users/SUMAN K/meta_transfer/node_modules/ethereum-provider/dist/index.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = __importDefault(require(\"events\"));\nconst payload_1 = require(\"./payload\");\nclass Provider extends events_1.default {\n    constructor(connection) {\n        super();\n        this.promises = {};\n        this.attemptedSubscriptions = new Set();\n        this.subscriptions = [];\n        this.checkConnectionRunning = false;\n        this.nextId = 1;\n        this.connected = false;\n        this.accounts = [];\n        this.selectedAddress = undefined;\n        this.coinbase = undefined;\n        this.enable = this.enable.bind(this);\n        this.doSend = this.doSend.bind(this);\n        this.send = this.send.bind(this);\n        this.sendBatch = this.sendBatch.bind(this);\n        this.subscribe = this.subscribe.bind(this);\n        this.unsubscribe = this.unsubscribe.bind(this);\n        this.resumeSubscriptions = this.resumeSubscriptions.bind(this);\n        this.sendAsync = this.sendAsync.bind(this);\n        this.sendAsyncBatch = this.sendAsyncBatch.bind(this);\n        this.isConnected = this.isConnected.bind(this);\n        this.close = this.close.bind(this);\n        this.request = this.request.bind(this);\n        this.connection = connection;\n        this.on('connect', this.resumeSubscriptions);\n        this.connection.on('connect', () => this.checkConnection(1000));\n        this.connection.on('close', () => {\n            this.connected = false;\n            this.attemptedSubscriptions.clear();\n            this.emit('close');\n            this.emit('disconnect');\n        });\n        this.connection.on('payload', payload => {\n            const { id, method, error, result } = payload;\n            if (typeof id !== 'undefined') {\n                if (this.promises[id]) { // Fulfill promise\n                    const requestMethod = this.promises[id].method;\n                    if (requestMethod && ['eth_accounts', 'eth_requestAccounts'].includes(requestMethod)) {\n                        const accounts = result || [];\n                        this.accounts = accounts;\n                        this.selectedAddress = accounts[0];\n                        this.coinbase = accounts[0];\n                    }\n                    payload.error ? this.promises[id].reject(error) : this.promises[id].resolve(result);\n                    delete this.promises[id];\n                }\n            }\n            else if (method && method.indexOf('_subscription') > -1) { // Emit subscription result\n                // Events: connect, disconnect, chainChanged, chainsChanged, accountsChanged, assetsChanged, message\n                this.emit(payload.params.subscription, payload.params.result);\n                this.emit(method, payload.params); // Older EIP-1193\n                this.emit('message', {\n                    type: payload.method,\n                    data: {\n                        subscription: payload.params.subscription,\n                        result: payload.params.result\n                    }\n                });\n                this.emit('data', payload); // Backwards Compatibility\n            }\n        });\n        this.on('newListener', event => {\n            if (Object.keys(this.eventHandlers).includes(event)) {\n                if (!this.attemptedSubscription(event) && this.connected) {\n                    this.startSubscription(event);\n                    if (event === 'networkChanged') {\n                        console.warn('The networkChanged event is being deprecated, use chainChanged instead');\n                    }\n                }\n            }\n        });\n        this.eventHandlers = {\n            networkChanged: netId => {\n                this.networkVersion = (typeof netId === 'string') ? parseInt(netId) : netId;\n                this.emit('networkChanged', this.networkVersion);\n            },\n            chainChanged: chainId => {\n                this.providerChainId = chainId;\n                if (!this.manualChainId) {\n                    this.emit('chainChanged', chainId);\n                }\n            },\n            chainsChanged: chains => {\n                this.emit('chainsChanged', chains);\n            },\n            accountsChanged: (accounts) => {\n                this.selectedAddress = accounts[0];\n                this.emit('accountsChanged', accounts);\n            },\n            assetsChanged: assets => {\n                this.emit('assetsChanged', assets);\n            }\n        };\n    }\n    get chainId() {\n        return this.manualChainId || this.providerChainId;\n    }\n    async checkConnection(retryTimeout = 4000) {\n        if (this.checkConnectionRunning || this.connected)\n            return;\n        clearTimeout(this.checkConnectionTimer);\n        this.checkConnectionTimer = undefined;\n        this.checkConnectionRunning = true;\n        try {\n            this.networkVersion = await this.doSend('net_version', [], undefined, false);\n            this.providerChainId = await this.doSend('eth_chainId', [], undefined, false);\n            this.connected = true;\n        }\n        catch (e) {\n            this.checkConnectionTimer = setTimeout(() => this.checkConnection(), retryTimeout);\n            this.connected = false;\n        }\n        finally {\n            this.checkConnectionRunning = false;\n            if (this.connected) {\n                this.emit('connect', { chainId: this.providerChainId });\n            }\n        }\n    }\n    attemptedSubscription(event) {\n        return this.attemptedSubscriptions.has(event);\n    }\n    setSubscriptionAttempted(event) {\n        this.attemptedSubscriptions.add(event);\n    }\n    async startSubscription(event) {\n        console.debug(`starting subscription for ${event} events`);\n        this.setSubscriptionAttempted(event);\n        try {\n            const eventId = await (this.subscribe('eth_subscribe', event));\n            this.on(eventId, this.eventHandlers[event]);\n        }\n        catch (e) {\n            console.warn(`Unable to subscribe to ${event}`, e);\n        }\n    }\n    resumeSubscriptions() {\n        Object.keys(this.eventHandlers).forEach(event => {\n            if (this.listenerCount(event) && !this.attemptedSubscription(event))\n                this.startSubscription(event);\n        });\n    }\n    async enable() {\n        const accounts = await this.doSend('eth_accounts');\n        if (accounts.length > 0) {\n            this.accounts = accounts;\n            this.selectedAddress = accounts[0];\n            this.coinbase = accounts[0];\n            this.emit('enable');\n            return accounts;\n        }\n        else {\n            const err = new Error('User Denied Full Provider');\n            err.code = '4001';\n            throw err;\n        }\n    }\n    doSend(rawPayload, rawParams = [], targetChain = this.manualChainId, waitForConnection = true) {\n        const sendFn = (resolve, reject) => {\n            const method = (typeof rawPayload === 'object') ? rawPayload.method : rawPayload;\n            const params = (typeof rawPayload === 'object') ? rawPayload.params : rawParams;\n            const chainTarget = ((typeof rawPayload === 'object') && rawPayload.chainId) || targetChain;\n            if (!method) {\n                return reject(new Error('Method is not a valid string.'));\n            }\n            try {\n                const payload = (0, payload_1.create)(method, params, this.nextId++, chainTarget);\n                this.promises[payload.id] = {\n                    resolve: (result) => resolve(result),\n                    reject,\n                    method: payload.method\n                };\n                this.connection.send(payload);\n            }\n            catch (e) {\n                reject(e);\n            }\n        };\n        if (this.connected || !waitForConnection) {\n            return new Promise(sendFn);\n        }\n        return new Promise((resolve, reject) => {\n            const resolveSend = () => {\n                clearTimeout(disconnectTimer);\n                return resolve(new Promise(sendFn));\n            };\n            const disconnectTimer = setTimeout(() => {\n                this.off('connect', resolveSend);\n                reject(new Error('Not connected'));\n            }, 5000);\n            this.once('connect', resolveSend);\n        });\n    }\n    async send(methodOrPayload, callbackOrArgs) {\n        if (typeof methodOrPayload === 'string' &&\n            (!callbackOrArgs || Array.isArray(callbackOrArgs))) {\n            const params = callbackOrArgs;\n            return this.doSend(methodOrPayload, params);\n        }\n        if (methodOrPayload &&\n            typeof methodOrPayload === 'object' &&\n            typeof callbackOrArgs === 'function') {\n            // a callback was passed to send(), forward everything to sendAsync()\n            const cb = callbackOrArgs;\n            return this.sendAsync(methodOrPayload, cb);\n        }\n        return this.request(methodOrPayload);\n    }\n    sendBatch(requests) {\n        return Promise.all(requests.map(payload => {\n            return this.doSend(payload.method, payload.params);\n        }));\n    }\n    async subscribe(type, method, params = []) {\n        const id = await this.doSend(type, [method, ...params]);\n        this.subscriptions.push(id);\n        return id;\n    }\n    async unsubscribe(type, id) {\n        const success = await this.doSend(type, [id]);\n        if (success) {\n            this.subscriptions = this.subscriptions.filter(_id => _id !== id); // Remove subscription\n            this.removeAllListeners(id); // Remove listeners\n            return success;\n        }\n    }\n    async sendAsync(rawPayload, cb) {\n        if (!cb || typeof cb !== 'function')\n            return new Error('Invalid or undefined callback provided to sendAsync');\n        if (!rawPayload)\n            return cb(new Error('Invalid Payload'));\n        // sendAsync can be called with an array for batch requests used by web3.js 0.x\n        // this is not part of EIP-1193's backwards compatibility but we still want to support it\n        if (Array.isArray(rawPayload)) {\n            const payloads = rawPayload.map(p => ({ ...p, jsonrpc: '2.0' }));\n            const callback = cb;\n            return this.sendAsyncBatch(payloads, callback);\n        }\n        else {\n            const payload = { ...rawPayload, jsonrpc: '2.0' };\n            const callback = cb;\n            try {\n                const result = await this.doSend(payload.method, payload.params);\n                callback(null, { id: payload.id, jsonrpc: payload.jsonrpc, result });\n            }\n            catch (e) {\n                callback(e);\n            }\n        }\n    }\n    async sendAsyncBatch(payloads, cb) {\n        try {\n            const results = await this.sendBatch(payloads);\n            const result = results.map((entry, index) => {\n                return { id: payloads[index].id, jsonrpc: payloads[index].jsonrpc, result: entry };\n            });\n            cb(null, result);\n        }\n        catch (e) {\n            cb(e);\n        }\n    }\n    isConnected() {\n        return this.connected;\n    }\n    close() {\n        if (this.connection && this.connection.close)\n            this.connection.close();\n        this.off('connect', this.resumeSubscriptions);\n        this.connected = false;\n        const error = new Error('Provider closed, subscription lost, please subscribe again.');\n        this.subscriptions.forEach(id => this.emit(id, error)); // Send Error objects to any open subscriptions\n        this.subscriptions = []; // Clear subscriptions\n        this.manualChainId = undefined;\n        this.providerChainId = undefined;\n        this.networkVersion = undefined;\n        this.selectedAddress = undefined;\n        this.coinbase = undefined;\n    }\n    async request(payload) {\n        return this.doSend(payload.method, payload.params, payload.chainId);\n    }\n    setChain(chainId) {\n        if (typeof chainId === 'number')\n            chainId = '0x' + chainId.toString(16);\n        const chainChanged = (chainId !== this.chainId);\n        this.manualChainId = chainId;\n        if (chainChanged) {\n            this.emit('chainChanged', this.chainId);\n        }\n    }\n}\nexports.default = Provider;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}