{"ast":null,"code":"/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b, _c, _d, _e, _f;\nimport { Mesh } from 'three';\nimport { $setActive, $variantSet, Material } from './material.js';\nimport { $children, Node, PrimitiveNode } from './nodes/primitive-node.js';\nimport { $correlatedObjects, $sourceObject } from './three-dom-element.js';\nexport const $materials = Symbol('materials');\nconst $hierarchy = Symbol('hierarchy');\nconst $roots = Symbol('roots');\nexport const $primitivesList = Symbol('primitives');\nexport const $loadVariant = Symbol('loadVariant');\nexport const $correlatedSceneGraph = Symbol('correlatedSceneGraph');\nexport const $prepareVariantsForExport = Symbol('prepareVariantsForExport');\nexport const $switchVariant = Symbol('switchVariant');\nexport const $threeScene = Symbol('threeScene');\nexport const $materialsFromPoint = Symbol('materialsFromPoint');\nexport const $materialFromPoint = Symbol('materialFromPoint');\nexport const $variantData = Symbol('variantData');\nexport const $availableVariants = Symbol('availableVariants');\nconst $modelOnUpdate = Symbol('modelOnUpdate');\nconst $cloneMaterial = Symbol('cloneMaterial');\n// Holds onto temporary scene context information needed to perform lazy loading\n// of a resource.\nexport class LazyLoader {\n  constructor(gltf, gltfElementMap, mapKey, doLazyLoad) {\n    this.gltf = gltf;\n    this.gltfElementMap = gltfElementMap;\n    this.mapKey = mapKey;\n    this.doLazyLoad = doLazyLoad;\n  }\n}\n/**\n * A Model facades the top-level GLTF object returned by Three.js' GLTFLoader.\n * Currently, the model only bothers itself with the materials in the Three.js\n * scene graph.\n */\nexport class Model {\n  constructor(correlatedSceneGraph, onUpdate = () => {}) {\n    this[_a] = new Array();\n    this[_b] = new Array();\n    this[_c] = new Array();\n    this[_d] = new Array();\n    this[_e] = () => {};\n    this[_f] = new Map();\n    this[$modelOnUpdate] = onUpdate;\n    this[$correlatedSceneGraph] = correlatedSceneGraph;\n    const {\n      gltf,\n      threeGLTF,\n      gltfElementMap\n    } = correlatedSceneGraph;\n    this[$threeScene] = threeGLTF.scene;\n    for (const [i, material] of gltf.materials.entries()) {\n      const correlatedMaterial = gltfElementMap.get(material);\n      if (correlatedMaterial != null) {\n        this[$materials].push(new Material(onUpdate, gltf, material, i, true, this[$variantData], correlatedMaterial));\n      } else {\n        const elementArray = gltf['materials'] || [];\n        const gltfMaterialDef = elementArray[i];\n        // Loads the three.js material.\n        const capturedMatIndex = i;\n        const materialLoadCallback = async () => {\n          const threeMaterial = await threeGLTF.parser.getDependency('material', capturedMatIndex);\n          // Adds correlation, maps the variant gltf-def to the\n          // three material set containing the variant material.\n          const threeMaterialSet = new Set();\n          gltfElementMap.set(gltfMaterialDef, threeMaterialSet);\n          threeMaterialSet.add(threeMaterial);\n          return {\n            set: threeMaterialSet,\n            material: threeMaterial\n          };\n        };\n        // Configures the material for lazy loading.\n        this[$materials].push(new Material(onUpdate, gltf, gltfMaterialDef, i, false, this[$variantData], correlatedMaterial, new LazyLoader(gltf, gltfElementMap, gltfMaterialDef, materialLoadCallback)));\n      }\n    }\n    // Creates a hierarchy of Nodes. Allows not just for switching which\n    // material is applied to a mesh but also exposes a way to provide API\n    // for switching materials and general assignment/modification.\n    // Prepares for scene iteration.\n    const parentMap = new Map();\n    const nodeStack = new Array();\n    for (const object of threeGLTF.scene.children) {\n      nodeStack.push(object);\n    }\n    // Walks the hierarchy and creates a node tree.\n    while (nodeStack.length > 0) {\n      const object = nodeStack.pop();\n      let node = null;\n      if (object instanceof Mesh) {\n        node = new PrimitiveNode(object, this.materials, this[$variantData], correlatedSceneGraph);\n        this[$primitivesList].push(node);\n      } else {\n        node = new Node(object.name);\n      }\n      const parent = parentMap.get(object);\n      if (parent != null) {\n        parent[$children].push(node);\n      } else {\n        this[$roots].push(node);\n      }\n      this[$hierarchy].push(node);\n      for (const child of object.children) {\n        nodeStack.push(child);\n        parentMap.set(object, node);\n      }\n    }\n  }\n  /**\n   * Materials are listed in the order of the GLTF materials array, plus a\n   * default material at the end if one is used.\n   *\n   * TODO(#1003): How do we handle non-active scenes?\n   */\n  get materials() {\n    return this[$materials];\n  }\n  [(_a = $materials, _b = $hierarchy, _c = $roots, _d = $primitivesList, _e = $modelOnUpdate, _f = $variantData, $availableVariants)]() {\n    const variants = Array.from(this[$variantData].values());\n    variants.sort((a, b) => {\n      return a.index - b.index;\n    });\n    return variants.map(data => {\n      return data.name;\n    });\n  }\n  getMaterialByName(name) {\n    const matches = this[$materials].filter(material => {\n      return material.name === name;\n    });\n    if (matches.length > 0) {\n      return matches[0];\n    }\n    return null;\n  }\n  /**\n   * Intersects a ray with the Model and returns a list of materials whose\n   * objects were intersected.\n   */\n  [$materialsFromPoint](raycaster) {\n    const hits = raycaster.intersectObject(this[$threeScene], true);\n    // Map the object hits to primitives and then to the active material of\n    // the primitive.\n    return hits.map(hit => {\n      const found = this[$hierarchy].find(node => {\n        if (node instanceof PrimitiveNode) {\n          const primitive = node;\n          if (primitive.mesh === hit.object) {\n            return true;\n          }\n        }\n        return false;\n      });\n      if (found != null) {\n        return found.getActiveMaterial();\n      }\n      return null;\n    });\n  }\n  /**\n   * Intersects a ray with the Model and returns the first material whose\n   * object was intersected.\n   */\n  [$materialFromPoint](raycaster) {\n    const materials = this[$materialsFromPoint](raycaster);\n    if (materials.length > 0) {\n      return materials[0];\n    }\n    return null;\n  }\n  /**\n   * Switches model variant to the variant name provided, or switches to\n   * default/initial materials if 'null' is provided.\n   */\n  async [$switchVariant](variantName) {\n    for (const primitive of this[$primitivesList]) {\n      await primitive.enableVariant(variantName);\n    }\n    for (const material of this.materials) {\n      material[$setActive](false);\n    }\n    // Marks the materials that are now in use after the variant switch.\n    for (const primitive of this[$primitivesList]) {\n      this.materials[primitive.getActiveMaterial().index][$setActive](true);\n    }\n  }\n  async [$prepareVariantsForExport]() {\n    const promises = new Array();\n    for (const primitive of this[$primitivesList]) {\n      promises.push(primitive.instantiateVariants());\n    }\n    await Promise.all(promises);\n  }\n  [$cloneMaterial](index, newMaterialName) {\n    const material = this.materials[index];\n    if (!material.isLoaded) {\n      console.error(`Cloning an unloaded material,\n           call 'material.ensureLoaded() before cloning the material.`);\n    }\n    const threeMaterialSet = material[$correlatedObjects];\n    // clones the gltf material data and updates the material name.\n    const gltfSourceMaterial = JSON.parse(JSON.stringify(material[$sourceObject]));\n    gltfSourceMaterial.name = newMaterialName;\n    // Adds the source material clone to the gltf def.\n    const gltf = this[$correlatedSceneGraph].gltf;\n    gltf.materials.push(gltfSourceMaterial);\n    const clonedSet = new Set();\n    for (const [i, threeMaterial] of threeMaterialSet.entries()) {\n      const clone = threeMaterial.clone();\n      clone.name = newMaterialName + (threeMaterialSet.size > 1 ? '_inst' + i : '');\n      clonedSet.add(clone);\n    }\n    const clonedMaterial = new Material(this[$modelOnUpdate], this[$correlatedSceneGraph].gltf, gltfSourceMaterial, this[$materials].length, false,\n    // Cloned as inactive.\n    this[$variantData], clonedSet);\n    this[$materials].push(clonedMaterial);\n    return clonedMaterial;\n  }\n  createMaterialInstanceForVariant(originalMaterialIndex, newMaterialName, variantName, activateVariant = true) {\n    let variantMaterialInstance = null;\n    for (const primitive of this[$primitivesList]) {\n      const variantData = this[$variantData].get(variantName);\n      // Skips the primitive if the variant already exists.\n      if (variantData != null && primitive.variantInfo.has(variantData.index)) {\n        continue;\n      }\n      // Skips the primitive if the source/original material does not exist.\n      if (primitive.getMaterial(originalMaterialIndex) == null) {\n        continue;\n      }\n      if (!this.hasVariant(variantName)) {\n        this.createVariant(variantName);\n      }\n      if (variantMaterialInstance == null) {\n        variantMaterialInstance = this[$cloneMaterial](originalMaterialIndex, newMaterialName);\n      }\n      primitive.addVariant(variantMaterialInstance, variantName);\n    }\n    if (activateVariant && variantMaterialInstance != null) {\n      variantMaterialInstance[$setActive](true);\n      this.materials[originalMaterialIndex][$setActive](false);\n      for (const primitive of this[$primitivesList]) {\n        primitive.enableVariant(variantName);\n      }\n    }\n    return variantMaterialInstance;\n  }\n  createVariant(variantName) {\n    if (!this[$variantData].has(variantName)) {\n      // Adds the name if it's not already in the list.\n      this[$variantData].set(variantName, {\n        name: variantName,\n        index: this[$variantData].size\n      });\n    } else {\n      console.warn(`Variant '${variantName}'' already exists`);\n    }\n  }\n  hasVariant(variantName) {\n    return this[$variantData].has(variantName);\n  }\n  setMaterialToVariant(materialIndex, targetVariantName) {\n    if (this[$availableVariants]().find(name => name === targetVariantName) == null) {\n      console.warn(`Can't add material to '${targetVariantName}', the variant does not exist.'`);\n      return;\n    }\n    if (materialIndex < 0 || materialIndex >= this.materials.length) {\n      console.error(`setMaterialToVariant(): materialIndex is out of bounds.`);\n      return;\n    }\n    for (const primitive of this[$primitivesList]) {\n      const material = primitive.getMaterial(materialIndex);\n      // Ensures the material exists on the primitive before setting it to a\n      // variant.\n      if (material != null) {\n        primitive.addVariant(material, targetVariantName);\n      }\n    }\n  }\n  updateVariantName(currentName, newName) {\n    const variantData = this[$variantData].get(currentName);\n    if (variantData == null) {\n      return;\n    }\n    variantData.name = newName;\n    this[$variantData].set(newName, variantData);\n    this[$variantData].delete(currentName);\n  }\n  deleteVariant(variantName) {\n    const variant = this[$variantData].get(variantName);\n    if (variant == null) {\n      return;\n    }\n    for (const material of this.materials) {\n      if (material.hasVariant(variantName)) {\n        material[$variantSet].delete(variant.index);\n      }\n    }\n    for (const primitive of this[$primitivesList]) {\n      primitive.deleteVariant(variant.index);\n    }\n    this[$variantData].delete(variantName);\n  }\n}","map":{"version":3,"names":["Mesh","$setActive","$variantSet","Material","$children","Node","PrimitiveNode","$correlatedObjects","$sourceObject","$materials","Symbol","$hierarchy","$roots","$primitivesList","$loadVariant","$correlatedSceneGraph","$prepareVariantsForExport","$switchVariant","$threeScene","$materialsFromPoint","$materialFromPoint","$variantData","$availableVariants","$modelOnUpdate","$cloneMaterial","LazyLoader","constructor","gltf","gltfElementMap","mapKey","doLazyLoad","Model","correlatedSceneGraph","onUpdate","_a","Array","_b","_c","_d","_e","_f","Map","threeGLTF","scene","i","material","materials","entries","correlatedMaterial","get","push","elementArray","gltfMaterialDef","capturedMatIndex","materialLoadCallback","threeMaterial","parser","getDependency","threeMaterialSet","Set","set","add","parentMap","nodeStack","object","children","length","pop","node","name","parent","child","variants","from","values","sort","a","b","index","map","data","getMaterialByName","matches","filter","raycaster","hits","intersectObject","hit","found","find","primitive","mesh","getActiveMaterial","variantName","enableVariant","promises","instantiateVariants","Promise","all","newMaterialName","isLoaded","console","error","gltfSourceMaterial","JSON","parse","stringify","clonedSet","clone","size","clonedMaterial","createMaterialInstanceForVariant","originalMaterialIndex","activateVariant","variantMaterialInstance","variantData","variantInfo","has","getMaterial","hasVariant","createVariant","addVariant","warn","setMaterialToVariant","materialIndex","targetVariantName","updateVariantName","currentName","newName","delete","deleteVariant","variant"],"sources":["C:\\Users\\SUMAN K\\meta_transfer\\node_modules\\@google\\model-viewer\\src\\features\\scene-graph\\model.ts"],"sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Group, Intersection, Material as ThreeMaterial, Mesh, MeshStandardMaterial, Object3D, Raycaster} from 'three';\n\nimport {CorrelatedSceneGraph, GLTFElementToThreeObjectMap, ThreeObjectSet} from '../../three-components/gltf-instance/correlated-scene-graph.js';\nimport {GLTF, GLTFElement, Material as GLTFMaterial} from '../../three-components/gltf-instance/gltf-2.0.js';\n\nimport {Model as ModelInterface} from './api.js';\nimport {$setActive, $variantSet, Material} from './material.js';\nimport {$children, Node, PrimitiveNode} from './nodes/primitive-node.js';\nimport {$correlatedObjects, $sourceObject} from './three-dom-element.js';\n\n\n\nexport const $materials = Symbol('materials');\nconst $hierarchy = Symbol('hierarchy');\nconst $roots = Symbol('roots');\nexport const $primitivesList = Symbol('primitives');\nexport const $loadVariant = Symbol('loadVariant');\nexport const $correlatedSceneGraph = Symbol('correlatedSceneGraph');\nexport const $prepareVariantsForExport = Symbol('prepareVariantsForExport');\nexport const $switchVariant = Symbol('switchVariant');\nexport const $threeScene = Symbol('threeScene');\nexport const $materialsFromPoint = Symbol('materialsFromPoint');\nexport const $materialFromPoint = Symbol('materialFromPoint');\nexport const $variantData = Symbol('variantData');\nexport const $availableVariants = Symbol('availableVariants');\nconst $modelOnUpdate = Symbol('modelOnUpdate');\nconst $cloneMaterial = Symbol('cloneMaterial');\n\n// Holds onto temporary scene context information needed to perform lazy loading\n// of a resource.\nexport class LazyLoader {\n  gltf: GLTF;\n  gltfElementMap: GLTFElementToThreeObjectMap;\n  mapKey: GLTFElement;\n  doLazyLoad: () => Promise<{set: ThreeObjectSet, material: ThreeMaterial}>;\n  constructor(\n      gltf: GLTF, gltfElementMap: GLTFElementToThreeObjectMap,\n      mapKey: GLTFElement,\n      doLazyLoad:\n          () => Promise<{set: ThreeObjectSet, material: ThreeMaterial}>) {\n    this.gltf = gltf;\n    this.gltfElementMap = gltfElementMap;\n    this.mapKey = mapKey;\n    this.doLazyLoad = doLazyLoad;\n  }\n}\n\n/**\n * Facades variant mapping data.\n */\nexport interface VariantData {\n  name: string;\n  index: number;\n}\n\n/**\n * A Model facades the top-level GLTF object returned by Three.js' GLTFLoader.\n * Currently, the model only bothers itself with the materials in the Three.js\n * scene graph.\n */\nexport class Model implements ModelInterface {\n  private[$materials] = new Array<Material>();\n  private[$hierarchy] = new Array<Node>();\n  private[$roots] = new Array<Node>();\n  private[$primitivesList] = new Array<PrimitiveNode>();\n  private[$threeScene]: Object3D|Group;\n  private[$modelOnUpdate]: () => void = () => {};\n  private[$correlatedSceneGraph]: CorrelatedSceneGraph;\n  private[$variantData] = new Map<string, VariantData>();\n\n  constructor(\n      correlatedSceneGraph: CorrelatedSceneGraph,\n      onUpdate: () => void = () => {}) {\n    this[$modelOnUpdate] = onUpdate;\n    this[$correlatedSceneGraph] = correlatedSceneGraph;\n    const {gltf, threeGLTF, gltfElementMap} = correlatedSceneGraph;\n    this[$threeScene] = threeGLTF.scene;\n\n    for (const [i, material] of gltf.materials!.entries()) {\n      const correlatedMaterial =\n          gltfElementMap.get(material) as Set<MeshStandardMaterial>;\n\n      if (correlatedMaterial != null) {\n        this[$materials].push(new Material(\n            onUpdate,\n            gltf,\n            material,\n            i,\n            true,\n            this[$variantData],\n            correlatedMaterial));\n      } else {\n        const elementArray = gltf['materials'] || [];\n        const gltfMaterialDef = elementArray[i];\n\n        // Loads the three.js material.\n        const capturedMatIndex = i;\n        const materialLoadCallback = async () => {\n          const threeMaterial =\n              await threeGLTF.parser.getDependency(\n                  'material', capturedMatIndex) as MeshStandardMaterial;\n\n          // Adds correlation, maps the variant gltf-def to the\n          // three material set containing the variant material.\n          const threeMaterialSet = new Set<MeshStandardMaterial>();\n          gltfElementMap.set(gltfMaterialDef, threeMaterialSet);\n          threeMaterialSet.add(threeMaterial);\n\n          return {set: threeMaterialSet, material: threeMaterial};\n        };\n\n        // Configures the material for lazy loading.\n        this[$materials].push(new Material(\n            onUpdate,\n            gltf,\n            gltfMaterialDef,\n            i,\n            false,\n            this[$variantData],\n            correlatedMaterial,\n            new LazyLoader(\n                gltf, gltfElementMap, gltfMaterialDef, materialLoadCallback)));\n      }\n    }\n\n    // Creates a hierarchy of Nodes. Allows not just for switching which\n    // material is applied to a mesh but also exposes a way to provide API\n    // for switching materials and general assignment/modification.\n\n    // Prepares for scene iteration.\n    const parentMap = new Map<object, Node>();\n    const nodeStack = new Array<Object3D>();\n    for (const object of threeGLTF.scene.children) {\n      nodeStack.push(object);\n    }\n\n    // Walks the hierarchy and creates a node tree.\n    while (nodeStack.length > 0) {\n      const object = nodeStack.pop()!;\n\n      let node: Node|null = null;\n\n      if (object instanceof Mesh) {\n        node = new PrimitiveNode(\n            object as Mesh,\n            this.materials,\n            this[$variantData],\n            correlatedSceneGraph);\n        this[$primitivesList].push(node as PrimitiveNode);\n      } else {\n        node = new Node(object.name);\n      }\n\n      const parent: Node|undefined = parentMap.get(object);\n      if (parent != null) {\n        parent[$children].push(node);\n      } else {\n        this[$roots].push(node);\n      }\n      this[$hierarchy].push(node);\n\n      for (const child of object.children) {\n        nodeStack.push(child);\n        parentMap.set(object, node);\n      }\n    }\n  }\n\n  /**\n   * Materials are listed in the order of the GLTF materials array, plus a\n   * default material at the end if one is used.\n   *\n   * TODO(#1003): How do we handle non-active scenes?\n   */\n  get materials(): Material[] {\n    return this[$materials];\n  }\n\n  [$availableVariants]() {\n    const variants = Array.from(this[$variantData].values());\n    variants.sort((a, b) => {\n      return a.index - b.index;\n    });\n\n    return variants.map((data) => {\n      return data.name;\n    });\n  }\n\n  getMaterialByName(name: string): Material|null {\n    const matches = this[$materials].filter(material => {\n      return material.name === name;\n    });\n\n    if (matches.length > 0) {\n      return matches[0];\n    }\n    return null;\n  }\n\n\n  /**\n   * Intersects a ray with the Model and returns a list of materials whose\n   * objects were intersected.\n   */\n  [$materialsFromPoint](raycaster: Raycaster): Material[] {\n    const hits = raycaster.intersectObject(this[$threeScene], true);\n\n    // Map the object hits to primitives and then to the active material of\n    // the primitive.\n    return hits.map((hit: Intersection<Object3D>) => {\n      const found = this[$hierarchy].find((node: Node) => {\n        if (node instanceof PrimitiveNode) {\n          const primitive = node as PrimitiveNode;\n          if (primitive.mesh === hit.object) {\n            return true;\n          }\n        }\n        return false;\n      }) as PrimitiveNode;\n\n      if (found != null) {\n        return found.getActiveMaterial();\n      }\n      return null;\n    }) as Material[];\n  }\n\n  /**\n   * Intersects a ray with the Model and returns the first material whose\n   * object was intersected.\n   */\n  [$materialFromPoint](raycaster: Raycaster): Material|null {\n    const materials = this[$materialsFromPoint](raycaster);\n\n    if (materials.length > 0) {\n      return materials[0];\n    }\n\n    return null;\n  }\n\n  /**\n   * Switches model variant to the variant name provided, or switches to\n   * default/initial materials if 'null' is provided.\n   */\n  async[$switchVariant](variantName: string|null) {\n    for (const primitive of this[$primitivesList]) {\n      await primitive.enableVariant(variantName);\n    }\n\n    for (const material of this.materials) {\n      material[$setActive](false);\n    }\n    // Marks the materials that are now in use after the variant switch.\n    for (const primitive of this[$primitivesList]) {\n      this.materials[primitive.getActiveMaterial().index][$setActive](true);\n    }\n  }\n\n  async[$prepareVariantsForExport]() {\n    const promises = new Array<Promise<void>>();\n    for (const primitive of this[$primitivesList]) {\n      promises.push(primitive.instantiateVariants());\n    }\n    await Promise.all(promises);\n  }\n\n  [$cloneMaterial](index: number, newMaterialName: string): Material {\n    const material = this.materials[index];\n\n    if (!material.isLoaded) {\n      console.error(`Cloning an unloaded material,\n           call 'material.ensureLoaded() before cloning the material.`);\n    }\n\n    const threeMaterialSet =\n        material[$correlatedObjects] as Set<MeshStandardMaterial>;\n\n    // clones the gltf material data and updates the material name.\n    const gltfSourceMaterial =\n        JSON.parse(JSON.stringify(material[$sourceObject])) as GLTFMaterial;\n    gltfSourceMaterial.name = newMaterialName;\n    // Adds the source material clone to the gltf def.\n    const gltf = this[$correlatedSceneGraph].gltf;\n    gltf.materials!.push(gltfSourceMaterial);\n\n    const clonedSet = new Set<MeshStandardMaterial>();\n    for (const [i, threeMaterial] of threeMaterialSet.entries()) {\n      const clone = threeMaterial.clone() as MeshStandardMaterial;\n      clone.name =\n          newMaterialName + (threeMaterialSet.size > 1 ? '_inst' + i : '');\n      clonedSet.add(clone);\n    }\n\n    const clonedMaterial = new Material(\n        this[$modelOnUpdate],\n        this[$correlatedSceneGraph].gltf,\n        gltfSourceMaterial,\n        this[$materials].length,\n        false,  // Cloned as inactive.\n        this[$variantData],\n        clonedSet);\n\n    this[$materials].push(clonedMaterial);\n\n    return clonedMaterial;\n  }\n\n  createMaterialInstanceForVariant(\n      originalMaterialIndex: number, newMaterialName: string,\n      variantName: string, activateVariant: boolean = true): Material|null {\n    let variantMaterialInstance: Material|null = null;\n\n    for (const primitive of this[$primitivesList]) {\n      const variantData = this[$variantData].get(variantName);\n      // Skips the primitive if the variant already exists.\n      if (variantData != null && primitive.variantInfo.has(variantData.index)) {\n        continue;\n      }\n\n      // Skips the primitive if the source/original material does not exist.\n      if (primitive.getMaterial(originalMaterialIndex) == null) {\n        continue;\n      }\n\n      if (!this.hasVariant(variantName)) {\n        this.createVariant(variantName);\n      }\n\n      if (variantMaterialInstance == null) {\n        variantMaterialInstance =\n            this[$cloneMaterial](originalMaterialIndex, newMaterialName);\n      }\n      primitive.addVariant(variantMaterialInstance, variantName)\n    }\n\n    if (activateVariant && variantMaterialInstance != null) {\n      (variantMaterialInstance as Material)[$setActive](true);\n      this.materials[originalMaterialIndex][$setActive](false);\n      for (const primitive of this[$primitivesList]) {\n        primitive.enableVariant(variantName);\n      }\n    }\n\n    return variantMaterialInstance;\n  }\n\n  createVariant(variantName: string) {\n    if (!this[$variantData].has(variantName)) {\n      // Adds the name if it's not already in the list.\n      this[$variantData].set(\n          variantName,\n          {name: variantName, index: this[$variantData].size} as VariantData);\n    } else {\n      console.warn(`Variant '${variantName}'' already exists`);\n    }\n  }\n\n  hasVariant(variantName: string) {\n    return this[$variantData].has(variantName);\n  }\n\n  setMaterialToVariant(materialIndex: number, targetVariantName: string) {\n    if (this[$availableVariants]().find(name => name === targetVariantName) ==\n        null) {\n      console.warn(`Can't add material to '${\n          targetVariantName}', the variant does not exist.'`);\n      return;\n    }\n\n    if (materialIndex < 0 || materialIndex >= this.materials.length) {\n      console.error(`setMaterialToVariant(): materialIndex is out of bounds.`);\n      return;\n    }\n\n    for (const primitive of this[$primitivesList]) {\n      const material = primitive.getMaterial(materialIndex);\n      // Ensures the material exists on the primitive before setting it to a\n      // variant.\n      if (material != null) {\n        primitive.addVariant(material, targetVariantName);\n      }\n    }\n  }\n\n  updateVariantName(currentName: string, newName: string) {\n    const variantData = this[$variantData].get(currentName);\n    if (variantData == null) {\n      return;\n    }\n    variantData.name = newName;\n    this[$variantData].set(newName, variantData!);\n    this[$variantData].delete(currentName);\n  }\n\n  deleteVariant(variantName: string) {\n    const variant = this[$variantData].get(variantName);\n    if (variant == null) {\n      return;\n    }\n\n    for (const material of this.materials) {\n      if (material.hasVariant(variantName)) {\n        material[$variantSet].delete(variant.index);\n      }\n    }\n\n    for (const primitive of this[$primitivesList]) {\n      primitive.deleteVariant(variant.index);\n    }\n\n    this[$variantData].delete(variantName);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}