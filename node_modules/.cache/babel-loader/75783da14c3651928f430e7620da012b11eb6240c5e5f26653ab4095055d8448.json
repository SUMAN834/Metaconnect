{"ast":null,"code":"import { getPaperOriginUrl, ChainToPublicRpc } from '@paperxyz/sdk-common-utilities';\nimport { _ as _defineProperty } from './defineProperty-c8ecdc07.browser.esm.js';\nimport { Signer, getDefaultProvider } from 'ethers';\nimport { defineReadOnly } from 'ethers/lib/utils';\nconst EMBEDDED_WALLET_PATH = \"/sdk/2022-08-12/embedded-wallet\";\nconst GET_IFRAME_BASE_URL = () => `${getPaperOriginUrl().replace(\"withpaper.com\", \"ews.thirdweb.com\")}`;\nconst WALLET_USER_DETAILS_LOCAL_STORAGE_NAME = clientId => `thirdwebEwsWalletUserDetails-${clientId}`;\nconst WALLET_USER_ID_LOCAL_STORAGE_NAME = clientId => `thirdwebEwsWalletUserId-${clientId}`;\nconst AUTH_TOKEN_LOCAL_STORAGE_PREFIX = \"walletToken\";\nconst AUTH_TOKEN_LOCAL_STORAGE_NAME = clientId => {\n  return `${AUTH_TOKEN_LOCAL_STORAGE_PREFIX}-${clientId}`;\n};\nconst DEVICE_SHARE_LOCAL_STORAGE_PREFIX = \"a\";\nconst DEVICE_SHARE_LOCAL_STORAGE_NAME = (clientId, userId) => `${DEVICE_SHARE_LOCAL_STORAGE_PREFIX}-${clientId}-${userId}`;\nconst DEVICE_SHARE_LOCAL_STORAGE_NAME_DEPRECATED = clientId => `${DEVICE_SHARE_LOCAL_STORAGE_PREFIX}-${clientId}`;\n\n// Class constructor types\n// types for class constructors still a little messy right now.\n// Open to PRs from whoever sees this and knows of a cleaner way to handle things\n// Auth Types\n// Embedded Wallet Types\nlet UserStatus = /*#__PURE__*/function (UserStatus) {\n  UserStatus[\"LOGGED_OUT\"] = \"Logged Out\";\n  UserStatus[\"LOGGED_IN_WALLET_INITIALIZED\"] = \"Logged In, Wallet Initialized\";\n  return UserStatus;\n}({});\nlet UserWalletStatus = /*#__PURE__*/function (UserWalletStatus) {\n  UserWalletStatus[\"LOGGED_OUT\"] = \"Logged Out\";\n  UserWalletStatus[\"LOGGED_IN_WALLET_UNINITIALIZED\"] = \"Logged In, Wallet Uninitialized\";\n  UserWalletStatus[\"LOGGED_IN_NEW_DEVICE\"] = \"Logged In, New Device\";\n  UserWalletStatus[\"LOGGED_IN_WALLET_INITIALIZED\"] = \"Logged In, Wallet Initialized\";\n  return UserWalletStatus;\n}({});\n\n// ! Types seem repetitive, but the name should identify which goes where\n// this is the return type from the EmbeddedWallet Class getUserWalletStatus method iframe call\n// this is the return type from the EmbeddedWallet Class getUserWalletStatus method\n// This is returned from the getUser method in PaperEmbeddedWalletSdk\n\nconst data = new Map();\nclass LocalStorage {\n  constructor(_ref) {\n    let {\n      clientId\n    } = _ref;\n    this.isSupported = !!window.localStorage;\n    this.clientId = clientId;\n  }\n  async getItem(key) {\n    if (this.isSupported) {\n      return window.localStorage.getItem(key);\n    } else {\n      return data.get(key) ?? null;\n    }\n  }\n  async setItem(key, value) {\n    if (this.isSupported) {\n      return window.localStorage.setItem(key, value);\n    } else {\n      data.set(key, value);\n    }\n  }\n  async removeItem(key) {\n    const item = await this.getItem(key);\n    if (this.isSupported && item) {\n      window.localStorage.removeItem(key);\n      return true;\n    }\n    return false;\n  }\n  async saveAuthCookie(cookie) {\n    await this.setItem(AUTH_TOKEN_LOCAL_STORAGE_NAME(this.clientId), cookie);\n  }\n  async getAuthCookie() {\n    return this.getItem(AUTH_TOKEN_LOCAL_STORAGE_NAME(this.clientId));\n  }\n  async removeAuthCookie() {\n    return this.removeItem(AUTH_TOKEN_LOCAL_STORAGE_NAME(this.clientId));\n  }\n  async saveDeviceShare(share, userId) {\n    await this.saveWalletUserId(userId);\n    await this.setItem(DEVICE_SHARE_LOCAL_STORAGE_NAME(this.clientId, userId), share);\n  }\n  async getDeviceShare() {\n    const userId = await this.getWalletUserId();\n    if (userId) {\n      return this.getItem(DEVICE_SHARE_LOCAL_STORAGE_NAME(this.clientId, userId));\n    }\n    return null;\n  }\n  async removeDeviceShare() {\n    const userId = await this.getWalletUserId();\n    if (userId) {\n      return this.removeItem(DEVICE_SHARE_LOCAL_STORAGE_NAME(this.clientId, userId));\n    }\n    return false;\n  }\n  async getWalletUserId() {\n    return this.getItem(WALLET_USER_ID_LOCAL_STORAGE_NAME(this.clientId));\n  }\n  async saveWalletUserId(userId) {\n    await this.setItem(WALLET_USER_ID_LOCAL_STORAGE_NAME(this.clientId), userId);\n  }\n  async removeWalletUserId() {\n    return this.removeItem(WALLET_USER_ID_LOCAL_STORAGE_NAME(this.clientId));\n  }\n}\nfunction sleep(seconds) {\n  return new Promise(resolve => {\n    setTimeout(resolve, seconds * 1000);\n  });\n}\nconst iframeBaseStyle = {\n  height: \"100%\",\n  width: \"100%\",\n  border: \"none\",\n  backgroundColor: \"transparent\",\n  colorScheme: \"light\",\n  position: \"fixed\",\n  top: \"0px\",\n  right: \"0px\",\n  zIndex: \"2147483646\",\n  display: \"none\"\n};\n\n// Global var to help track iframe state\nconst isIframeLoaded = new Map();\nclass IframeCommunicator {\n  constructor(_ref) {\n    let {\n      link,\n      iframeId,\n      container = document.body,\n      iframeStyles,\n      onIframeInitialize\n    } = _ref;\n    _defineProperty(this, \"POLLING_INTERVAL_SECONDS\", 1.4);\n    this.iframeBaseUrl = GET_IFRAME_BASE_URL();\n\n    // Creating the IFrame element for communication\n    let iframe = document.getElementById(iframeId);\n    const hrefLink = new URL(link);\n    const sdkVersion = \"2.0.10\";\n    hrefLink.searchParams.set(\"sdkVersion\", sdkVersion);\n    if (!iframe || iframe.src !== hrefLink.href) {\n      // ! Do not update the hrefLink here or it'll cause multiple re-renders\n      if (!iframe) {\n        iframe = document.createElement(\"iframe\");\n        const mergedIframeStyles = {\n          ...iframeBaseStyle,\n          ...iframeStyles\n        };\n        Object.assign(iframe.style, mergedIframeStyles);\n        iframe.setAttribute(\"id\", iframeId);\n        iframe.setAttribute(\"fetchpriority\", \"high\");\n        container.appendChild(iframe);\n      }\n      iframe.src = hrefLink.href;\n      iframe.setAttribute(\"data-version\", sdkVersion);\n      const onIframeLoaded = event => {\n        if (event.data.eventType === \"ewsIframeLoaded\") {\n          window.removeEventListener(\"message\", onIframeLoaded);\n          if (!iframe) {\n            console.warn(\"thirdweb Iframe not found\");\n            return;\n          }\n          this.onIframeLoadHandler(iframe, onIframeInitialize)();\n        }\n      };\n      window.addEventListener(\"message\", onIframeLoaded);\n    }\n    this.iframe = iframe;\n  }\n  async onIframeLoadedInitVariables() {\n    return {};\n  }\n  onIframeLoadHandler(iframe, onIframeInitialize) {\n    return async () => {\n      const promise = new Promise(async (res, rej) => {\n        const channel = new MessageChannel();\n        channel.port1.onmessage = event => {\n          const {\n            data\n          } = event;\n          channel.port1.close();\n          if (!data.success) {\n            return rej(new Error(data.error));\n          }\n          isIframeLoaded.set(iframe.src, true);\n          if (onIframeInitialize) {\n            onIframeInitialize();\n          }\n          return res(true);\n        };\n        const INIT_IFRAME_EVENT = \"initIframe\";\n        iframe?.contentWindow?.postMessage(\n        // ? We initialise the iframe with a bunch\n        // of useful information so that we don't have to pass it\n        // through in each of the future call. This would be where we do it.\n        {\n          eventType: INIT_IFRAME_EVENT,\n          data: await this.onIframeLoadedInitVariables()\n        }, this.iframeBaseUrl, [channel.port2]);\n      });\n      await promise;\n    };\n  }\n  async call(_ref2) {\n    let {\n      procedureName,\n      params,\n      showIframe = false\n    } = _ref2;\n    while (!isIframeLoaded.get(this.iframe.src)) {\n      await sleep(this.POLLING_INTERVAL_SECONDS);\n    }\n    if (showIframe) {\n      this.iframe.style.display = \"block\";\n      // magic number to let the display render before performing the animation of the modal in\n      await sleep(0.005);\n    }\n    const promise = new Promise((res, rej) => {\n      const channel = new MessageChannel();\n      channel.port1.onmessage = async event => {\n        const {\n          data\n        } = event;\n        channel.port1.close();\n        if (showIframe) {\n          // magic number to let modal fade out before hiding it\n          await sleep(0.1);\n          this.iframe.style.display = \"none\";\n        }\n        if (!data.success) {\n          rej(new Error(data.error));\n        } else {\n          res(data.data);\n        }\n      };\n      this.iframe.contentWindow?.postMessage({\n        eventType: procedureName,\n        data: params\n      }, this.iframeBaseUrl, [channel.port2]);\n    });\n    return promise;\n  }\n\n  /**\n   * This has to be called by any iframe that will be removed from the DOM.\n   * Use to make sure that we reset the global loaded state of the particular iframe.src\n   */\n  destroy() {\n    isIframeLoaded.delete(this.iframe.src);\n  }\n}\nclass EmbeddedWalletIframeCommunicator extends IframeCommunicator {\n  constructor(_ref) {\n    let {\n      clientId,\n      customizationOptions\n    } = _ref;\n    super({\n      iframeId: EMBEDDED_WALLET_IFRAME_ID,\n      link: createEmbeddedWalletIframeLink({\n        clientId,\n        path: EMBEDDED_WALLET_PATH,\n        queryParams: customizationOptions\n      }).href,\n      container: document.body\n    });\n    this.clientId = clientId;\n  }\n  async onIframeLoadedInitVariables() {\n    const localStorage = new LocalStorage({\n      clientId: this.clientId\n    });\n    return {\n      authCookie: await localStorage.getAuthCookie(),\n      deviceShareStored: await localStorage.getDeviceShare(),\n      walletUserId: await localStorage.getWalletUserId(),\n      clientId: this.clientId\n    };\n  }\n}\n\n// This is the URL and ID tag of the iFrame that we communicate with\nfunction createEmbeddedWalletIframeLink(_ref2) {\n  let {\n    clientId,\n    path,\n    queryParams\n  } = _ref2;\n  const embeddedWalletUrl = new URL(`${path}`, GET_IFRAME_BASE_URL());\n  if (queryParams) {\n    for (const queryKey of Object.keys(queryParams)) {\n      embeddedWalletUrl.searchParams.set(queryKey, queryParams[queryKey]?.toString() || \"\");\n    }\n  }\n  embeddedWalletUrl.searchParams.set(\"clientId\", clientId);\n  return embeddedWalletUrl;\n}\nconst EMBEDDED_WALLET_IFRAME_ID = \"thirdweb-embedded-wallet-iframe\";\nclass AbstractLogin {\n  /**\n   * Used to manage the user's auth states. This should not be instantiated directly.\n   * Call {@link EmbeddedWalletSdk.auth} instead.\n   *\n   */\n  constructor(_ref) {\n    let {\n      querier,\n      preLogin,\n      postLogin,\n      clientId\n    } = _ref;\n    this.LoginQuerier = querier;\n    this.preLogin = preLogin;\n    this.postLogin = postLogin;\n    this.clientId = clientId;\n  }\n  async sendEmailLoginOtp(_ref2) {\n    let {\n      email\n    } = _ref2;\n    await this.preLogin();\n    const result = await this.LoginQuerier.call({\n      procedureName: \"sendThirdwebEmailLoginOtp\",\n      params: {\n        email\n      }\n    });\n    return result;\n  }\n}\nclass BaseLogin extends AbstractLogin {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"closeWindow\", _ref => {\n      let {\n        isWindowOpenedByFn,\n        win,\n        closeOpenedWindow\n      } = _ref;\n      if (isWindowOpenedByFn) {\n        win?.close();\n      } else {\n        if (win && closeOpenedWindow) {\n          closeOpenedWindow(win);\n        } else if (win) {\n          win.close();\n        }\n      }\n    });\n  }\n  async getGoogleLoginUrl() {\n    const result = await this.LoginQuerier.call({\n      procedureName: \"getHeadlessGoogleLoginLink\",\n      params: undefined\n    });\n    return result;\n  }\n  async loginWithModal() {\n    await this.preLogin();\n    const result = await this.LoginQuerier.call({\n      procedureName: \"loginWithThirdwebModal\",\n      params: undefined,\n      showIframe: true\n    });\n    return this.postLogin(result);\n  }\n  async loginWithEmailOtp(_ref2) {\n    let {\n      email\n    } = _ref2;\n    await this.preLogin();\n    const result = await this.LoginQuerier.call({\n      procedureName: \"loginWithThirdwebModal\",\n      params: {\n        email\n      },\n      showIframe: true\n    });\n    return this.postLogin(result);\n  }\n  async loginWithGoogle(args) {\n    await this.preLogin();\n    let win = args?.openedWindow;\n    let isWindowOpenedByFn = false;\n    if (!win) {\n      win = window.open(\"\", \"Login\", \"width=350, height=500\");\n      isWindowOpenedByFn = true;\n    }\n    if (!win) {\n      throw new Error(\"Something went wrong opening pop-up\");\n    }\n    await this.preLogin();\n    // fetch the url to open the login window from iframe\n    const {\n      loginLink\n    } = await this.getGoogleLoginUrl();\n    win.location.href = loginLink;\n\n    // listen to result from the login window\n    const result = await new Promise((resolve, reject) => {\n      // detect when the user closes the login window\n      const pollTimer = window.setInterval(async () => {\n        if (!win) {\n          return;\n        }\n        if (win.closed) {\n          clearInterval(pollTimer);\n          window.removeEventListener(\"message\", messageListener);\n          reject(new Error(\"User closed login window\"));\n        }\n      }, 1000);\n      const messageListener = async event => {\n        if (event.origin !== GET_IFRAME_BASE_URL()) {\n          return;\n        }\n        if (typeof event.data !== \"object\") {\n          reject(new Error(\"Invalid event data\"));\n          return;\n        }\n        switch (event.data.eventType) {\n          case \"userLoginSuccess\":\n            {\n              window.removeEventListener(\"message\", messageListener);\n              clearInterval(pollTimer);\n              this.closeWindow({\n                isWindowOpenedByFn,\n                win,\n                closeOpenedWindow: args?.closeOpenedWindow\n              });\n              if (event.data.authResult) {\n                resolve(event.data.authResult);\n              }\n              break;\n            }\n          case \"userLoginFailed\":\n            {\n              window.removeEventListener(\"message\", messageListener);\n              clearInterval(pollTimer);\n              this.closeWindow({\n                isWindowOpenedByFn,\n                win,\n                closeOpenedWindow: args?.closeOpenedWindow\n              });\n              reject(new Error(event.data.error));\n              break;\n            }\n          case \"injectDeveloperClientId\":\n            {\n              win?.postMessage({\n                eventType: \"injectDeveloperClientIdResult\",\n                developerClientId: this.clientId\n              }, GET_IFRAME_BASE_URL());\n              break;\n            }\n        }\n      };\n      window.addEventListener(\"message\", messageListener);\n    });\n    return this.postLogin({\n      storedToken: {\n        ...result.storedToken,\n        shouldStoreCookieString: true\n      },\n      walletDetails: {\n        ...result.walletDetails,\n        isIframeStorageEnabled: false\n      }\n    });\n  }\n  async verifyEmailLoginOtp(_ref3) {\n    let {\n      email,\n      otp\n    } = _ref3;\n    const result = await this.LoginQuerier.call({\n      procedureName: \"verifyThirdwebEmailLoginOtp\",\n      params: {\n        email,\n        otp\n      }\n    });\n    return this.postLogin(result);\n  }\n}\nclass Auth {\n  /**\n   * Used to manage the user's auth states. This should not be instantiated directly.\n   * Call {@link EmbeddedWalletSdk.auth} instead.\n   *\n   * @param {string} params.clientId the clientId from your thirdweb dashboard\n   */\n  constructor(_ref) {\n    let {\n      clientId,\n      querier,\n      onAuthSuccess\n    } = _ref;\n    this.clientId = clientId;\n    this.AuthQuerier = querier;\n    this.localStorage = new LocalStorage({\n      clientId\n    });\n    this.onAuthSuccess = onAuthSuccess;\n    this.BaseLogin = new BaseLogin({\n      postLogin: async result => {\n        return this.postLogin(result);\n      },\n      preLogin: async () => {\n        await this.preLogin();\n      },\n      querier: querier,\n      clientId\n    });\n  }\n  async preLogin() {\n    await this.logout();\n  }\n  async postLogin(_ref2) {\n    let {\n      storedToken,\n      walletDetails\n    } = _ref2;\n    if (storedToken.shouldStoreCookieString) {\n      await this.localStorage.saveAuthCookie(storedToken.cookieString);\n    }\n    const initializedUser = await this.onAuthSuccess({\n      storedToken,\n      walletDetails\n    });\n    return initializedUser;\n  }\n\n  /**\n   * @description\n   * Used to log the user into their thirdweb wallet on your platform via a myriad of auth providers\n   *\n   * @example\n   * const thirdwebEmbeddedWallet = new EmbeddedWalletSdk({clientId: \"YOUR_CLIENT_ID\", chain: \"Polygon\"})\n   * try {\n   *   const user = await thirdwebEmbeddedWallet.auth.loginWithModal();\n   *   // user is now logged in\n   * } catch (e) {\n   *   // User closed modal or something else went wrong during the authentication process\n   *   console.error(e)\n   * }\n   *\n   * @param {(userWalletId: string) => Promise<string | undefined>} args.getRecoveryCode Only present when using RecoveryShareManagement.USER_MANAGED recovery share management. A function that returns the recovery code for a given userWalletId.\n   *\n   * @returns {{user: InitializedUser}} An InitializedUser object. See {@link EmbeddedWalletSdk.getUser} for more\n   */\n  async loginWithModal() {\n    await this.preLogin();\n    return this.BaseLogin.loginWithModal();\n  }\n\n  /**\n   * @description\n   * Used to log the user into their thirdweb wallet using email OTP\n   *\n   * @example\n   *  // Basic Flow\n   *  const thirdwebEmbeddedWallet = new EmbeddedWalletSdk({clientId: \"\", chain: \"Polygon\"});\n   *  try {\n   *    // prompts user to enter the code they received\n   *    const user = await thirdwebEmbeddedWallet.auth.loginWithThirdwebEmailOtp({ email : \"you@example.com\" });\n   *    // user is now logged in\n   *  } catch (e) {\n   *    // User closed the OTP modal or something else went wrong during the authentication process\n   *    console.error(e)\n   *  }\n   *\n   * @param {string} props.email We will send the email an OTP that needs to be entered in order for them to be logged in.\n   * @returns {{user: InitializedUser}} An InitializedUser object. See {@link EmbeddedWalletSdk.getUser} for more\n   */\n  async loginWithEmailOtp(args) {\n    return this.BaseLogin.loginWithEmailOtp(args);\n  }\n  async loginWithGoogle(args) {\n    return this.BaseLogin.loginWithGoogle(args);\n  }\n\n  /**\n   * A headless way to initiate login with google.\n   * @returns {{user: InitializedUser}} An InitializedUser object. See {@link EmbeddedWalletSdk.getUser} for more\n    */\n\n  /**\n   * @description\n   * A headless way to send the users at {email} an OTP code.\n   * You need to then call {@link Auth.verifyEmailLoginOtp} in order to complete the login process\n   *\n   * @example\n   *  const thirdwebEmbeddedWallet = new EmbeddedWalletSdk({clientId: \"\", chain: \"Polygon\"});\n   *  // sends user an OTP code\n   * try {\n   *    await thirdwebEmbeddedWallet.auth.sendEmailLoginOtp({ email : \"you@example.com\" });\n   * } catch(e) {\n   *    // Error Sending user's email an OTP code\n   *    console.error(e);\n   * }\n   *\n   * // Then when your user is ready to verify their OTP\n   * try {\n   *    const user = await thirdwebEmbeddedWallet.auth.verifyEmailLoginOtp({ email: \"you@example.com\", otp: \"6-DIGIT_CODE_HERE\" });\n   * } catch(e) {\n   *    // Error verifying the OTP code\n   *    console.error(e)\n   * }\n   *\n   * @param {string} props.email We will send the email an OTP that needs to be entered in order for them to be logged in.\n   * @returns {{ isNewUser: boolean }} IsNewUser indicates if the user is a new user to your platform\n   */\n  async sendEmailLoginOtp(_ref3) {\n    let {\n      email\n    } = _ref3;\n    return this.BaseLogin.sendEmailLoginOtp({\n      email\n    });\n  }\n\n  /**\n   *  @description\n   * Used to verify the otp that the user receives from thirdweb\n   *\n   * See {@link Auth.sendEmailLoginOtp} for how the headless call flow looks like. Simply swap out the calls to `loginWithThirdwebEmailOtp` with `verifyThirdwebEmailLoginOtp`\n   *\n   * @param {string} props.email We will send the email an OTP that needs to be entered in order for them to be logged in.\n   * @param {string} props.otp The code that the user received in their email\n   * @returns {{user: InitializedUser}} An InitializedUser object containing the user's status, wallet, authDetails, and more\n   */\n  async verifyEmailLoginOtp(args) {\n    return this.BaseLogin.verifyEmailLoginOtp(args);\n  }\n\n  /**\n   * @description\n   * Logs any existing user out of their wallet.\n   * @returns {{success: boolean}} true if a user is successfully logged out. false if there's no user currently logged in.\n   */\n  async logout() {\n    const {\n      success\n    } = await this.AuthQuerier.call({\n      procedureName: \"logout\",\n      params: undefined\n    });\n    const isRemoveAuthCookie = await this.localStorage.removeAuthCookie();\n    const isRemoveUserId = await this.localStorage.removeWalletUserId();\n    return {\n      success: success || isRemoveAuthCookie || isRemoveUserId\n    };\n  }\n}\nclass EthersSigner extends Signer {\n  constructor(_ref) {\n    let {\n      provider,\n      clientId,\n      querier\n    } = _ref;\n    super();\n    _defineProperty(this, \"DEFAULT_ETHEREUM_CHAIN_ID\", 5);\n    this.clientId = clientId;\n    this.querier = querier;\n    // we try to extract a url if possible\n    this.endpoint = provider.connection?.url;\n    defineReadOnly(this, \"provider\", provider);\n  }\n  async getAddress() {\n    const {\n      address\n    } = await this.querier.call({\n      procedureName: \"getAddress\",\n      params: undefined\n    });\n    return address;\n  }\n  async signMessage(message) {\n    const {\n      signedMessage\n    } = await this.querier.call({\n      procedureName: \"signMessage\",\n      params: {\n        message,\n        chainId: (await this.provider?.getNetwork())?.chainId ?? this.DEFAULT_ETHEREUM_CHAIN_ID,\n        rpcEndpoint: this.endpoint\n      }\n    });\n    return signedMessage;\n  }\n  async signTransaction(transaction) {\n    const {\n      signedTransaction\n    } = await this.querier.call({\n      procedureName: \"signTransaction\",\n      params: {\n        transaction,\n        chainId: (await this.provider?.getNetwork())?.chainId ?? this.DEFAULT_ETHEREUM_CHAIN_ID,\n        rpcEndpoint: this.endpoint\n      }\n    });\n    return signedTransaction;\n  }\n  async _signTypedData(domain, types, message) {\n    const {\n      signedTypedData\n    } = await this.querier.call({\n      procedureName: \"signTypedDataV4\",\n      params: {\n        domain,\n        types,\n        message,\n        chainId: (await this.provider?.getNetwork())?.chainId ?? this.DEFAULT_ETHEREUM_CHAIN_ID,\n        rpcEndpoint: this.endpoint\n      }\n    });\n    return signedTypedData;\n  }\n  connect(provider) {\n    return new EthersSigner({\n      clientId: this.clientId,\n      provider,\n      querier: this.querier\n    });\n  }\n}\nclass EmbeddedWallet {\n  /**\n   * Not meant to be initialized directly. Call {@link .initializeUser} to get an instance\n   * @param param0\n   */\n  constructor(_ref) {\n    let {\n      clientId,\n      chain,\n      querier\n    } = _ref;\n    this.clientId = clientId;\n    this.chain = chain;\n    this.walletManagerQuerier = querier;\n    this.localStorage = new LocalStorage({\n      clientId\n    });\n  }\n\n  /**\n   * @internal\n   * Used to set-up the user device in the case that they are using incognito\n   * @param {string} param.deviceShareStored the value that is saved for the user's device share.\n   * We save this into the localStorage on the site itself if we could not save it within the iframe's localStorage.\n   * This happens in incognito mostly\n   * @param {string} param.walletAddress User's wallet address\n   * @param {boolean} param.isIframeStorageEnabled Tells us if we were able to store values in the localStorage in our iframe.\n   * We need to store it under the dev's domain localStorage if we weren't able to store things in the iframe\n   * @returns {{ walletAddress : string }} The user's wallet details\n   */\n  async postWalletSetUp(_ref2) {\n    let {\n      deviceShareStored,\n      walletAddress,\n      isIframeStorageEnabled,\n      walletUserId\n    } = _ref2;\n    if (!isIframeStorageEnabled) {\n      await this.localStorage.saveDeviceShare(deviceShareStored, walletUserId);\n    }\n    return {\n      walletAddress\n    };\n  }\n\n  /**\n   * @internal\n   * Gets the various status states of the user\n   * @example\n   *  const userStatus = await Paper.getUserWalletStatus();\n   *  switch (userStatus.status) {\n   *  case UserWalletStatus.LOGGED_OUT: {\n   *    // User is logged out, call one of the auth methods on Paper.auth to authenticate the user\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED: {\n   *    // User is logged in, but does not have a wallet associated with it\n   *    // you also have access to the user's details\n   *    userStatus.user.authDetails;\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_NEW_DEVICE: {\n   *    // User is logged in and created a wallet already, but is missing the device shard\n   *    // You have access to:\n   *    userStatus.user.authDetails;\n   *    userStatus.user.walletAddress;\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED: {\n   *    // user is logged in and wallet is all set up.\n   *    // You have access to:\n   *    userStatus.user.authDetails;\n   *    userStatus.user.walletAddress;\n   *    userStatus.user.wallet;\n   *    break;\n   *  }\n   *}\n   * @returns {GetUserWalletStatusFnReturnType} an object to containing various information on the user statuses\n   */\n  async getUserWalletStatus() {\n    const userStatus = await this.walletManagerQuerier.call({\n      procedureName: \"getUserStatus\",\n      params: undefined\n    });\n    if (userStatus.status === UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED) {\n      return {\n        status: UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED,\n        user: {\n          ...userStatus.user,\n          wallet: this\n        }\n      };\n    }\n    return userStatus;\n  }\n\n  /**\n   * @description\n   * Switches the chain that the user wallet is currently on.\n   * @example\n   * // user wallet will be set to Polygon\n   * const Paper = new ThirdwebEmbeddedWalletSdk({clientId: \"\", chain: \"Polygon\"});\n   * const user = await Paper.initializeUser();\n   * // Switch the user wallet to Mumbai\n   * await user.wallet.setChain({ chain: \"Mumbai\" });\n   * @param {Chain} params.chain The chain that we are changing the user wallet too\n   */\n  async setChain(_ref3) {\n    let {\n      chain\n    } = _ref3;\n    this.chain = chain;\n  }\n\n  /**\n   * Returns an Ethers.Js compatible signer that you can use in conjunction with the rest of dApp\n   * @example\n   * const Paper = new ThirdwebEmbeddedWalletSdk({clientId: \"\", chain: \"Polygon\"});\n   * const user = await Paper.getUser();\n   * if (user.status === UserStatus.LOGGED_IN_WALLET_INITIALIZED) {\n   *    // returns a signer on the Polygon mainnet\n   *    const signer = await user.getEthersJsSigner();\n   *    // returns a signer on the specified RPC endpoints\n   *    const signer = await user.getEthersJsSigner({rpcEndpoint: \"https://eth-rpc.gateway.pokt.network\"});\n   * }\n   * @param {Networkish} network.rpcEndpoint the rpc url where calls will be routed through\n   * @throws If attempting to call the function without the user wallet initialize on their current device. This should never happen if call {@link ThirdwebEmbeddedWalletSdk.initializeUser} before accessing this function\n   * @returns A signer that is compatible with Ether.js. Defaults to the public rpc on the chain specified when initializing the {@link ThirdwebEmbeddedWalletSdk} instance\n   */\n  async getEthersJsSigner(network) {\n    const signer = new EthersSigner({\n      clientId: this.clientId,\n      provider: getDefaultProvider(network?.rpcEndpoint ?? ChainToPublicRpc[this.chain]),\n      querier: this.walletManagerQuerier\n    });\n    return signer;\n  }\n}\nclass EmbeddedWalletSdk {\n  /**\n   * Used to manage the Auth state of the user.\n   */\n\n  isClientIdLegacyPaper(clientId) {\n    if (clientId.indexOf(\"-\") > 0 && clientId.length === 36) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @example\n   * const thirdwebEmbeddedWallet = new EmbeddedWalletSdk({ clientId: \"\", chain: \"Goerli\" });\n   * @param {string} initParams.clientId the clientId found on the {@link https://thirdweb.com/dashboard/settings dashboard settings}\n   * @param {Chain} initParams.chain sets the default chain that the EmbeddedWallet will live on.\n   * @param {CustomizationOptionsType} initParams.styles sets the default style override for any modal that pops up asking for user's details when creating wallet or logging in.\n   */\n  constructor(_ref) {\n    let {\n      clientId,\n      chain,\n      styles\n    } = _ref;\n    if (this.isClientIdLegacyPaper(clientId)) {\n      throw new Error(\"You are using a legacy clientId. Please use the clientId found on the thirdweb dashboard settings page\");\n    }\n    this.clientId = clientId;\n    this.querier = new EmbeddedWalletIframeCommunicator({\n      clientId,\n      customizationOptions: styles\n    });\n    this.wallet = new EmbeddedWallet({\n      clientId,\n      chain,\n      querier: this.querier\n    });\n    this.auth = new Auth({\n      clientId,\n      querier: this.querier,\n      onAuthSuccess: async authResult => {\n        await this.wallet.postWalletSetUp({\n          ...authResult.walletDetails,\n          walletUserId: authResult.storedToken.authDetails.userWalletId\n        });\n        await this.querier.call({\n          procedureName: \"initIframe\",\n          params: {\n            deviceShareStored: authResult.walletDetails.deviceShareStored,\n            clientId: this.clientId,\n            walletUserId: authResult.storedToken.authDetails.userWalletId,\n            authCookie: authResult.storedToken.cookieString\n          }\n        });\n        return {\n          user: {\n            status: UserStatus.LOGGED_IN_WALLET_INITIALIZED,\n            authDetails: authResult.storedToken.authDetails,\n            wallet: this.wallet,\n            walletAddress: authResult.walletDetails.walletAddress\n          }\n        };\n      }\n    });\n  }\n\n  /**\n   * Gets the usr if they are logged in\n   * @example\n   *  const user = await thirdwebEmbeddedWallet.getUser();\n   *  switch (user.status) {\n   *     case UserStatus.LOGGED_OUT: {\n   *       // User is logged out, call one of the auth methods on thirdwebEmbeddedWallet.auth to authenticate the user\n   *       break;\n   *     }\n   *     case UserStatus.LOGGED_IN_WALLET_INITIALIZED: {\n   *       // user is logged in and wallet is all set up.\n   *       // You have access to:\n   *       user.status;\n   *       user.authDetails;\n   *       user.walletAddress;\n   *       user.wallet;\n   *       break;\n   *     }\n   *}\n   * @returns {GetUser} an object to containing various information on the user statuses\n   */\n  async getUser() {\n    const userStatus = await this.wallet.getUserWalletStatus();\n    switch (userStatus.status) {\n      // user gets {UserWalletStatus.LOGGED_IN_NEW_DEVICE} when they log in but never complete the recovery flow and exits (close modal, refresh etc)\n      case UserWalletStatus.LOGGED_IN_NEW_DEVICE:\n      // User gets {UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED} when they log in but manage to exit the client in the small window between auth completion and sending them their wallet recovery details\n      case UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED:\n        // in both case, we simply log them out to reset their state\n        await this.auth.logout();\n        return this.getUser();\n      case UserWalletStatus.LOGGED_OUT:\n        return {\n          status: UserStatus.LOGGED_OUT\n        };\n      case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED:\n        return {\n          status: UserStatus.LOGGED_IN_WALLET_INITIALIZED,\n          ...userStatus.user\n        };\n    }\n  }\n}\nexport { AUTH_TOKEN_LOCAL_STORAGE_NAME as A, DEVICE_SHARE_LOCAL_STORAGE_NAME as D, EmbeddedWalletSdk as E, UserStatus as U, WALLET_USER_DETAILS_LOCAL_STORAGE_NAME as W, DEVICE_SHARE_LOCAL_STORAGE_NAME_DEPRECATED as a, WALLET_USER_ID_LOCAL_STORAGE_NAME as b };","map":{"version":3,"names":["getPaperOriginUrl","ChainToPublicRpc","_","_defineProperty","Signer","getDefaultProvider","defineReadOnly","EMBEDDED_WALLET_PATH","GET_IFRAME_BASE_URL","replace","WALLET_USER_DETAILS_LOCAL_STORAGE_NAME","clientId","WALLET_USER_ID_LOCAL_STORAGE_NAME","AUTH_TOKEN_LOCAL_STORAGE_PREFIX","AUTH_TOKEN_LOCAL_STORAGE_NAME","DEVICE_SHARE_LOCAL_STORAGE_PREFIX","DEVICE_SHARE_LOCAL_STORAGE_NAME","userId","DEVICE_SHARE_LOCAL_STORAGE_NAME_DEPRECATED","UserStatus","UserWalletStatus","data","Map","LocalStorage","constructor","_ref","isSupported","window","localStorage","getItem","key","get","setItem","value","set","removeItem","item","saveAuthCookie","cookie","getAuthCookie","removeAuthCookie","saveDeviceShare","share","saveWalletUserId","getDeviceShare","getWalletUserId","removeDeviceShare","removeWalletUserId","sleep","seconds","Promise","resolve","setTimeout","iframeBaseStyle","height","width","border","backgroundColor","colorScheme","position","top","right","zIndex","display","isIframeLoaded","IframeCommunicator","link","iframeId","container","document","body","iframeStyles","onIframeInitialize","iframeBaseUrl","iframe","getElementById","hrefLink","URL","sdkVersion","searchParams","src","href","createElement","mergedIframeStyles","Object","assign","style","setAttribute","appendChild","onIframeLoaded","event","eventType","removeEventListener","console","warn","onIframeLoadHandler","addEventListener","onIframeLoadedInitVariables","promise","res","rej","channel","MessageChannel","port1","onmessage","close","success","Error","error","INIT_IFRAME_EVENT","contentWindow","postMessage","port2","call","_ref2","procedureName","params","showIframe","POLLING_INTERVAL_SECONDS","destroy","delete","EmbeddedWalletIframeCommunicator","customizationOptions","EMBEDDED_WALLET_IFRAME_ID","createEmbeddedWalletIframeLink","path","queryParams","authCookie","deviceShareStored","walletUserId","embeddedWalletUrl","queryKey","keys","toString","AbstractLogin","querier","preLogin","postLogin","LoginQuerier","sendEmailLoginOtp","email","result","BaseLogin","arguments","isWindowOpenedByFn","win","closeOpenedWindow","getGoogleLoginUrl","undefined","loginWithModal","loginWithEmailOtp","loginWithGoogle","args","openedWindow","open","loginLink","location","reject","pollTimer","setInterval","closed","clearInterval","messageListener","origin","closeWindow","authResult","developerClientId","storedToken","shouldStoreCookieString","walletDetails","isIframeStorageEnabled","verifyEmailLoginOtp","_ref3","otp","Auth","onAuthSuccess","AuthQuerier","logout","cookieString","initializedUser","isRemoveAuthCookie","isRemoveUserId","EthersSigner","provider","endpoint","connection","url","getAddress","address","signMessage","message","signedMessage","chainId","getNetwork","DEFAULT_ETHEREUM_CHAIN_ID","rpcEndpoint","signTransaction","transaction","signedTransaction","_signTypedData","domain","types","signedTypedData","connect","EmbeddedWallet","chain","walletManagerQuerier","postWalletSetUp","walletAddress","getUserWalletStatus","userStatus","status","LOGGED_IN_WALLET_INITIALIZED","user","wallet","setChain","getEthersJsSigner","network","signer","EmbeddedWalletSdk","isClientIdLegacyPaper","indexOf","length","styles","auth","authDetails","userWalletId","getUser","LOGGED_IN_NEW_DEVICE","LOGGED_IN_WALLET_UNINITIALIZED","LOGGED_OUT","A","D","E","U","W","a","b"],"sources":["C:/Users/SUMAN K/meta_transfer/node_modules/@thirdweb-dev/wallets/dist/embedded-wallet-89e555d2.browser.esm.js"],"sourcesContent":["import { getPaperOriginUrl, ChainToPublicRpc } from '@paperxyz/sdk-common-utilities';\nimport { _ as _defineProperty } from './defineProperty-c8ecdc07.browser.esm.js';\nimport { Signer, getDefaultProvider } from 'ethers';\nimport { defineReadOnly } from 'ethers/lib/utils';\n\nconst EMBEDDED_WALLET_PATH = \"/sdk/2022-08-12/embedded-wallet\";\nconst GET_IFRAME_BASE_URL = () => `${getPaperOriginUrl().replace(\"withpaper.com\", \"ews.thirdweb.com\")}`;\nconst WALLET_USER_DETAILS_LOCAL_STORAGE_NAME = clientId => `thirdwebEwsWalletUserDetails-${clientId}`;\nconst WALLET_USER_ID_LOCAL_STORAGE_NAME = clientId => `thirdwebEwsWalletUserId-${clientId}`;\nconst AUTH_TOKEN_LOCAL_STORAGE_PREFIX = \"walletToken\";\nconst AUTH_TOKEN_LOCAL_STORAGE_NAME = clientId => {\n  return `${AUTH_TOKEN_LOCAL_STORAGE_PREFIX}-${clientId}`;\n};\nconst DEVICE_SHARE_LOCAL_STORAGE_PREFIX = \"a\";\nconst DEVICE_SHARE_LOCAL_STORAGE_NAME = (clientId, userId) => `${DEVICE_SHARE_LOCAL_STORAGE_PREFIX}-${clientId}-${userId}`;\nconst DEVICE_SHARE_LOCAL_STORAGE_NAME_DEPRECATED = clientId => `${DEVICE_SHARE_LOCAL_STORAGE_PREFIX}-${clientId}`;\n\n// Class constructor types\n// types for class constructors still a little messy right now.\n// Open to PRs from whoever sees this and knows of a cleaner way to handle things\n// Auth Types\n// Embedded Wallet Types\nlet UserStatus = /*#__PURE__*/function (UserStatus) {\n  UserStatus[\"LOGGED_OUT\"] = \"Logged Out\";\n  UserStatus[\"LOGGED_IN_WALLET_INITIALIZED\"] = \"Logged In, Wallet Initialized\";\n  return UserStatus;\n}({});\nlet UserWalletStatus = /*#__PURE__*/function (UserWalletStatus) {\n  UserWalletStatus[\"LOGGED_OUT\"] = \"Logged Out\";\n  UserWalletStatus[\"LOGGED_IN_WALLET_UNINITIALIZED\"] = \"Logged In, Wallet Uninitialized\";\n  UserWalletStatus[\"LOGGED_IN_NEW_DEVICE\"] = \"Logged In, New Device\";\n  UserWalletStatus[\"LOGGED_IN_WALLET_INITIALIZED\"] = \"Logged In, Wallet Initialized\";\n  return UserWalletStatus;\n}({});\n\n// ! Types seem repetitive, but the name should identify which goes where\n// this is the return type from the EmbeddedWallet Class getUserWalletStatus method iframe call\n// this is the return type from the EmbeddedWallet Class getUserWalletStatus method\n// This is returned from the getUser method in PaperEmbeddedWalletSdk\n\nconst data = new Map();\nclass LocalStorage {\n  constructor(_ref) {\n    let {\n      clientId\n    } = _ref;\n    this.isSupported = !!window.localStorage;\n    this.clientId = clientId;\n  }\n  async getItem(key) {\n    if (this.isSupported) {\n      return window.localStorage.getItem(key);\n    } else {\n      return data.get(key) ?? null;\n    }\n  }\n  async setItem(key, value) {\n    if (this.isSupported) {\n      return window.localStorage.setItem(key, value);\n    } else {\n      data.set(key, value);\n    }\n  }\n  async removeItem(key) {\n    const item = await this.getItem(key);\n    if (this.isSupported && item) {\n      window.localStorage.removeItem(key);\n      return true;\n    }\n    return false;\n  }\n  async saveAuthCookie(cookie) {\n    await this.setItem(AUTH_TOKEN_LOCAL_STORAGE_NAME(this.clientId), cookie);\n  }\n  async getAuthCookie() {\n    return this.getItem(AUTH_TOKEN_LOCAL_STORAGE_NAME(this.clientId));\n  }\n  async removeAuthCookie() {\n    return this.removeItem(AUTH_TOKEN_LOCAL_STORAGE_NAME(this.clientId));\n  }\n  async saveDeviceShare(share, userId) {\n    await this.saveWalletUserId(userId);\n    await this.setItem(DEVICE_SHARE_LOCAL_STORAGE_NAME(this.clientId, userId), share);\n  }\n  async getDeviceShare() {\n    const userId = await this.getWalletUserId();\n    if (userId) {\n      return this.getItem(DEVICE_SHARE_LOCAL_STORAGE_NAME(this.clientId, userId));\n    }\n    return null;\n  }\n  async removeDeviceShare() {\n    const userId = await this.getWalletUserId();\n    if (userId) {\n      return this.removeItem(DEVICE_SHARE_LOCAL_STORAGE_NAME(this.clientId, userId));\n    }\n    return false;\n  }\n  async getWalletUserId() {\n    return this.getItem(WALLET_USER_ID_LOCAL_STORAGE_NAME(this.clientId));\n  }\n  async saveWalletUserId(userId) {\n    await this.setItem(WALLET_USER_ID_LOCAL_STORAGE_NAME(this.clientId), userId);\n  }\n  async removeWalletUserId() {\n    return this.removeItem(WALLET_USER_ID_LOCAL_STORAGE_NAME(this.clientId));\n  }\n}\n\nfunction sleep(seconds) {\n  return new Promise(resolve => {\n    setTimeout(resolve, seconds * 1000);\n  });\n}\nconst iframeBaseStyle = {\n  height: \"100%\",\n  width: \"100%\",\n  border: \"none\",\n  backgroundColor: \"transparent\",\n  colorScheme: \"light\",\n  position: \"fixed\",\n  top: \"0px\",\n  right: \"0px\",\n  zIndex: \"2147483646\",\n  display: \"none\"\n};\n\n// Global var to help track iframe state\nconst isIframeLoaded = new Map();\nclass IframeCommunicator {\n  constructor(_ref) {\n    let {\n      link,\n      iframeId,\n      container = document.body,\n      iframeStyles,\n      onIframeInitialize\n    } = _ref;\n    _defineProperty(this, \"POLLING_INTERVAL_SECONDS\", 1.4);\n    this.iframeBaseUrl = GET_IFRAME_BASE_URL();\n\n    // Creating the IFrame element for communication\n    let iframe = document.getElementById(iframeId);\n    const hrefLink = new URL(link);\n    const sdkVersion = \"2.0.10\";\n    hrefLink.searchParams.set(\"sdkVersion\", sdkVersion);\n    if (!iframe || iframe.src !== hrefLink.href) {\n      // ! Do not update the hrefLink here or it'll cause multiple re-renders\n      if (!iframe) {\n        iframe = document.createElement(\"iframe\");\n        const mergedIframeStyles = {\n          ...iframeBaseStyle,\n          ...iframeStyles\n        };\n        Object.assign(iframe.style, mergedIframeStyles);\n        iframe.setAttribute(\"id\", iframeId);\n        iframe.setAttribute(\"fetchpriority\", \"high\");\n        container.appendChild(iframe);\n      }\n      iframe.src = hrefLink.href;\n      iframe.setAttribute(\"data-version\", sdkVersion);\n      const onIframeLoaded = event => {\n        if (event.data.eventType === \"ewsIframeLoaded\") {\n          window.removeEventListener(\"message\", onIframeLoaded);\n          if (!iframe) {\n            console.warn(\"thirdweb Iframe not found\");\n            return;\n          }\n          this.onIframeLoadHandler(iframe, onIframeInitialize)();\n        }\n      };\n      window.addEventListener(\"message\", onIframeLoaded);\n    }\n    this.iframe = iframe;\n  }\n  async onIframeLoadedInitVariables() {\n    return {};\n  }\n  onIframeLoadHandler(iframe, onIframeInitialize) {\n    return async () => {\n      const promise = new Promise(async (res, rej) => {\n        const channel = new MessageChannel();\n        channel.port1.onmessage = event => {\n          const {\n            data\n          } = event;\n          channel.port1.close();\n          if (!data.success) {\n            return rej(new Error(data.error));\n          }\n          isIframeLoaded.set(iframe.src, true);\n          if (onIframeInitialize) {\n            onIframeInitialize();\n          }\n          return res(true);\n        };\n        const INIT_IFRAME_EVENT = \"initIframe\";\n        iframe?.contentWindow?.postMessage(\n        // ? We initialise the iframe with a bunch\n        // of useful information so that we don't have to pass it\n        // through in each of the future call. This would be where we do it.\n        {\n          eventType: INIT_IFRAME_EVENT,\n          data: await this.onIframeLoadedInitVariables()\n        }, this.iframeBaseUrl, [channel.port2]);\n      });\n      await promise;\n    };\n  }\n  async call(_ref2) {\n    let {\n      procedureName,\n      params,\n      showIframe = false\n    } = _ref2;\n    while (!isIframeLoaded.get(this.iframe.src)) {\n      await sleep(this.POLLING_INTERVAL_SECONDS);\n    }\n    if (showIframe) {\n      this.iframe.style.display = \"block\";\n      // magic number to let the display render before performing the animation of the modal in\n      await sleep(0.005);\n    }\n    const promise = new Promise((res, rej) => {\n      const channel = new MessageChannel();\n      channel.port1.onmessage = async event => {\n        const {\n          data\n        } = event;\n        channel.port1.close();\n        if (showIframe) {\n          // magic number to let modal fade out before hiding it\n          await sleep(0.1);\n          this.iframe.style.display = \"none\";\n        }\n        if (!data.success) {\n          rej(new Error(data.error));\n        } else {\n          res(data.data);\n        }\n      };\n      this.iframe.contentWindow?.postMessage({\n        eventType: procedureName,\n        data: params\n      }, this.iframeBaseUrl, [channel.port2]);\n    });\n    return promise;\n  }\n\n  /**\n   * This has to be called by any iframe that will be removed from the DOM.\n   * Use to make sure that we reset the global loaded state of the particular iframe.src\n   */\n  destroy() {\n    isIframeLoaded.delete(this.iframe.src);\n  }\n}\n\nclass EmbeddedWalletIframeCommunicator extends IframeCommunicator {\n  constructor(_ref) {\n    let {\n      clientId,\n      customizationOptions\n    } = _ref;\n    super({\n      iframeId: EMBEDDED_WALLET_IFRAME_ID,\n      link: createEmbeddedWalletIframeLink({\n        clientId,\n        path: EMBEDDED_WALLET_PATH,\n        queryParams: customizationOptions\n      }).href,\n      container: document.body\n    });\n    this.clientId = clientId;\n  }\n  async onIframeLoadedInitVariables() {\n    const localStorage = new LocalStorage({\n      clientId: this.clientId\n    });\n    return {\n      authCookie: await localStorage.getAuthCookie(),\n      deviceShareStored: await localStorage.getDeviceShare(),\n      walletUserId: await localStorage.getWalletUserId(),\n      clientId: this.clientId\n    };\n  }\n}\n\n// This is the URL and ID tag of the iFrame that we communicate with\nfunction createEmbeddedWalletIframeLink(_ref2) {\n  let {\n    clientId,\n    path,\n    queryParams\n  } = _ref2;\n  const embeddedWalletUrl = new URL(`${path}`, GET_IFRAME_BASE_URL());\n  if (queryParams) {\n    for (const queryKey of Object.keys(queryParams)) {\n      embeddedWalletUrl.searchParams.set(queryKey, queryParams[queryKey]?.toString() || \"\");\n    }\n  }\n  embeddedWalletUrl.searchParams.set(\"clientId\", clientId);\n  return embeddedWalletUrl;\n}\nconst EMBEDDED_WALLET_IFRAME_ID = \"thirdweb-embedded-wallet-iframe\";\n\nclass AbstractLogin {\n  /**\n   * Used to manage the user's auth states. This should not be instantiated directly.\n   * Call {@link EmbeddedWalletSdk.auth} instead.\n   *\n   */\n  constructor(_ref) {\n    let {\n      querier,\n      preLogin,\n      postLogin,\n      clientId\n    } = _ref;\n    this.LoginQuerier = querier;\n    this.preLogin = preLogin;\n    this.postLogin = postLogin;\n    this.clientId = clientId;\n  }\n  async sendEmailLoginOtp(_ref2) {\n    let {\n      email\n    } = _ref2;\n    await this.preLogin();\n    const result = await this.LoginQuerier.call({\n      procedureName: \"sendThirdwebEmailLoginOtp\",\n      params: {\n        email\n      }\n    });\n    return result;\n  }\n}\n\nclass BaseLogin extends AbstractLogin {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"closeWindow\", _ref => {\n      let {\n        isWindowOpenedByFn,\n        win,\n        closeOpenedWindow\n      } = _ref;\n      if (isWindowOpenedByFn) {\n        win?.close();\n      } else {\n        if (win && closeOpenedWindow) {\n          closeOpenedWindow(win);\n        } else if (win) {\n          win.close();\n        }\n      }\n    });\n  }\n  async getGoogleLoginUrl() {\n    const result = await this.LoginQuerier.call({\n      procedureName: \"getHeadlessGoogleLoginLink\",\n      params: undefined\n    });\n    return result;\n  }\n  async loginWithModal() {\n    await this.preLogin();\n    const result = await this.LoginQuerier.call({\n      procedureName: \"loginWithThirdwebModal\",\n      params: undefined,\n      showIframe: true\n    });\n    return this.postLogin(result);\n  }\n  async loginWithEmailOtp(_ref2) {\n    let {\n      email\n    } = _ref2;\n    await this.preLogin();\n    const result = await this.LoginQuerier.call({\n      procedureName: \"loginWithThirdwebModal\",\n      params: {\n        email\n      },\n      showIframe: true\n    });\n    return this.postLogin(result);\n  }\n  async loginWithGoogle(args) {\n    await this.preLogin();\n    let win = args?.openedWindow;\n    let isWindowOpenedByFn = false;\n    if (!win) {\n      win = window.open(\"\", \"Login\", \"width=350, height=500\");\n      isWindowOpenedByFn = true;\n    }\n    if (!win) {\n      throw new Error(\"Something went wrong opening pop-up\");\n    }\n    await this.preLogin();\n    // fetch the url to open the login window from iframe\n    const {\n      loginLink\n    } = await this.getGoogleLoginUrl();\n    win.location.href = loginLink;\n\n    // listen to result from the login window\n    const result = await new Promise((resolve, reject) => {\n      // detect when the user closes the login window\n      const pollTimer = window.setInterval(async () => {\n        if (!win) {\n          return;\n        }\n        if (win.closed) {\n          clearInterval(pollTimer);\n          window.removeEventListener(\"message\", messageListener);\n          reject(new Error(\"User closed login window\"));\n        }\n      }, 1000);\n      const messageListener = async event => {\n        if (event.origin !== GET_IFRAME_BASE_URL()) {\n          return;\n        }\n        if (typeof event.data !== \"object\") {\n          reject(new Error(\"Invalid event data\"));\n          return;\n        }\n        switch (event.data.eventType) {\n          case \"userLoginSuccess\":\n            {\n              window.removeEventListener(\"message\", messageListener);\n              clearInterval(pollTimer);\n              this.closeWindow({\n                isWindowOpenedByFn,\n                win,\n                closeOpenedWindow: args?.closeOpenedWindow\n              });\n              if (event.data.authResult) {\n                resolve(event.data.authResult);\n              }\n              break;\n            }\n          case \"userLoginFailed\":\n            {\n              window.removeEventListener(\"message\", messageListener);\n              clearInterval(pollTimer);\n              this.closeWindow({\n                isWindowOpenedByFn,\n                win,\n                closeOpenedWindow: args?.closeOpenedWindow\n              });\n              reject(new Error(event.data.error));\n              break;\n            }\n          case \"injectDeveloperClientId\":\n            {\n              win?.postMessage({\n                eventType: \"injectDeveloperClientIdResult\",\n                developerClientId: this.clientId\n              }, GET_IFRAME_BASE_URL());\n              break;\n            }\n        }\n      };\n      window.addEventListener(\"message\", messageListener);\n    });\n    return this.postLogin({\n      storedToken: {\n        ...result.storedToken,\n        shouldStoreCookieString: true\n      },\n      walletDetails: {\n        ...result.walletDetails,\n        isIframeStorageEnabled: false\n      }\n    });\n  }\n  async verifyEmailLoginOtp(_ref3) {\n    let {\n      email,\n      otp\n    } = _ref3;\n    const result = await this.LoginQuerier.call({\n      procedureName: \"verifyThirdwebEmailLoginOtp\",\n      params: {\n        email,\n        otp\n      }\n    });\n    return this.postLogin(result);\n  }\n}\n\nclass Auth {\n  /**\n   * Used to manage the user's auth states. This should not be instantiated directly.\n   * Call {@link EmbeddedWalletSdk.auth} instead.\n   *\n   * @param {string} params.clientId the clientId from your thirdweb dashboard\n   */\n  constructor(_ref) {\n    let {\n      clientId,\n      querier,\n      onAuthSuccess\n    } = _ref;\n    this.clientId = clientId;\n    this.AuthQuerier = querier;\n    this.localStorage = new LocalStorage({\n      clientId\n    });\n    this.onAuthSuccess = onAuthSuccess;\n    this.BaseLogin = new BaseLogin({\n      postLogin: async result => {\n        return this.postLogin(result);\n      },\n      preLogin: async () => {\n        await this.preLogin();\n      },\n      querier: querier,\n      clientId\n    });\n  }\n  async preLogin() {\n    await this.logout();\n  }\n  async postLogin(_ref2) {\n    let {\n      storedToken,\n      walletDetails\n    } = _ref2;\n    if (storedToken.shouldStoreCookieString) {\n      await this.localStorage.saveAuthCookie(storedToken.cookieString);\n    }\n    const initializedUser = await this.onAuthSuccess({\n      storedToken,\n      walletDetails\n    });\n    return initializedUser;\n  }\n\n  /**\n   * @description\n   * Used to log the user into their thirdweb wallet on your platform via a myriad of auth providers\n   *\n   * @example\n   * const thirdwebEmbeddedWallet = new EmbeddedWalletSdk({clientId: \"YOUR_CLIENT_ID\", chain: \"Polygon\"})\n   * try {\n   *   const user = await thirdwebEmbeddedWallet.auth.loginWithModal();\n   *   // user is now logged in\n   * } catch (e) {\n   *   // User closed modal or something else went wrong during the authentication process\n   *   console.error(e)\n   * }\n   *\n   * @param {(userWalletId: string) => Promise<string | undefined>} args.getRecoveryCode Only present when using RecoveryShareManagement.USER_MANAGED recovery share management. A function that returns the recovery code for a given userWalletId.\n   *\n   * @returns {{user: InitializedUser}} An InitializedUser object. See {@link EmbeddedWalletSdk.getUser} for more\n   */\n  async loginWithModal() {\n    await this.preLogin();\n    return this.BaseLogin.loginWithModal();\n  }\n\n  /**\n   * @description\n   * Used to log the user into their thirdweb wallet using email OTP\n   *\n   * @example\n   *  // Basic Flow\n   *  const thirdwebEmbeddedWallet = new EmbeddedWalletSdk({clientId: \"\", chain: \"Polygon\"});\n   *  try {\n   *    // prompts user to enter the code they received\n   *    const user = await thirdwebEmbeddedWallet.auth.loginWithThirdwebEmailOtp({ email : \"you@example.com\" });\n   *    // user is now logged in\n   *  } catch (e) {\n   *    // User closed the OTP modal or something else went wrong during the authentication process\n   *    console.error(e)\n   *  }\n   *\n   * @param {string} props.email We will send the email an OTP that needs to be entered in order for them to be logged in.\n   * @returns {{user: InitializedUser}} An InitializedUser object. See {@link EmbeddedWalletSdk.getUser} for more\n   */\n  async loginWithEmailOtp(args) {\n    return this.BaseLogin.loginWithEmailOtp(args);\n  }\n  async loginWithGoogle(args) {\n    return this.BaseLogin.loginWithGoogle(args);\n  }\n\n  /**\n   * A headless way to initiate login with google.\n   * @returns {{user: InitializedUser}} An InitializedUser object. See {@link EmbeddedWalletSdk.getUser} for more\n    */\n\n  /**\n   * @description\n   * A headless way to send the users at {email} an OTP code.\n   * You need to then call {@link Auth.verifyEmailLoginOtp} in order to complete the login process\n   *\n   * @example\n   *  const thirdwebEmbeddedWallet = new EmbeddedWalletSdk({clientId: \"\", chain: \"Polygon\"});\n   *  // sends user an OTP code\n   * try {\n   *    await thirdwebEmbeddedWallet.auth.sendEmailLoginOtp({ email : \"you@example.com\" });\n   * } catch(e) {\n   *    // Error Sending user's email an OTP code\n   *    console.error(e);\n   * }\n   *\n   * // Then when your user is ready to verify their OTP\n   * try {\n   *    const user = await thirdwebEmbeddedWallet.auth.verifyEmailLoginOtp({ email: \"you@example.com\", otp: \"6-DIGIT_CODE_HERE\" });\n   * } catch(e) {\n   *    // Error verifying the OTP code\n   *    console.error(e)\n   * }\n   *\n   * @param {string} props.email We will send the email an OTP that needs to be entered in order for them to be logged in.\n   * @returns {{ isNewUser: boolean }} IsNewUser indicates if the user is a new user to your platform\n   */\n  async sendEmailLoginOtp(_ref3) {\n    let {\n      email\n    } = _ref3;\n    return this.BaseLogin.sendEmailLoginOtp({\n      email\n    });\n  }\n\n  /**\n   *  @description\n   * Used to verify the otp that the user receives from thirdweb\n   *\n   * See {@link Auth.sendEmailLoginOtp} for how the headless call flow looks like. Simply swap out the calls to `loginWithThirdwebEmailOtp` with `verifyThirdwebEmailLoginOtp`\n   *\n   * @param {string} props.email We will send the email an OTP that needs to be entered in order for them to be logged in.\n   * @param {string} props.otp The code that the user received in their email\n   * @returns {{user: InitializedUser}} An InitializedUser object containing the user's status, wallet, authDetails, and more\n   */\n  async verifyEmailLoginOtp(args) {\n    return this.BaseLogin.verifyEmailLoginOtp(args);\n  }\n\n  /**\n   * @description\n   * Logs any existing user out of their wallet.\n   * @returns {{success: boolean}} true if a user is successfully logged out. false if there's no user currently logged in.\n   */\n  async logout() {\n    const {\n      success\n    } = await this.AuthQuerier.call({\n      procedureName: \"logout\",\n      params: undefined\n    });\n    const isRemoveAuthCookie = await this.localStorage.removeAuthCookie();\n    const isRemoveUserId = await this.localStorage.removeWalletUserId();\n    return {\n      success: success || isRemoveAuthCookie || isRemoveUserId\n    };\n  }\n}\n\nclass EthersSigner extends Signer {\n  constructor(_ref) {\n    let {\n      provider,\n      clientId,\n      querier\n    } = _ref;\n    super();\n    _defineProperty(this, \"DEFAULT_ETHEREUM_CHAIN_ID\", 5);\n    this.clientId = clientId;\n    this.querier = querier;\n    // we try to extract a url if possible\n    this.endpoint = provider.connection?.url;\n    defineReadOnly(this, \"provider\", provider);\n  }\n  async getAddress() {\n    const {\n      address\n    } = await this.querier.call({\n      procedureName: \"getAddress\",\n      params: undefined\n    });\n    return address;\n  }\n  async signMessage(message) {\n    const {\n      signedMessage\n    } = await this.querier.call({\n      procedureName: \"signMessage\",\n      params: {\n        message,\n        chainId: (await this.provider?.getNetwork())?.chainId ?? this.DEFAULT_ETHEREUM_CHAIN_ID,\n        rpcEndpoint: this.endpoint\n      }\n    });\n    return signedMessage;\n  }\n  async signTransaction(transaction) {\n    const {\n      signedTransaction\n    } = await this.querier.call({\n      procedureName: \"signTransaction\",\n      params: {\n        transaction,\n        chainId: (await this.provider?.getNetwork())?.chainId ?? this.DEFAULT_ETHEREUM_CHAIN_ID,\n        rpcEndpoint: this.endpoint\n      }\n    });\n    return signedTransaction;\n  }\n  async _signTypedData(domain, types, message) {\n    const {\n      signedTypedData\n    } = await this.querier.call({\n      procedureName: \"signTypedDataV4\",\n      params: {\n        domain,\n        types,\n        message,\n        chainId: (await this.provider?.getNetwork())?.chainId ?? this.DEFAULT_ETHEREUM_CHAIN_ID,\n        rpcEndpoint: this.endpoint\n      }\n    });\n    return signedTypedData;\n  }\n  connect(provider) {\n    return new EthersSigner({\n      clientId: this.clientId,\n      provider,\n      querier: this.querier\n    });\n  }\n}\n\nclass EmbeddedWallet {\n  /**\n   * Not meant to be initialized directly. Call {@link .initializeUser} to get an instance\n   * @param param0\n   */\n  constructor(_ref) {\n    let {\n      clientId,\n      chain,\n      querier\n    } = _ref;\n    this.clientId = clientId;\n    this.chain = chain;\n    this.walletManagerQuerier = querier;\n    this.localStorage = new LocalStorage({\n      clientId\n    });\n  }\n\n  /**\n   * @internal\n   * Used to set-up the user device in the case that they are using incognito\n   * @param {string} param.deviceShareStored the value that is saved for the user's device share.\n   * We save this into the localStorage on the site itself if we could not save it within the iframe's localStorage.\n   * This happens in incognito mostly\n   * @param {string} param.walletAddress User's wallet address\n   * @param {boolean} param.isIframeStorageEnabled Tells us if we were able to store values in the localStorage in our iframe.\n   * We need to store it under the dev's domain localStorage if we weren't able to store things in the iframe\n   * @returns {{ walletAddress : string }} The user's wallet details\n   */\n  async postWalletSetUp(_ref2) {\n    let {\n      deviceShareStored,\n      walletAddress,\n      isIframeStorageEnabled,\n      walletUserId\n    } = _ref2;\n    if (!isIframeStorageEnabled) {\n      await this.localStorage.saveDeviceShare(deviceShareStored, walletUserId);\n    }\n    return {\n      walletAddress\n    };\n  }\n\n  /**\n   * @internal\n   * Gets the various status states of the user\n   * @example\n   *  const userStatus = await Paper.getUserWalletStatus();\n   *  switch (userStatus.status) {\n   *  case UserWalletStatus.LOGGED_OUT: {\n   *    // User is logged out, call one of the auth methods on Paper.auth to authenticate the user\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED: {\n   *    // User is logged in, but does not have a wallet associated with it\n   *    // you also have access to the user's details\n   *    userStatus.user.authDetails;\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_NEW_DEVICE: {\n   *    // User is logged in and created a wallet already, but is missing the device shard\n   *    // You have access to:\n   *    userStatus.user.authDetails;\n   *    userStatus.user.walletAddress;\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED: {\n   *    // user is logged in and wallet is all set up.\n   *    // You have access to:\n   *    userStatus.user.authDetails;\n   *    userStatus.user.walletAddress;\n   *    userStatus.user.wallet;\n   *    break;\n   *  }\n   *}\n   * @returns {GetUserWalletStatusFnReturnType} an object to containing various information on the user statuses\n   */\n  async getUserWalletStatus() {\n    const userStatus = await this.walletManagerQuerier.call({\n      procedureName: \"getUserStatus\",\n      params: undefined\n    });\n    if (userStatus.status === UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED) {\n      return {\n        status: UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED,\n        user: {\n          ...userStatus.user,\n          wallet: this\n        }\n      };\n    }\n    return userStatus;\n  }\n\n  /**\n   * @description\n   * Switches the chain that the user wallet is currently on.\n   * @example\n   * // user wallet will be set to Polygon\n   * const Paper = new ThirdwebEmbeddedWalletSdk({clientId: \"\", chain: \"Polygon\"});\n   * const user = await Paper.initializeUser();\n   * // Switch the user wallet to Mumbai\n   * await user.wallet.setChain({ chain: \"Mumbai\" });\n   * @param {Chain} params.chain The chain that we are changing the user wallet too\n   */\n  async setChain(_ref3) {\n    let {\n      chain\n    } = _ref3;\n    this.chain = chain;\n  }\n\n  /**\n   * Returns an Ethers.Js compatible signer that you can use in conjunction with the rest of dApp\n   * @example\n   * const Paper = new ThirdwebEmbeddedWalletSdk({clientId: \"\", chain: \"Polygon\"});\n   * const user = await Paper.getUser();\n   * if (user.status === UserStatus.LOGGED_IN_WALLET_INITIALIZED) {\n   *    // returns a signer on the Polygon mainnet\n   *    const signer = await user.getEthersJsSigner();\n   *    // returns a signer on the specified RPC endpoints\n   *    const signer = await user.getEthersJsSigner({rpcEndpoint: \"https://eth-rpc.gateway.pokt.network\"});\n   * }\n   * @param {Networkish} network.rpcEndpoint the rpc url where calls will be routed through\n   * @throws If attempting to call the function without the user wallet initialize on their current device. This should never happen if call {@link ThirdwebEmbeddedWalletSdk.initializeUser} before accessing this function\n   * @returns A signer that is compatible with Ether.js. Defaults to the public rpc on the chain specified when initializing the {@link ThirdwebEmbeddedWalletSdk} instance\n   */\n  async getEthersJsSigner(network) {\n    const signer = new EthersSigner({\n      clientId: this.clientId,\n      provider: getDefaultProvider(network?.rpcEndpoint ?? ChainToPublicRpc[this.chain]),\n      querier: this.walletManagerQuerier\n    });\n    return signer;\n  }\n}\n\nclass EmbeddedWalletSdk {\n  /**\n   * Used to manage the Auth state of the user.\n   */\n\n  isClientIdLegacyPaper(clientId) {\n    if (clientId.indexOf(\"-\") > 0 && clientId.length === 36) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @example\n   * const thirdwebEmbeddedWallet = new EmbeddedWalletSdk({ clientId: \"\", chain: \"Goerli\" });\n   * @param {string} initParams.clientId the clientId found on the {@link https://thirdweb.com/dashboard/settings dashboard settings}\n   * @param {Chain} initParams.chain sets the default chain that the EmbeddedWallet will live on.\n   * @param {CustomizationOptionsType} initParams.styles sets the default style override for any modal that pops up asking for user's details when creating wallet or logging in.\n   */\n  constructor(_ref) {\n    let {\n      clientId,\n      chain,\n      styles\n    } = _ref;\n    if (this.isClientIdLegacyPaper(clientId)) {\n      throw new Error(\"You are using a legacy clientId. Please use the clientId found on the thirdweb dashboard settings page\");\n    }\n    this.clientId = clientId;\n    this.querier = new EmbeddedWalletIframeCommunicator({\n      clientId,\n      customizationOptions: styles\n    });\n    this.wallet = new EmbeddedWallet({\n      clientId,\n      chain,\n      querier: this.querier\n    });\n    this.auth = new Auth({\n      clientId,\n      querier: this.querier,\n      onAuthSuccess: async authResult => {\n        await this.wallet.postWalletSetUp({\n          ...authResult.walletDetails,\n          walletUserId: authResult.storedToken.authDetails.userWalletId\n        });\n        await this.querier.call({\n          procedureName: \"initIframe\",\n          params: {\n            deviceShareStored: authResult.walletDetails.deviceShareStored,\n            clientId: this.clientId,\n            walletUserId: authResult.storedToken.authDetails.userWalletId,\n            authCookie: authResult.storedToken.cookieString\n          }\n        });\n        return {\n          user: {\n            status: UserStatus.LOGGED_IN_WALLET_INITIALIZED,\n            authDetails: authResult.storedToken.authDetails,\n            wallet: this.wallet,\n            walletAddress: authResult.walletDetails.walletAddress\n          }\n        };\n      }\n    });\n  }\n\n  /**\n   * Gets the usr if they are logged in\n   * @example\n   *  const user = await thirdwebEmbeddedWallet.getUser();\n   *  switch (user.status) {\n   *     case UserStatus.LOGGED_OUT: {\n   *       // User is logged out, call one of the auth methods on thirdwebEmbeddedWallet.auth to authenticate the user\n   *       break;\n   *     }\n   *     case UserStatus.LOGGED_IN_WALLET_INITIALIZED: {\n   *       // user is logged in and wallet is all set up.\n   *       // You have access to:\n   *       user.status;\n   *       user.authDetails;\n   *       user.walletAddress;\n   *       user.wallet;\n   *       break;\n   *     }\n   *}\n   * @returns {GetUser} an object to containing various information on the user statuses\n   */\n  async getUser() {\n    const userStatus = await this.wallet.getUserWalletStatus();\n    switch (userStatus.status) {\n      // user gets {UserWalletStatus.LOGGED_IN_NEW_DEVICE} when they log in but never complete the recovery flow and exits (close modal, refresh etc)\n      case UserWalletStatus.LOGGED_IN_NEW_DEVICE:\n      // User gets {UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED} when they log in but manage to exit the client in the small window between auth completion and sending them their wallet recovery details\n      case UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED:\n        // in both case, we simply log them out to reset their state\n        await this.auth.logout();\n        return this.getUser();\n      case UserWalletStatus.LOGGED_OUT:\n        return {\n          status: UserStatus.LOGGED_OUT\n        };\n      case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED:\n        return {\n          status: UserStatus.LOGGED_IN_WALLET_INITIALIZED,\n          ...userStatus.user\n        };\n    }\n  }\n}\n\nexport { AUTH_TOKEN_LOCAL_STORAGE_NAME as A, DEVICE_SHARE_LOCAL_STORAGE_NAME as D, EmbeddedWalletSdk as E, UserStatus as U, WALLET_USER_DETAILS_LOCAL_STORAGE_NAME as W, DEVICE_SHARE_LOCAL_STORAGE_NAME_DEPRECATED as a, WALLET_USER_ID_LOCAL_STORAGE_NAME as b };\n"],"mappings":"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AAEA,OAAO;MAChB5H;IACF,CAAC,CAAC;EACJ;EACA,MAAM6H,QAAQA,CAAA,EAAG;IACf,MAAM,IAAI,CAACyC,MAAM,CAAC,CAAC;EACrB;EACA,MAAMxC,SAASA,CAACvB,KAAK,EAAE;IACrB,IAAI;MACFqD,WAAW;MACXE;IACF,CAAC,GAAGvD,KAAK;IACT,IAAIqD,WAAW,CAACC,uBAAuB,EAAE;MACvC,MAAM,IAAI,CAAC5I,YAAY,CAACS,cAAc,CAACkI,WAAW,CAACW,YAAY,CAAC;IAClE;IACA,MAAMC,eAAe,GAAG,MAAM,IAAI,CAACJ,aAAa,CAAC;MAC/CR,WAAW;MACXE;IACF,CAAC,CAAC;IACF,OAAOU,eAAe;EACxB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAM9B,cAAcA,CAAA,EAAG;IACrB,MAAM,IAAI,CAACb,QAAQ,CAAC,CAAC;IACrB,OAAO,IAAI,CAACM,SAAS,CAACO,cAAc,CAAC,CAAC;EACxC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMC,iBAAiBA,CAACE,IAAI,EAAE;IAC5B,OAAO,IAAI,CAACV,SAAS,CAACQ,iBAAiB,CAACE,IAAI,CAAC;EAC/C;EACA,MAAMD,eAAeA,CAACC,IAAI,EAAE;IAC1B,OAAO,IAAI,CAACV,SAAS,CAACS,eAAe,CAACC,IAAI,CAAC;EAC7C;;EAEA;AACF;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMb,iBAAiBA,CAACiC,KAAK,EAAE;IAC7B,IAAI;MACFhC;IACF,CAAC,GAAGgC,KAAK;IACT,OAAO,IAAI,CAAC9B,SAAS,CAACH,iBAAiB,CAAC;MACtCC;IACF,CAAC,CAAC;EACJ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"},"metadata":{},"sourceType":"module","externalDependencies":[]}